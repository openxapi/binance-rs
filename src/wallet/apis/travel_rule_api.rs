/*
 * Binance Wallet API
 *
 * OpenAPI specification for Binance exchange - Wallet API
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::wallet::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};

/// struct for passing parameters to the method [`wallet_create_localentity_broker_withdraw_apply_v1`]
#[derive(Clone, Debug, Default)]
pub struct WalletCreateLocalentityBrokerWithdrawApplyV1Params {
    pub address: String,
    pub amount: String,
    pub coin: String,
    pub originator_pii: String,
    pub questionnaire: String,
    pub signature: String,
    pub sub_account_id: String,
    pub timestamp: i64,
    pub withdraw_order_id: String,
    pub address_name: Option<String>,
    pub address_tag: Option<String>,
    pub network: Option<String>,
    pub transaction_fee_flag: Option<bool>,
    pub wallet_type: Option<i32>
}

/// struct for passing parameters to the method [`wallet_create_localentity_withdraw_apply_v1`]
#[derive(Clone, Debug, Default)]
pub struct WalletCreateLocalentityWithdrawApplyV1Params {
    pub address: String,
    pub amount: String,
    pub coin: String,
    pub questionnaire: String,
    pub timestamp: i64,
    pub address_tag: Option<String>,
    pub name: Option<String>,
    pub network: Option<String>,
    pub recv_window: Option<i64>,
    pub transaction_fee_flag: Option<bool>,
    pub wallet_type: Option<i32>,
    pub withdraw_order_id: Option<String>
}

/// struct for passing parameters to the method [`wallet_get_localentity_deposit_history_v1`]
#[derive(Clone, Debug, Default)]
pub struct WalletGetLocalentityDepositHistoryV1Params {
    pub timestamp: i64,
    /// Comma(,) separated list of travel rule record Ids.
    pub tr_id: Option<String>,
    /// Comma(,) separated list of transaction Ids.
    pub tx_id: Option<String>,
    /// Comma(,) separated list of wallet tran Ids.
    pub tran_id: Option<String>,
    pub network: Option<String>,
    pub coin: Option<String>,
    /// 0:Completed,1:Pending,2:Failed
    pub travel_rule_status: Option<i32>,
    /// true: Only return records that pending deposit questionnaire. false/not provided: return all records.
    pub pending_questionnaire: Option<bool>,
    /// Default: 90 days from current timestamp
    pub start_time: Option<i64>,
    /// Default: present timestamp
    pub end_time: Option<i64>,
    /// Default:0
    pub offset: Option<i32>,
    /// Default:1000, Max:1000
    pub limit: Option<i32>
}

/// struct for passing parameters to the method [`wallet_get_localentity_withdraw_history_v1`]
#[derive(Clone, Debug, Default)]
pub struct WalletGetLocalentityWithdrawHistoryV1Params {
    pub timestamp: i64,
    /// Comma(,) separated list of travel rule record Ids.
    pub tr_id: Option<String>,
    /// Comma(,) separated list of transaction Ids.
    pub tx_id: Option<String>,
    /// Comma(,) separated list of withdrawID defined by the client (i.e. client&#39;s internal withdrawID).
    pub withdraw_order_id: Option<String>,
    pub network: Option<String>,
    pub coin: Option<String>,
    /// 0:Completed,1:Pending,2:Failed
    pub travel_rule_status: Option<i32>,
    /// Default: 0
    pub offset: Option<i32>,
    /// Default: 1000, Max: 1000
    pub limit: Option<i32>,
    /// Default: 90 days from current timestamp
    pub start_time: Option<i64>,
    /// Default: present timestamp
    pub end_time: Option<i64>,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`wallet_get_localentity_withdraw_history_v2`]
#[derive(Clone, Debug, Default)]
pub struct WalletGetLocalentityWithdrawHistoryV2Params {
    pub timestamp: i64,
    /// Comma(,) separated list of travel rule record Ids.
    pub tr_id: Option<String>,
    /// Comma(,) separated list of transaction Ids.
    pub tx_id: Option<String>,
    /// Withdraw ID defined by the client (i.e. client&#39;s internal withdrawID).
    pub withdraw_order_id: Option<String>,
    pub network: Option<String>,
    pub coin: Option<String>,
    /// 0:Completed,1:Pending,2:Failed
    pub travel_rule_status: Option<i32>,
    /// Default: 0
    pub offset: Option<i32>,
    /// Default: 1000, Max: 1000
    pub limit: Option<i32>,
    /// Default: 90 days from current timestamp
    pub start_time: Option<i64>,
    /// Default: present timestamp
    pub end_time: Option<i64>,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`wallet_update_localentity_broker_deposit_provide_info_v1`]
#[derive(Clone, Debug, Default)]
pub struct WalletUpdateLocalentityBrokerDepositProvideInfoV1Params {
    pub beneficiary_pii: String,
    pub deposit_id: String,
    pub questionnaire: String,
    pub signature: String,
    pub sub_account_id: String,
    pub timestamp: i64,
    pub address: Option<String>,
    pub address_tag: Option<String>,
    pub amount: Option<String>,
    pub coin: Option<String>,
    pub network: Option<String>
}

/// struct for passing parameters to the method [`wallet_update_localentity_deposit_provide_info_v1`]
#[derive(Clone, Debug, Default)]
pub struct WalletUpdateLocalentityDepositProvideInfoV1Params {
    pub questionnaire: String,
    pub timestamp: i64,
    pub tran_id: i64
}


/// struct for typed errors of method [`wallet_create_localentity_broker_withdraw_apply_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WalletCreateLocalentityBrokerWithdrawApplyV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`wallet_create_localentity_withdraw_apply_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WalletCreateLocalentityWithdrawApplyV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`wallet_get_localentity_deposit_history_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WalletGetLocalentityDepositHistoryV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`wallet_get_localentity_vasp_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WalletGetLocalentityVaspV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`wallet_get_localentity_withdraw_history_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WalletGetLocalentityWithdrawHistoryV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`wallet_get_localentity_withdraw_history_v2`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WalletGetLocalentityWithdrawHistoryV2Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`wallet_update_localentity_broker_deposit_provide_info_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WalletUpdateLocalentityBrokerDepositProvideInfoV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`wallet_update_localentity_deposit_provide_info_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WalletUpdateLocalentityDepositProvideInfoV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}


/// Submit a withdrawal request for brokers of local entities that required travel rule.
pub async fn wallet_create_localentity_broker_withdraw_apply_v1(configuration: &configuration::Configuration, params: WalletCreateLocalentityBrokerWithdrawApplyV1Params) -> Result<models::WalletCreateLocalentityBrokerWithdrawApplyV1Resp, Error<WalletCreateLocalentityBrokerWithdrawApplyV1Error>> {

    let uri_str = format!("{}/sapi/v1/localentity/broker/withdraw/apply", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("address", params.address.to_string());
    if let Some(param_value) = params.address_name {
        multipart_form_params.insert("addressName", param_value.to_string());
    }
    if let Some(param_value) = params.address_tag {
        multipart_form_params.insert("addressTag", param_value.to_string());
    }
    multipart_form_params.insert("amount", params.amount.to_string());
    multipart_form_params.insert("coin", params.coin.to_string());
    if let Some(param_value) = params.network {
        multipart_form_params.insert("network", param_value.to_string());
    }
    multipart_form_params.insert("originatorPii", params.originator_pii.to_string());
    multipart_form_params.insert("questionnaire", params.questionnaire.to_string());
    multipart_form_params.insert("signature", params.signature.to_string());
    multipart_form_params.insert("subAccountId", params.sub_account_id.to_string());
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    if let Some(param_value) = params.transaction_fee_flag {
        multipart_form_params.insert("transactionFeeFlag", param_value.to_string());
    }
    if let Some(param_value) = params.wallet_type {
        multipart_form_params.insert("walletType", param_value.to_string());
    }
    multipart_form_params.insert("withdrawOrderId", params.withdraw_order_id.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WalletCreateLocalentityBrokerWithdrawApplyV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WalletCreateLocalentityBrokerWithdrawApplyV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WalletCreateLocalentityBrokerWithdrawApplyV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Submit a withdrawal request for local entities that required travel rule.
pub async fn wallet_create_localentity_withdraw_apply_v1(configuration: &configuration::Configuration, params: WalletCreateLocalentityWithdrawApplyV1Params) -> Result<models::WalletCreateLocalentityWithdrawApplyV1Resp, Error<WalletCreateLocalentityWithdrawApplyV1Error>> {

    let uri_str = format!("{}/sapi/v1/localentity/withdraw/apply", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("address", params.address.to_string());
    if let Some(param_value) = params.address_tag {
        multipart_form_params.insert("addressTag", param_value.to_string());
    }
    multipart_form_params.insert("amount", params.amount.to_string());
    multipart_form_params.insert("coin", params.coin.to_string());
    if let Some(param_value) = params.name {
        multipart_form_params.insert("name", param_value.to_string());
    }
    if let Some(param_value) = params.network {
        multipart_form_params.insert("network", param_value.to_string());
    }
    multipart_form_params.insert("questionnaire", params.questionnaire.to_string());
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    if let Some(param_value) = params.transaction_fee_flag {
        multipart_form_params.insert("transactionFeeFlag", param_value.to_string());
    }
    if let Some(param_value) = params.wallet_type {
        multipart_form_params.insert("walletType", param_value.to_string());
    }
    if let Some(param_value) = params.withdraw_order_id {
        multipart_form_params.insert("withdrawOrderId", param_value.to_string());
    }
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WalletCreateLocalentityWithdrawApplyV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WalletCreateLocalentityWithdrawApplyV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WalletCreateLocalentityWithdrawApplyV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fetch deposit history for local entities that required travel rule.
pub async fn wallet_get_localentity_deposit_history_v1(configuration: &configuration::Configuration, params: WalletGetLocalentityDepositHistoryV1Params) -> Result<Vec<models::WalletGetLocalentityDepositHistoryV1RespItem>, Error<WalletGetLocalentityDepositHistoryV1Error>> {

    let uri_str = format!("{}/sapi/v1/localentity/deposit/history", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.tr_id {
        query_params.push(("trId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.tx_id {
        query_params.push(("txId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.tran_id {
        query_params.push(("tranId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.network {
        query_params.push(("network".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.coin {
        query_params.push(("coin".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.travel_rule_status {
        query_params.push(("travelRuleStatus".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.pending_questionnaire {
        query_params.push(("pendingQuestionnaire".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.start_time {
        query_params.push(("startTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.end_time {
        query_params.push(("endTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.offset {
        query_params.push(("offset".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.limit {
        query_params.push(("limit".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::WalletGetLocalentityDepositHistoryV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::WalletGetLocalentityDepositHistoryV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WalletGetLocalentityDepositHistoryV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fetch the onboarded VASP list for local entities that required travel rule.
pub async fn wallet_get_localentity_vasp_v1(configuration: &configuration::Configuration) -> Result<Vec<models::WalletGetLocalentityVaspV1RespItem>, Error<WalletGetLocalentityVaspV1Error>> {

    let uri_str = format!("{}/sapi/v1/localentity/vasp", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::WalletGetLocalentityVaspV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::WalletGetLocalentityVaspV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WalletGetLocalentityVaspV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fetch withdraw history for local entities that required travel rule.
pub async fn wallet_get_localentity_withdraw_history_v1(configuration: &configuration::Configuration, params: WalletGetLocalentityWithdrawHistoryV1Params) -> Result<Vec<models::WalletGetLocalentityWithdrawHistoryV1RespItem>, Error<WalletGetLocalentityWithdrawHistoryV1Error>> {

    let uri_str = format!("{}/sapi/v1/localentity/withdraw/history", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.tr_id {
        query_params.push(("trId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.tx_id {
        query_params.push(("txId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.withdraw_order_id {
        query_params.push(("withdrawOrderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.network {
        query_params.push(("network".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.coin {
        query_params.push(("coin".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.travel_rule_status {
        query_params.push(("travelRuleStatus".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.offset {
        query_params.push(("offset".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.limit {
        query_params.push(("limit".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.start_time {
        query_params.push(("startTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.end_time {
        query_params.push(("endTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::WalletGetLocalentityWithdrawHistoryV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::WalletGetLocalentityWithdrawHistoryV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WalletGetLocalentityWithdrawHistoryV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fetch withdraw history for local entities that required travel rule.
pub async fn wallet_get_localentity_withdraw_history_v2(configuration: &configuration::Configuration, params: WalletGetLocalentityWithdrawHistoryV2Params) -> Result<Vec<models::WalletGetLocalentityWithdrawHistoryV2RespItem>, Error<WalletGetLocalentityWithdrawHistoryV2Error>> {

    let uri_str = format!("{}/sapi/v2/localentity/withdraw/history", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.tr_id {
        query_params.push(("trId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.tx_id {
        query_params.push(("txId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.withdraw_order_id {
        query_params.push(("withdrawOrderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.network {
        query_params.push(("network".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.coin {
        query_params.push(("coin".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.travel_rule_status {
        query_params.push(("travelRuleStatus".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.offset {
        query_params.push(("offset".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.limit {
        query_params.push(("limit".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.start_time {
        query_params.push(("startTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.end_time {
        query_params.push(("endTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::WalletGetLocalentityWithdrawHistoryV2RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::WalletGetLocalentityWithdrawHistoryV2RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WalletGetLocalentityWithdrawHistoryV2Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Submit questionnaire for brokers of local entities that require travel rule. The questionnaire is only applies to transactions from un-hosted wallets or VASPs that are not yet onboarded with GTR.
pub async fn wallet_update_localentity_broker_deposit_provide_info_v1(configuration: &configuration::Configuration, params: WalletUpdateLocalentityBrokerDepositProvideInfoV1Params) -> Result<models::WalletUpdateLocalentityBrokerDepositProvideInfoV1Resp, Error<WalletUpdateLocalentityBrokerDepositProvideInfoV1Error>> {

    let uri_str = format!("{}/sapi/v1/localentity/broker/deposit/provide-info", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    if let Some(param_value) = params.address {
        multipart_form_params.insert("address", param_value.to_string());
    }
    if let Some(param_value) = params.address_tag {
        multipart_form_params.insert("addressTag", param_value.to_string());
    }
    if let Some(param_value) = params.amount {
        multipart_form_params.insert("amount", param_value.to_string());
    }
    multipart_form_params.insert("beneficiaryPii", params.beneficiary_pii.to_string());
    if let Some(param_value) = params.coin {
        multipart_form_params.insert("coin", param_value.to_string());
    }
    multipart_form_params.insert("depositId", params.deposit_id.to_string());
    if let Some(param_value) = params.network {
        multipart_form_params.insert("network", param_value.to_string());
    }
    multipart_form_params.insert("questionnaire", params.questionnaire.to_string());
    multipart_form_params.insert("signature", params.signature.to_string());
    multipart_form_params.insert("subAccountId", params.sub_account_id.to_string());
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WalletUpdateLocalentityBrokerDepositProvideInfoV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WalletUpdateLocalentityBrokerDepositProvideInfoV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WalletUpdateLocalentityBrokerDepositProvideInfoV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Submit questionnaire for local entities that require travel rule. The questionnaire is only applies to transactions from unhosted wallets or VASPs that are not yet onboarded with GTR.
pub async fn wallet_update_localentity_deposit_provide_info_v1(configuration: &configuration::Configuration, params: WalletUpdateLocalentityDepositProvideInfoV1Params) -> Result<models::WalletUpdateLocalentityDepositProvideInfoV1Resp, Error<WalletUpdateLocalentityDepositProvideInfoV1Error>> {

    let uri_str = format!("{}/sapi/v1/localentity/deposit/provide-info", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("questionnaire", params.questionnaire.to_string());
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    multipart_form_params.insert("tranId", params.tran_id.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WalletUpdateLocalentityDepositProvideInfoV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WalletUpdateLocalentityDepositProvideInfoV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WalletUpdateLocalentityDepositProvideInfoV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

