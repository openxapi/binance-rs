/*
 * Binance Spot API
 *
 * OpenAPI specification for Binance exchange - Spot API
 *
 * The version of the OpenAPI document: 0.2.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::spot::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};

/// struct for passing parameters to the method [`create_order_cancel_replace_v3`]
#[derive(Clone, Debug, Default)]
pub struct CreateOrderCancelReplaceV3Params {
    pub cancel_replace_mode: String,
    pub side: String,
    pub symbol: String,
    pub timestamp: i64,
    pub r#type: String,
    pub cancel_new_client_order_id: Option<String>,
    pub cancel_order_id: Option<i64>,
    pub cancel_orig_client_order_id: Option<String>,
    pub cancel_restrictions: Option<String>,
    pub iceberg_qty: Option<String>,
    pub new_client_order_id: Option<String>,
    pub new_order_resp_type: Option<String>,
    pub order_rate_limit_exceeded_mode: Option<String>,
    pub price: Option<String>,
    pub quantity: Option<String>,
    pub quote_order_qty: Option<String>,
    pub recv_window: Option<i64>,
    pub self_trade_prevention_mode: Option<String>,
    pub stop_price: Option<String>,
    pub strategy_id: Option<i64>,
    pub strategy_type: Option<i32>,
    pub time_in_force: Option<String>,
    pub trailing_delta: Option<i64>
}

/// struct for passing parameters to the method [`create_order_list_oco_v3`]
#[derive(Clone, Debug, Default)]
pub struct CreateOrderListOcoV3Params {
    pub above_type: String,
    pub below_type: String,
    pub quantity: String,
    pub side: String,
    pub symbol: String,
    pub timestamp: i64,
    pub above_client_order_id: Option<String>,
    pub above_iceberg_qty: Option<i64>,
    pub above_price: Option<String>,
    pub above_stop_price: Option<String>,
    pub above_strategy_id: Option<i64>,
    pub above_strategy_type: Option<i32>,
    pub above_time_in_force: Option<String>,
    pub above_trailing_delta: Option<i64>,
    pub below_client_order_id: Option<String>,
    pub below_iceberg_qty: Option<i64>,
    pub below_price: Option<String>,
    pub below_stop_price: Option<String>,
    pub below_strategy_id: Option<i64>,
    pub below_strategy_type: Option<i32>,
    pub below_time_in_force: Option<String>,
    pub below_trailing_delta: Option<i64>,
    pub list_client_order_id: Option<String>,
    pub new_order_resp_type: Option<String>,
    pub recv_window: Option<i64>,
    pub self_trade_prevention_mode: Option<String>
}

/// struct for passing parameters to the method [`create_order_list_oto_v3`]
#[derive(Clone, Debug, Default)]
pub struct CreateOrderListOtoV3Params {
    pub pending_quantity: String,
    pub pending_side: String,
    pub pending_type: String,
    pub symbol: String,
    pub timestamp: i64,
    pub working_price: String,
    pub working_quantity: String,
    pub working_side: String,
    pub working_type: String,
    pub list_client_order_id: Option<String>,
    pub new_order_resp_type: Option<String>,
    pub pending_client_order_id: Option<String>,
    pub pending_iceberg_qty: Option<String>,
    pub pending_price: Option<String>,
    pub pending_stop_price: Option<String>,
    pub pending_strategy_id: Option<i64>,
    pub pending_strategy_type: Option<i32>,
    pub pending_time_in_force: Option<String>,
    pub pending_trailing_delta: Option<String>,
    pub recv_window: Option<i64>,
    pub self_trade_prevention_mode: Option<String>,
    pub working_client_order_id: Option<String>,
    pub working_iceberg_qty: Option<String>,
    pub working_strategy_id: Option<i64>,
    pub working_strategy_type: Option<i32>,
    pub working_time_in_force: Option<String>
}

/// struct for passing parameters to the method [`create_order_list_otoco_v3`]
#[derive(Clone, Debug, Default)]
pub struct CreateOrderListOtocoV3Params {
    pub pending_above_type: String,
    pub pending_quantity: String,
    pub pending_side: String,
    pub symbol: String,
    pub timestamp: i64,
    pub working_price: String,
    pub working_quantity: String,
    pub working_side: String,
    pub working_type: String,
    pub list_client_order_id: Option<String>,
    pub new_order_resp_type: Option<String>,
    pub pending_above_client_order_id: Option<String>,
    pub pending_above_iceberg_qty: Option<String>,
    pub pending_above_price: Option<String>,
    pub pending_above_stop_price: Option<String>,
    pub pending_above_strategy_id: Option<i64>,
    pub pending_above_strategy_type: Option<i32>,
    pub pending_above_time_in_force: Option<String>,
    pub pending_above_trailing_delta: Option<String>,
    pub pending_below_client_order_id: Option<String>,
    pub pending_below_iceberg_qty: Option<String>,
    pub pending_below_price: Option<String>,
    pub pending_below_stop_price: Option<String>,
    pub pending_below_strategy_id: Option<i64>,
    pub pending_below_strategy_type: Option<i32>,
    pub pending_below_time_in_force: Option<String>,
    pub pending_below_trailing_delta: Option<String>,
    pub pending_below_type: Option<String>,
    pub recv_window: Option<i64>,
    pub self_trade_prevention_mode: Option<String>,
    pub working_client_order_id: Option<String>,
    pub working_iceberg_qty: Option<String>,
    pub working_strategy_id: Option<i64>,
    pub working_strategy_type: Option<i32>,
    pub working_time_in_force: Option<String>
}

/// struct for passing parameters to the method [`create_order_oco_v3`]
#[derive(Clone, Debug, Default)]
pub struct CreateOrderOcoV3Params {
    pub price: String,
    pub quantity: String,
    pub side: String,
    pub stop_price: String,
    pub symbol: String,
    pub timestamp: i64,
    pub limit_client_order_id: Option<String>,
    pub limit_iceberg_qty: Option<String>,
    pub limit_strategy_id: Option<i64>,
    pub limit_strategy_type: Option<i32>,
    pub list_client_order_id: Option<String>,
    pub new_order_resp_type: Option<String>,
    pub recv_window: Option<i64>,
    pub self_trade_prevention_mode: Option<String>,
    pub stop_client_order_id: Option<String>,
    pub stop_iceberg_qty: Option<String>,
    pub stop_limit_price: Option<String>,
    pub stop_limit_time_in_force: Option<String>,
    pub stop_strategy_id: Option<i64>,
    pub stop_strategy_type: Option<i32>,
    pub trailing_delta: Option<i64>
}

/// struct for passing parameters to the method [`create_order_test_v3`]
#[derive(Clone, Debug, Default)]
pub struct CreateOrderTestV3Params {
    pub side: String,
    pub symbol: String,
    pub timestamp: i64,
    pub r#type: String,
    pub compute_commission_rates: Option<bool>,
    pub iceberg_qty: Option<String>,
    pub new_client_order_id: Option<String>,
    pub new_order_resp_type: Option<String>,
    pub price: Option<String>,
    pub quantity: Option<String>,
    pub quote_order_qty: Option<String>,
    pub recv_window: Option<i64>,
    pub self_trade_prevention_mode: Option<String>,
    pub stop_price: Option<String>,
    pub strategy_id: Option<i64>,
    pub strategy_type: Option<i32>,
    pub time_in_force: Option<String>,
    pub trailing_delta: Option<i64>
}

/// struct for passing parameters to the method [`create_order_v3`]
#[derive(Clone, Debug, Default)]
pub struct CreateOrderV3Params {
    pub side: String,
    pub symbol: String,
    pub timestamp: i64,
    pub r#type: String,
    pub iceberg_qty: Option<String>,
    pub new_client_order_id: Option<String>,
    pub new_order_resp_type: Option<String>,
    pub price: Option<String>,
    pub quantity: Option<String>,
    pub quote_order_qty: Option<String>,
    pub recv_window: Option<i64>,
    pub self_trade_prevention_mode: Option<String>,
    pub stop_price: Option<String>,
    pub strategy_id: Option<i64>,
    pub strategy_type: Option<i32>,
    pub time_in_force: Option<String>,
    pub trailing_delta: Option<i64>
}

/// struct for passing parameters to the method [`create_sor_order_test_v3`]
#[derive(Clone, Debug, Default)]
pub struct CreateSorOrderTestV3Params {
    pub quantity: String,
    pub side: String,
    pub symbol: String,
    pub timestamp: i64,
    pub r#type: String,
    pub compute_commission_rates: Option<bool>,
    pub iceberg_qty: Option<String>,
    pub new_client_order_id: Option<String>,
    pub new_order_resp_type: Option<String>,
    pub price: Option<String>,
    pub recv_window: Option<i64>,
    pub self_trade_prevention_mode: Option<String>,
    pub strategy_id: Option<i64>,
    pub strategy_type: Option<i32>,
    pub time_in_force: Option<String>
}

/// struct for passing parameters to the method [`create_sor_order_v3`]
#[derive(Clone, Debug, Default)]
pub struct CreateSorOrderV3Params {
    pub quantity: String,
    pub side: String,
    pub symbol: String,
    pub timestamp: i64,
    pub r#type: String,
    pub iceberg_qty: Option<String>,
    pub new_client_order_id: Option<String>,
    pub new_order_resp_type: Option<String>,
    pub price: Option<String>,
    pub recv_window: Option<i64>,
    pub self_trade_prevention_mode: Option<String>,
    pub strategy_id: Option<i64>,
    pub strategy_type: Option<i32>,
    pub time_in_force: Option<String>
}

/// struct for passing parameters to the method [`delete_open_orders_v3`]
#[derive(Clone, Debug, Default)]
pub struct DeleteOpenOrdersV3Params {
    pub symbol: String,
    pub timestamp: i64,
    /// The value cannot be greater than `60000`
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`delete_order_list_v3`]
#[derive(Clone, Debug, Default)]
pub struct DeleteOrderListV3Params {
    pub symbol: String,
    pub timestamp: i64,
    /// Either `orderListId` or `listClientOrderId` must be provided
    pub order_list_id: Option<i64>,
    /// Either `orderListId` or `listClientOrderId` must be provided
    pub list_client_order_id: Option<String>,
    /// Used to uniquely identify this cancel. Automatically generated by default
    pub new_client_order_id: Option<String>,
    /// The value cannot be greater than `60000`
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`delete_order_v3`]
#[derive(Clone, Debug, Default)]
pub struct DeleteOrderV3Params {
    pub symbol: String,
    pub timestamp: i64,
    pub order_id: Option<i64>,
    pub orig_client_order_id: Option<String>,
    /// Used to uniquely identify this cancel. Automatically generated by default.
    pub new_client_order_id: Option<String>,
    /// Supported values: <br/>`ONLY_NEW` - Cancel will succeed if the order status is `NEW`.<br/> `ONLY_PARTIALLY_FILLED ` - Cancel will succeed if order status is `PARTIALLY_FILLED`.
    pub cancel_restrictions: Option<String>,
    /// The value cannot be greater than `60000`.
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`delete_user_data_stream_v3`]
#[derive(Clone, Debug, Default)]
pub struct DeleteUserDataStreamV3Params {
    pub listen_key: String
}

/// struct for passing parameters to the method [`get_account_commission_v3`]
#[derive(Clone, Debug, Default)]
pub struct GetAccountCommissionV3Params {
    pub symbol: String
}

/// struct for passing parameters to the method [`get_account_v3`]
#[derive(Clone, Debug, Default)]
pub struct GetAccountV3Params {
    pub timestamp: i64,
    /// When set to `true`, emits only the non-zero balances of an account. <br/>Default value: `false`
    pub omit_zero_balances: Option<bool>,
    /// The value cannot be greater than `60000`
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_agg_trades_v3`]
#[derive(Clone, Debug, Default)]
pub struct GetAggTradesV3Params {
    pub symbol: String,
    /// ID to get aggregate trades from INCLUSIVE.
    pub from_id: Option<i64>,
    /// Timestamp in ms to get aggregate trades from INCLUSIVE.
    pub start_time: Option<i64>,
    /// Timestamp in ms to get aggregate trades until INCLUSIVE.
    pub end_time: Option<i64>,
    /// Default 500; max 1000.
    pub limit: Option<i32>
}

/// struct for passing parameters to the method [`get_all_order_list_v3`]
#[derive(Clone, Debug, Default)]
pub struct GetAllOrderListV3Params {
    pub timestamp: i64,
    /// If supplied, neither `startTime` or `endTime` can be provided
    pub from_id: Option<i64>,
    pub start_time: Option<i64>,
    pub end_time: Option<i64>,
    /// Default Value: 500; Max Value: 1000
    pub limit: Option<i32>,
    /// The value cannot be greater than `60000`
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_all_orders_v3`]
#[derive(Clone, Debug, Default)]
pub struct GetAllOrdersV3Params {
    pub symbol: String,
    pub timestamp: i64,
    pub order_id: Option<i64>,
    pub start_time: Option<i64>,
    pub end_time: Option<i64>,
    /// Default 500; max 1000.
    pub limit: Option<i32>,
    /// The value cannot be greater than `60000`
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_avg_price_v3`]
#[derive(Clone, Debug, Default)]
pub struct GetAvgPriceV3Params {
    pub symbol: String
}

/// struct for passing parameters to the method [`get_depth_v3`]
#[derive(Clone, Debug, Default)]
pub struct GetDepthV3Params {
    pub symbol: String,
    /// Default 100; max 5000. <br/> If limit &gt; 5000. then the response will truncate to 5000.
    pub limit: Option<i32>
}

/// struct for passing parameters to the method [`get_exchange_info_v3`]
#[derive(Clone, Debug, Default)]
pub struct GetExchangeInfoV3Params {
    /// Example: curl -X GET &#34;<a href=\"https://api.binance.com/api/v3/exchangeInfo?symbol=BNBBTC\" target=\"_blank\" rel=\"noopener noreferrer\">https://api.binance.com/api/v3/exchangeInfo?symbol=BNBBTC</a>&#34;
    pub symbol: Option<String>,
    /// Examples: curl -X GET &#34;<a href=\"https://api.binance.com/api/v3/exchangeInfo?symbols=%5B%22BNBBTC%22,%22BTCUSDT%22%5D\" target=\"_blank\" rel=\"noopener noreferrer\">https://api.binance.com/api/v3/exchangeInfo?symbols=%5B%22BNBBTC%22,%22BTCUSDT%22%5D</a>&#34; <br/> or <br/> curl -g -X  GET &#39;<a href=\"https://api.binance.com/api/v3/exchangeInfo?symbols=%5B%22BTCUSDT%22,%22BNBBTC\" target=\"_blank\" rel=\"noopener noreferrer\">https://api.binance.com/api/v3/exchangeInfo?symbols=[&#34;BTCUSDT&#34;,&#34;BNBBTC</a>&#34;]&#39;
    pub symbols: Option<Vec<String>>,
    /// Examples: curl -X GET &#34;<a href=\"https://api.binance.com/api/v3/exchangeInfo?permissions=SPOT\" target=\"_blank\" rel=\"noopener noreferrer\">https://api.binance.com/api/v3/exchangeInfo?permissions=SPOT</a>&#34; <br/> or <br/> curl -X GET &#34;<a href=\"https://api.binance.com/api/v3/exchangeInfo?permissions=%5B%22MARGIN%22%2C%22LEVERAGED%22%5D\" target=\"_blank\" rel=\"noopener noreferrer\">https://api.binance.com/api/v3/exchangeInfo?permissions=%5B%22MARGIN%22%2C%22LEVERAGED%22%5D</a>&#34; <br/> or <br/> curl -g -X GET &#39;<a href=\"https://api.binance.com/api/v3/exchangeInfo?permissions=%5B%22MARGIN%22,%22LEVERAGED\" target=\"_blank\" rel=\"noopener noreferrer\">https://api.binance.com/api/v3/exchangeInfo?permissions=[&#34;MARGIN&#34;,&#34;LEVERAGED</a>&#34;]&#39;
    pub permissions: Option<String>,
    /// Controls whether the content of the `permissionSets` field is populated or not. Defaults to `true`
    pub show_permission_sets: Option<bool>,
    /// Filters symbols that have this `tradingStatus`. Valid values: `TRADING`, `HALT`, `BREAK` <br/> Cannot be used in combination with `symbols` or `symbol`.
    pub symbol_status: Option<String>
}

/// struct for passing parameters to the method [`get_historical_trades_v3`]
#[derive(Clone, Debug, Default)]
pub struct GetHistoricalTradesV3Params {
    pub symbol: String,
    /// Default 500; max 1000.
    pub limit: Option<i32>,
    /// TradeId to fetch from. Default gets most recent trades.
    pub from_id: Option<i64>
}

/// struct for passing parameters to the method [`get_klines_v3`]
#[derive(Clone, Debug, Default)]
pub struct GetKlinesV3Params {
    pub symbol: String,
    pub interval: String,
    pub start_time: Option<i64>,
    pub end_time: Option<i64>,
    /// Default: 0 (UTC)
    pub time_zone: Option<String>,
    /// Default 500; max 1000.
    pub limit: Option<i32>
}

/// struct for passing parameters to the method [`get_my_allocations_v3`]
#[derive(Clone, Debug, Default)]
pub struct GetMyAllocationsV3Params {
    pub symbol: String,
    pub start_time: Option<i64>,
    pub end_time: Option<i64>,
    pub from_allocation_id: Option<i32>,
    /// Default 500;Max 1000
    pub limit: Option<i32>,
    pub order_id: Option<i64>,
    /// The value cannot be greater than `60000`.
    pub recv_window: Option<i64>,
    pub timestamp: Option<i64>
}

/// struct for passing parameters to the method [`get_my_prevented_matches_v3`]
#[derive(Clone, Debug, Default)]
pub struct GetMyPreventedMatchesV3Params {
    pub symbol: String,
    pub timestamp: i64,
    pub prevented_match_id: Option<i64>,
    pub order_id: Option<i64>,
    pub from_prevented_match_id: Option<i64>,
    /// Default: `500`; Max: `1000`
    pub limit: Option<i32>,
    /// The value cannot be greater than `60000`
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_my_trades_v3`]
#[derive(Clone, Debug, Default)]
pub struct GetMyTradesV3Params {
    pub symbol: String,
    pub timestamp: i64,
    /// This can only be used in combination with `symbol`.
    pub order_id: Option<i64>,
    pub start_time: Option<i64>,
    pub end_time: Option<i64>,
    /// TradeId to fetch from. Default gets most recent trades.
    pub from_id: Option<i64>,
    /// Default 500; max 1000.
    pub limit: Option<i32>,
    /// The value cannot be greater than `60000`
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_open_order_list_v3`]
#[derive(Clone, Debug, Default)]
pub struct GetOpenOrderListV3Params {
    pub timestamp: i64,
    /// The value cannot be greater than `60000`
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_open_orders_v3`]
#[derive(Clone, Debug, Default)]
pub struct GetOpenOrdersV3Params {
    pub timestamp: i64,
    pub symbol: Option<String>,
    /// The value cannot be greater than `60000`
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_order_list_v3`]
#[derive(Clone, Debug, Default)]
pub struct GetOrderListV3Params {
    pub timestamp: i64,
    /// Either `orderListId` or `listClientOrderId` must be provided
    pub order_list_id: Option<i64>,
    /// Either `orderListId` or `listClientOrderId` must be provided
    pub orig_client_order_id: Option<String>,
    /// The value cannot be greater than `60000`
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_order_v3`]
#[derive(Clone, Debug, Default)]
pub struct GetOrderV3Params {
    pub symbol: String,
    pub timestamp: i64,
    pub order_id: Option<i64>,
    pub orig_client_order_id: Option<String>,
    /// The value cannot be greater than `60000`
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_rate_limit_order_v3`]
#[derive(Clone, Debug, Default)]
pub struct GetRateLimitOrderV3Params {
    pub timestamp: i64,
    /// The value cannot be greater than `60000`
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_ticker24hr_v3`]
#[derive(Clone, Debug, Default)]
pub struct GetTicker24hrV3Params {
    /// Parameter symbol and symbols cannot be used in combination. <br/> If neither parameter is sent, tickers for all symbols will be returned in an array. <br/><br/>          Examples of accepted format for the symbols parameter:          [&#34;BTCUSDT&#34;,&#34;BNBUSDT&#34;] <br/>          or <br/>          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D
    pub symbol: Option<String>,
    /// Parameter symbol and symbols cannot be used in combination. <br/> If neither parameter is sent, tickers for all symbols will be returned in an array. <br/><br/>          Examples of accepted format for the symbols parameter:          [&#34;BTCUSDT&#34;,&#34;BNBUSDT&#34;] <br/>          or <br/>          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D
    pub symbols: Option<String>,
    /// Supported values: `FULL` or `MINI`. <br/>If none provided, the default is `FULL`
    pub r#type: Option<String>
}

/// struct for passing parameters to the method [`get_ticker_book_ticker_v3`]
#[derive(Clone, Debug, Default)]
pub struct GetTickerBookTickerV3Params {
    /// Parameter symbol and symbols cannot be used in combination. <br/> If neither parameter is sent, bookTickers for all symbols will be returned in an array.          <br/><br/>         Examples of accepted format for the symbols parameter:          [&#34;BTCUSDT&#34;,&#34;BNBUSDT&#34;] <br/>          or <br/>          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D
    pub symbol: Option<String>,
    /// Parameter symbol and symbols cannot be used in combination. <br/> If neither parameter is sent, bookTickers for all symbols will be returned in an array.          <br/><br/>         Examples of accepted format for the symbols parameter:          [&#34;BTCUSDT&#34;,&#34;BNBUSDT&#34;] <br/>          or <br/>          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D
    pub symbols: Option<String>
}

/// struct for passing parameters to the method [`get_ticker_price_v3`]
#[derive(Clone, Debug, Default)]
pub struct GetTickerPriceV3Params {
    /// Parameter symbol and symbols cannot be used in combination. <br/> If neither parameter is sent, prices for all symbols will be returned in an array. <br/><br/>         Examples of accepted format for the symbols parameter:          [&#34;BTCUSDT&#34;,&#34;BNBUSDT&#34;] <br/>          or <br/>          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D
    pub symbol: Option<String>,
    /// Parameter symbol and symbols cannot be used in combination. <br/> If neither parameter is sent, prices for all symbols will be returned in an array. <br/><br/>         Examples of accepted format for the symbols parameter:          [&#34;BTCUSDT&#34;,&#34;BNBUSDT&#34;] <br/>          or <br/>          %5B%22BTCUSDT%22,%22BNBUSDT%22%5D
    pub symbols: Option<String>
}

/// struct for passing parameters to the method [`get_ticker_trading_day_v3`]
#[derive(Clone, Debug, Default)]
pub struct GetTickerTradingDayV3Params {
    /// Either `symbol` or `symbols` must be provided <br/><br/> Examples of accepted format for the `symbols` parameter: <br/> [&#34;BTCUSDT&#34;,&#34;BNBUSDT&#34;] <br/>or <br/>%5B%22BTCUSDT%22,%22BNBUSDT%22%5D <br/><br/> The maximum number of `symbols` allowed in a request is 100.
    pub symbol: String,
    /// Either `symbol` or `symbols` must be provided <br/><br/> Examples of accepted format for the `symbols` parameter: <br/> [&#34;BTCUSDT&#34;,&#34;BNBUSDT&#34;] <br/>or <br/>%5B%22BTCUSDT%22,%22BNBUSDT%22%5D <br/><br/> The maximum number of `symbols` allowed in a request is 100.
    pub symbols: String,
    /// Default: 0 (UTC)
    pub time_zone: Option<String>,
    /// Supported values: `FULL` or `MINI`. <br/>If none provided, the default is `FULL`
    pub r#type: Option<String>
}

/// struct for passing parameters to the method [`get_ticker_v3`]
#[derive(Clone, Debug, Default)]
pub struct GetTickerV3Params {
    /// Either `symbol` or `symbols` must be provided <br/><br/> Examples of accepted format for the `symbols` parameter: <br/> [&#34;BTCUSDT&#34;,&#34;BNBUSDT&#34;] <br/>or <br/>%5B%22BTCUSDT%22,%22BNBUSDT%22%5D <br/><br/> The maximum number of `symbols` allowed in a request is 100.
    pub symbol: String,
    /// Either `symbol` or `symbols` must be provided <br/><br/> Examples of accepted format for the `symbols` parameter: <br/> [&#34;BTCUSDT&#34;,&#34;BNBUSDT&#34;] <br/>or <br/>%5B%22BTCUSDT%22,%22BNBUSDT%22%5D <br/><br/> The maximum number of `symbols` allowed in a request is 100.
    pub symbols: String,
    /// Defaults to `1d` if no parameter provided <br/> Supported `windowSize` values: <br/> `1m`,`2m`....`59m` for minutes <br/> `1h`, `2h`....`23h` - for hours <br/> `1d`...`7d` - for days <br/><br/> Units cannot be combined (e.g. `1d2h` is not allowed)
    pub window_size: Option<String>,
    /// Supported values: `FULL` or `MINI`. <br/>If none provided, the default is `FULL`
    pub r#type: Option<String>
}

/// struct for passing parameters to the method [`get_trades_v3`]
#[derive(Clone, Debug, Default)]
pub struct GetTradesV3Params {
    pub symbol: String,
    /// Default 500; max 1000.
    pub limit: Option<i32>
}

/// struct for passing parameters to the method [`get_ui_klines_v3`]
#[derive(Clone, Debug, Default)]
pub struct GetUiKlinesV3Params {
    pub symbol: String,
    /// See <a href=\"/docs/binance-spot-api-docs/rest-api/market-data-endpoints#kline-intervals\">`klines`</a>
    pub interval: String,
    pub start_time: Option<i64>,
    pub end_time: Option<i64>,
    /// Default: 0 (UTC)
    pub time_zone: Option<String>,
    /// Default 500; max 1000.
    pub limit: Option<i32>
}

/// struct for passing parameters to the method [`update_user_data_stream_v3`]
#[derive(Clone, Debug, Default)]
pub struct UpdateUserDataStreamV3Params {
    pub listen_key: String
}


/// struct for typed errors of method [`create_order_cancel_replace_v3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateOrderCancelReplaceV3Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_order_list_oco_v3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateOrderListOcoV3Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_order_list_oto_v3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateOrderListOtoV3Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_order_list_otoco_v3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateOrderListOtocoV3Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_order_oco_v3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateOrderOcoV3Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_order_test_v3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateOrderTestV3Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_order_v3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateOrderV3Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_sor_order_test_v3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSorOrderTestV3Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_sor_order_v3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSorOrderV3Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_user_data_stream_v3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateUserDataStreamV3Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_open_orders_v3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteOpenOrdersV3Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_order_list_v3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteOrderListV3Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_order_v3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteOrderV3Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_user_data_stream_v3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteUserDataStreamV3Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_account_commission_v3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAccountCommissionV3Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_account_v3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAccountV3Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_agg_trades_v3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAggTradesV3Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_all_order_list_v3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAllOrderListV3Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_all_orders_v3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAllOrdersV3Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_avg_price_v3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAvgPriceV3Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_depth_v3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDepthV3Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_exchange_info_v3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetExchangeInfoV3Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_historical_trades_v3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetHistoricalTradesV3Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_klines_v3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetKlinesV3Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_my_allocations_v3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMyAllocationsV3Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_my_prevented_matches_v3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMyPreventedMatchesV3Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_my_trades_v3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMyTradesV3Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_open_order_list_v3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetOpenOrderListV3Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_open_orders_v3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetOpenOrdersV3Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_order_list_v3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetOrderListV3Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_order_v3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetOrderV3Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_ping_v3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPingV3Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_rate_limit_order_v3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRateLimitOrderV3Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_ticker24hr_v3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTicker24hrV3Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_ticker_book_ticker_v3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTickerBookTickerV3Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_ticker_price_v3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTickerPriceV3Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_ticker_trading_day_v3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTickerTradingDayV3Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_ticker_v3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTickerV3Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_time_v3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTimeV3Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_trades_v3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTradesV3Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_ui_klines_v3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUiKlinesV3Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_user_data_stream_v3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateUserDataStreamV3Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}


/// Cancels an existing order and places a new order on the same symbol. Filters and Order Count are evaluated before the processing of the cancellation and order placement occurs. A new order that was not attempted (i.e. when newOrderResult: NOT_ATTEMPTED ), will still increase the order count by 1.
pub async fn create_order_cancel_replace_v3(configuration: &configuration::Configuration, params: CreateOrderCancelReplaceV3Params) -> Result<models::SpotCreateOrderCancelReplaceV3Resp, Error<CreateOrderCancelReplaceV3Error>> {

    let uri_str = format!("{}/api/v3/order/cancelReplace", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    if let Some(param_value) = params.cancel_new_client_order_id {
        multipart_form_params.insert("cancelNewClientOrderId", param_value.to_string());
    }
    if let Some(param_value) = params.cancel_order_id {
        multipart_form_params.insert("cancelOrderId", param_value.to_string());
    }
    if let Some(param_value) = params.cancel_orig_client_order_id {
        multipart_form_params.insert("cancelOrigClientOrderId", param_value.to_string());
    }
    multipart_form_params.insert("cancelReplaceMode", params.cancel_replace_mode.to_string());
    if let Some(param_value) = params.cancel_restrictions {
        multipart_form_params.insert("cancelRestrictions", param_value.to_string());
    }
    if let Some(param_value) = params.iceberg_qty {
        multipart_form_params.insert("icebergQty", param_value.to_string());
    }
    if let Some(param_value) = params.new_client_order_id {
        multipart_form_params.insert("newClientOrderId", param_value.to_string());
    }
    if let Some(param_value) = params.new_order_resp_type {
        multipart_form_params.insert("newOrderRespType", param_value.to_string());
    }
    if let Some(param_value) = params.order_rate_limit_exceeded_mode {
        multipart_form_params.insert("orderRateLimitExceededMode", param_value.to_string());
    }
    if let Some(param_value) = params.price {
        multipart_form_params.insert("price", param_value.to_string());
    }
    if let Some(param_value) = params.quantity {
        multipart_form_params.insert("quantity", param_value.to_string());
    }
    if let Some(param_value) = params.quote_order_qty {
        multipart_form_params.insert("quoteOrderQty", param_value.to_string());
    }
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    if let Some(param_value) = params.self_trade_prevention_mode {
        multipart_form_params.insert("selfTradePreventionMode", param_value.to_string());
    }
    multipart_form_params.insert("side", params.side.to_string());
    if let Some(param_value) = params.stop_price {
        multipart_form_params.insert("stopPrice", param_value.to_string());
    }
    if let Some(param_value) = params.strategy_id {
        multipart_form_params.insert("strategyId", param_value.to_string());
    }
    if let Some(param_value) = params.strategy_type {
        multipart_form_params.insert("strategyType", param_value.to_string());
    }
    multipart_form_params.insert("symbol", params.symbol.to_string());
    if let Some(param_value) = params.time_in_force {
        multipart_form_params.insert("timeInForce", param_value.to_string());
    }
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    if let Some(param_value) = params.trailing_delta {
        multipart_form_params.insert("trailingDelta", param_value.to_string());
    }
    multipart_form_params.insert("type", params.r#type.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SpotCreateOrderCancelReplaceV3Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SpotCreateOrderCancelReplaceV3Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateOrderCancelReplaceV3Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Send in an one-cancels-the-other (OCO) pair, where activation of one order immediately cancels the other. - An OCO has 2 orders called the above order and below order. - One of the orders must be a LIMIT_MAKER/TAKE_PROFIT/TAKE_PROFIT_LIMIT order and the other must be STOP_LOSS or STOP_LOSS_LIMIT order. - Price restrictions  If the OCO is on the SELL side:  LIMIT_MAKER/TAKE_PROFIT_LIMIT price > Last Traded Price >  STOP_LOSS/STOP_LOSS_LIMIT stopPrice TAKE_PROFIT stopPrice > Last Traded Price > STOP_LOSS/STOP_LOSS_LIMIT stopPrice   If the OCO is on the BUY side:  LIMIT_MAKER/TAKE_PROFIT_LIMIT price < Last Traded Price < stopPrice TAKE_PROFIT stopPrice < Last Traded Price < STOP_LOSS/STOP_LOSS_LIMIT stopPrice - OCOs add 2 orders to the unfilled order count, EXCHANGE_MAX_ORDERS filter, and the MAX_NUM_ORDERS filter.
pub async fn create_order_list_oco_v3(configuration: &configuration::Configuration, params: CreateOrderListOcoV3Params) -> Result<models::CreateOrderListOcoV3Resp, Error<CreateOrderListOcoV3Error>> {

    let uri_str = format!("{}/api/v3/orderList/oco", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    if let Some(param_value) = params.above_client_order_id {
        multipart_form_params.insert("aboveClientOrderId", param_value.to_string());
    }
    if let Some(param_value) = params.above_iceberg_qty {
        multipart_form_params.insert("aboveIcebergQty", param_value.to_string());
    }
    if let Some(param_value) = params.above_price {
        multipart_form_params.insert("abovePrice", param_value.to_string());
    }
    if let Some(param_value) = params.above_stop_price {
        multipart_form_params.insert("aboveStopPrice", param_value.to_string());
    }
    if let Some(param_value) = params.above_strategy_id {
        multipart_form_params.insert("aboveStrategyId", param_value.to_string());
    }
    if let Some(param_value) = params.above_strategy_type {
        multipart_form_params.insert("aboveStrategyType", param_value.to_string());
    }
    if let Some(param_value) = params.above_time_in_force {
        multipart_form_params.insert("aboveTimeInForce", param_value.to_string());
    }
    if let Some(param_value) = params.above_trailing_delta {
        multipart_form_params.insert("aboveTrailingDelta", param_value.to_string());
    }
    multipart_form_params.insert("aboveType", params.above_type.to_string());
    if let Some(param_value) = params.below_client_order_id {
        multipart_form_params.insert("belowClientOrderId", param_value.to_string());
    }
    if let Some(param_value) = params.below_iceberg_qty {
        multipart_form_params.insert("belowIcebergQty", param_value.to_string());
    }
    if let Some(param_value) = params.below_price {
        multipart_form_params.insert("belowPrice", param_value.to_string());
    }
    if let Some(param_value) = params.below_stop_price {
        multipart_form_params.insert("belowStopPrice", param_value.to_string());
    }
    if let Some(param_value) = params.below_strategy_id {
        multipart_form_params.insert("belowStrategyId", param_value.to_string());
    }
    if let Some(param_value) = params.below_strategy_type {
        multipart_form_params.insert("belowStrategyType", param_value.to_string());
    }
    if let Some(param_value) = params.below_time_in_force {
        multipart_form_params.insert("belowTimeInForce", param_value.to_string());
    }
    if let Some(param_value) = params.below_trailing_delta {
        multipart_form_params.insert("belowTrailingDelta", param_value.to_string());
    }
    multipart_form_params.insert("belowType", params.below_type.to_string());
    if let Some(param_value) = params.list_client_order_id {
        multipart_form_params.insert("listClientOrderId", param_value.to_string());
    }
    if let Some(param_value) = params.new_order_resp_type {
        multipart_form_params.insert("newOrderRespType", param_value.to_string());
    }
    multipart_form_params.insert("quantity", params.quantity.to_string());
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    if let Some(param_value) = params.self_trade_prevention_mode {
        multipart_form_params.insert("selfTradePreventionMode", param_value.to_string());
    }
    multipart_form_params.insert("side", params.side.to_string());
    multipart_form_params.insert("symbol", params.symbol.to_string());
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CreateOrderListOcoV3Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CreateOrderListOcoV3Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateOrderListOcoV3Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Places an OTO. - An OTO (One-Triggers-the-Other) is an order list comprised of 2 orders. - The first order is called the working order and must be LIMIT or LIMIT_MAKER. Initially, only the working order goes on the order book. - The second order is called the pending order. It can be any order type except for MARKET orders using parameter quoteOrderQty. The pending order is only placed on the order book when the working order gets fully filled. - If either the working order or the pending order is cancelled individually, the other order in the order list will also be canceled or expired. - When the order list is placed, if the working order gets immediately fully filled, the placement response will show the working order as FILLED but the pending order will still appear as PENDING_NEW. You need to query the status of the pending order again to see its updated status. - OTOs add 2 orders to the unfilled order count, EXCHANGE_MAX_NUM_ORDERS filter and MAX_NUM_ORDERS filter.
pub async fn create_order_list_oto_v3(configuration: &configuration::Configuration, params: CreateOrderListOtoV3Params) -> Result<models::CreateOrderListOtoV3Resp, Error<CreateOrderListOtoV3Error>> {

    let uri_str = format!("{}/api/v3/orderList/oto", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    if let Some(param_value) = params.list_client_order_id {
        multipart_form_params.insert("listClientOrderId", param_value.to_string());
    }
    if let Some(param_value) = params.new_order_resp_type {
        multipart_form_params.insert("newOrderRespType", param_value.to_string());
    }
    if let Some(param_value) = params.pending_client_order_id {
        multipart_form_params.insert("pendingClientOrderId", param_value.to_string());
    }
    if let Some(param_value) = params.pending_iceberg_qty {
        multipart_form_params.insert("pendingIcebergQty", param_value.to_string());
    }
    if let Some(param_value) = params.pending_price {
        multipart_form_params.insert("pendingPrice", param_value.to_string());
    }
    multipart_form_params.insert("pendingQuantity", params.pending_quantity.to_string());
    multipart_form_params.insert("pendingSide", params.pending_side.to_string());
    if let Some(param_value) = params.pending_stop_price {
        multipart_form_params.insert("pendingStopPrice", param_value.to_string());
    }
    if let Some(param_value) = params.pending_strategy_id {
        multipart_form_params.insert("pendingStrategyId", param_value.to_string());
    }
    if let Some(param_value) = params.pending_strategy_type {
        multipart_form_params.insert("pendingStrategyType", param_value.to_string());
    }
    if let Some(param_value) = params.pending_time_in_force {
        multipart_form_params.insert("pendingTimeInForce", param_value.to_string());
    }
    if let Some(param_value) = params.pending_trailing_delta {
        multipart_form_params.insert("pendingTrailingDelta", param_value.to_string());
    }
    multipart_form_params.insert("pendingType", params.pending_type.to_string());
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    if let Some(param_value) = params.self_trade_prevention_mode {
        multipart_form_params.insert("selfTradePreventionMode", param_value.to_string());
    }
    multipart_form_params.insert("symbol", params.symbol.to_string());
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    if let Some(param_value) = params.working_client_order_id {
        multipart_form_params.insert("workingClientOrderId", param_value.to_string());
    }
    if let Some(param_value) = params.working_iceberg_qty {
        multipart_form_params.insert("workingIcebergQty", param_value.to_string());
    }
    multipart_form_params.insert("workingPrice", params.working_price.to_string());
    multipart_form_params.insert("workingQuantity", params.working_quantity.to_string());
    multipart_form_params.insert("workingSide", params.working_side.to_string());
    if let Some(param_value) = params.working_strategy_id {
        multipart_form_params.insert("workingStrategyId", param_value.to_string());
    }
    if let Some(param_value) = params.working_strategy_type {
        multipart_form_params.insert("workingStrategyType", param_value.to_string());
    }
    if let Some(param_value) = params.working_time_in_force {
        multipart_form_params.insert("workingTimeInForce", param_value.to_string());
    }
    multipart_form_params.insert("workingType", params.working_type.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CreateOrderListOtoV3Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CreateOrderListOtoV3Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateOrderListOtoV3Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Place an OTOCO. - An OTOCO (One-Triggers-One-Cancels-the-Other) is an order list comprised of 3 orders. - The first order is called the working order and must be LIMIT or LIMIT_MAKER. Initially, only the working order goes on the order book.  The behavior of the working order is the same as the OTO. - OTOCO has 2 pending orders (pending above and pending below), forming an OCO pair. The pending orders are only placed on the order book when the working order gets fully filled.  The rules of the pending above and pending below follow the same rules as the Order list OCO. - OTOCOs add 3 orders against the unfilled order count, EXCHANGE_MAX_NUM_ORDERS filter, and MAX_NUM_ORDERS filter.
pub async fn create_order_list_otoco_v3(configuration: &configuration::Configuration, params: CreateOrderListOtocoV3Params) -> Result<models::CreateOrderListOtocoV3Resp, Error<CreateOrderListOtocoV3Error>> {

    let uri_str = format!("{}/api/v3/orderList/otoco", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    if let Some(param_value) = params.list_client_order_id {
        multipart_form_params.insert("listClientOrderId", param_value.to_string());
    }
    if let Some(param_value) = params.new_order_resp_type {
        multipart_form_params.insert("newOrderRespType", param_value.to_string());
    }
    if let Some(param_value) = params.pending_above_client_order_id {
        multipart_form_params.insert("pendingAboveClientOrderId", param_value.to_string());
    }
    if let Some(param_value) = params.pending_above_iceberg_qty {
        multipart_form_params.insert("pendingAboveIcebergQty", param_value.to_string());
    }
    if let Some(param_value) = params.pending_above_price {
        multipart_form_params.insert("pendingAbovePrice", param_value.to_string());
    }
    if let Some(param_value) = params.pending_above_stop_price {
        multipart_form_params.insert("pendingAboveStopPrice", param_value.to_string());
    }
    if let Some(param_value) = params.pending_above_strategy_id {
        multipart_form_params.insert("pendingAboveStrategyId", param_value.to_string());
    }
    if let Some(param_value) = params.pending_above_strategy_type {
        multipart_form_params.insert("pendingAboveStrategyType", param_value.to_string());
    }
    if let Some(param_value) = params.pending_above_time_in_force {
        multipart_form_params.insert("pendingAboveTimeInForce", param_value.to_string());
    }
    if let Some(param_value) = params.pending_above_trailing_delta {
        multipart_form_params.insert("pendingAboveTrailingDelta", param_value.to_string());
    }
    multipart_form_params.insert("pendingAboveType", params.pending_above_type.to_string());
    if let Some(param_value) = params.pending_below_client_order_id {
        multipart_form_params.insert("pendingBelowClientOrderId", param_value.to_string());
    }
    if let Some(param_value) = params.pending_below_iceberg_qty {
        multipart_form_params.insert("pendingBelowIcebergQty", param_value.to_string());
    }
    if let Some(param_value) = params.pending_below_price {
        multipart_form_params.insert("pendingBelowPrice", param_value.to_string());
    }
    if let Some(param_value) = params.pending_below_stop_price {
        multipart_form_params.insert("pendingBelowStopPrice", param_value.to_string());
    }
    if let Some(param_value) = params.pending_below_strategy_id {
        multipart_form_params.insert("pendingBelowStrategyId", param_value.to_string());
    }
    if let Some(param_value) = params.pending_below_strategy_type {
        multipart_form_params.insert("pendingBelowStrategyType", param_value.to_string());
    }
    if let Some(param_value) = params.pending_below_time_in_force {
        multipart_form_params.insert("pendingBelowTimeInForce", param_value.to_string());
    }
    if let Some(param_value) = params.pending_below_trailing_delta {
        multipart_form_params.insert("pendingBelowTrailingDelta", param_value.to_string());
    }
    if let Some(param_value) = params.pending_below_type {
        multipart_form_params.insert("pendingBelowType", param_value.to_string());
    }
    multipart_form_params.insert("pendingQuantity", params.pending_quantity.to_string());
    multipart_form_params.insert("pendingSide", params.pending_side.to_string());
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    if let Some(param_value) = params.self_trade_prevention_mode {
        multipart_form_params.insert("selfTradePreventionMode", param_value.to_string());
    }
    multipart_form_params.insert("symbol", params.symbol.to_string());
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    if let Some(param_value) = params.working_client_order_id {
        multipart_form_params.insert("workingClientOrderId", param_value.to_string());
    }
    if let Some(param_value) = params.working_iceberg_qty {
        multipart_form_params.insert("workingIcebergQty", param_value.to_string());
    }
    multipart_form_params.insert("workingPrice", params.working_price.to_string());
    multipart_form_params.insert("workingQuantity", params.working_quantity.to_string());
    multipart_form_params.insert("workingSide", params.working_side.to_string());
    if let Some(param_value) = params.working_strategy_id {
        multipart_form_params.insert("workingStrategyId", param_value.to_string());
    }
    if let Some(param_value) = params.working_strategy_type {
        multipart_form_params.insert("workingStrategyType", param_value.to_string());
    }
    if let Some(param_value) = params.working_time_in_force {
        multipart_form_params.insert("workingTimeInForce", param_value.to_string());
    }
    multipart_form_params.insert("workingType", params.working_type.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CreateOrderListOtocoV3Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CreateOrderListOtocoV3Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateOrderListOtocoV3Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Send in a new OCO. - Price Restrictions:  SELL: Limit Price > Last Price > Stop Price BUY: Limit Price < Last Price < Stop Price - Quantity Restrictions:  Both legs must have the same quantity. ICEBERG quantities however do not have to be the same - OCO adds 2 orders to the unfilled order count, EXCHANGE_MAX_ORDERS filter and the MAX_NUM_ORDERS filter.
pub async fn create_order_oco_v3(configuration: &configuration::Configuration, params: CreateOrderOcoV3Params) -> Result<models::CreateOrderOcoV3Resp, Error<CreateOrderOcoV3Error>> {

    let uri_str = format!("{}/api/v3/order/oco", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    if let Some(param_value) = params.limit_client_order_id {
        multipart_form_params.insert("limitClientOrderId", param_value.to_string());
    }
    if let Some(param_value) = params.limit_iceberg_qty {
        multipart_form_params.insert("limitIcebergQty", param_value.to_string());
    }
    if let Some(param_value) = params.limit_strategy_id {
        multipart_form_params.insert("limitStrategyId", param_value.to_string());
    }
    if let Some(param_value) = params.limit_strategy_type {
        multipart_form_params.insert("limitStrategyType", param_value.to_string());
    }
    if let Some(param_value) = params.list_client_order_id {
        multipart_form_params.insert("listClientOrderId", param_value.to_string());
    }
    if let Some(param_value) = params.new_order_resp_type {
        multipart_form_params.insert("newOrderRespType", param_value.to_string());
    }
    multipart_form_params.insert("price", params.price.to_string());
    multipart_form_params.insert("quantity", params.quantity.to_string());
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    if let Some(param_value) = params.self_trade_prevention_mode {
        multipart_form_params.insert("selfTradePreventionMode", param_value.to_string());
    }
    multipart_form_params.insert("side", params.side.to_string());
    if let Some(param_value) = params.stop_client_order_id {
        multipart_form_params.insert("stopClientOrderId", param_value.to_string());
    }
    if let Some(param_value) = params.stop_iceberg_qty {
        multipart_form_params.insert("stopIcebergQty", param_value.to_string());
    }
    if let Some(param_value) = params.stop_limit_price {
        multipart_form_params.insert("stopLimitPrice", param_value.to_string());
    }
    if let Some(param_value) = params.stop_limit_time_in_force {
        multipart_form_params.insert("stopLimitTimeInForce", param_value.to_string());
    }
    multipart_form_params.insert("stopPrice", params.stop_price.to_string());
    if let Some(param_value) = params.stop_strategy_id {
        multipart_form_params.insert("stopStrategyId", param_value.to_string());
    }
    if let Some(param_value) = params.stop_strategy_type {
        multipart_form_params.insert("stopStrategyType", param_value.to_string());
    }
    multipart_form_params.insert("symbol", params.symbol.to_string());
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    if let Some(param_value) = params.trailing_delta {
        multipart_form_params.insert("trailingDelta", param_value.to_string());
    }
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CreateOrderOcoV3Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CreateOrderOcoV3Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateOrderOcoV3Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Test new order creation and signature/recvWindow long. Creates and validates a new order but does not send it into the matching engine.
pub async fn create_order_test_v3(configuration: &configuration::Configuration, params: CreateOrderTestV3Params) -> Result<models::SpotCreateOrderTestV3Resp, Error<CreateOrderTestV3Error>> {

    let uri_str = format!("{}/api/v3/order/test", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    if let Some(param_value) = params.compute_commission_rates {
        multipart_form_params.insert("computeCommissionRates", param_value.to_string());
    }
    if let Some(param_value) = params.iceberg_qty {
        multipart_form_params.insert("icebergQty", param_value.to_string());
    }
    if let Some(param_value) = params.new_client_order_id {
        multipart_form_params.insert("newClientOrderId", param_value.to_string());
    }
    if let Some(param_value) = params.new_order_resp_type {
        multipart_form_params.insert("newOrderRespType", param_value.to_string());
    }
    if let Some(param_value) = params.price {
        multipart_form_params.insert("price", param_value.to_string());
    }
    if let Some(param_value) = params.quantity {
        multipart_form_params.insert("quantity", param_value.to_string());
    }
    if let Some(param_value) = params.quote_order_qty {
        multipart_form_params.insert("quoteOrderQty", param_value.to_string());
    }
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    if let Some(param_value) = params.self_trade_prevention_mode {
        multipart_form_params.insert("selfTradePreventionMode", param_value.to_string());
    }
    multipart_form_params.insert("side", params.side.to_string());
    if let Some(param_value) = params.stop_price {
        multipart_form_params.insert("stopPrice", param_value.to_string());
    }
    if let Some(param_value) = params.strategy_id {
        multipart_form_params.insert("strategyId", param_value.to_string());
    }
    if let Some(param_value) = params.strategy_type {
        multipart_form_params.insert("strategyType", param_value.to_string());
    }
    multipart_form_params.insert("symbol", params.symbol.to_string());
    if let Some(param_value) = params.time_in_force {
        multipart_form_params.insert("timeInForce", param_value.to_string());
    }
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    if let Some(param_value) = params.trailing_delta {
        multipart_form_params.insert("trailingDelta", param_value.to_string());
    }
    multipart_form_params.insert("type", params.r#type.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SpotCreateOrderTestV3Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SpotCreateOrderTestV3Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateOrderTestV3Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Send in a new order.
pub async fn create_order_v3(configuration: &configuration::Configuration, params: CreateOrderV3Params) -> Result<models::SpotCreateOrderV3Resp, Error<CreateOrderV3Error>> {

    let uri_str = format!("{}/api/v3/order", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    if let Some(param_value) = params.iceberg_qty {
        multipart_form_params.insert("icebergQty", param_value.to_string());
    }
    if let Some(param_value) = params.new_client_order_id {
        multipart_form_params.insert("newClientOrderId", param_value.to_string());
    }
    if let Some(param_value) = params.new_order_resp_type {
        multipart_form_params.insert("newOrderRespType", param_value.to_string());
    }
    if let Some(param_value) = params.price {
        multipart_form_params.insert("price", param_value.to_string());
    }
    if let Some(param_value) = params.quantity {
        multipart_form_params.insert("quantity", param_value.to_string());
    }
    if let Some(param_value) = params.quote_order_qty {
        multipart_form_params.insert("quoteOrderQty", param_value.to_string());
    }
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    if let Some(param_value) = params.self_trade_prevention_mode {
        multipart_form_params.insert("selfTradePreventionMode", param_value.to_string());
    }
    multipart_form_params.insert("side", params.side.to_string());
    if let Some(param_value) = params.stop_price {
        multipart_form_params.insert("stopPrice", param_value.to_string());
    }
    if let Some(param_value) = params.strategy_id {
        multipart_form_params.insert("strategyId", param_value.to_string());
    }
    if let Some(param_value) = params.strategy_type {
        multipart_form_params.insert("strategyType", param_value.to_string());
    }
    multipart_form_params.insert("symbol", params.symbol.to_string());
    if let Some(param_value) = params.time_in_force {
        multipart_form_params.insert("timeInForce", param_value.to_string());
    }
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    if let Some(param_value) = params.trailing_delta {
        multipart_form_params.insert("trailingDelta", param_value.to_string());
    }
    multipart_form_params.insert("type", params.r#type.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SpotCreateOrderV3Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SpotCreateOrderV3Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateOrderV3Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Test new order creation and signature/recvWindow using smart order routing (SOR). Creates and validates a new order but does not send it into the matching engine.
pub async fn create_sor_order_test_v3(configuration: &configuration::Configuration, params: CreateSorOrderTestV3Params) -> Result<models::SpotCreateSorOrderTestV3Resp, Error<CreateSorOrderTestV3Error>> {

    let uri_str = format!("{}/api/v3/sor/order/test", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    if let Some(param_value) = params.compute_commission_rates {
        multipart_form_params.insert("computeCommissionRates", param_value.to_string());
    }
    if let Some(param_value) = params.iceberg_qty {
        multipart_form_params.insert("icebergQty", param_value.to_string());
    }
    if let Some(param_value) = params.new_client_order_id {
        multipart_form_params.insert("newClientOrderId", param_value.to_string());
    }
    if let Some(param_value) = params.new_order_resp_type {
        multipart_form_params.insert("newOrderRespType", param_value.to_string());
    }
    if let Some(param_value) = params.price {
        multipart_form_params.insert("price", param_value.to_string());
    }
    multipart_form_params.insert("quantity", params.quantity.to_string());
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    if let Some(param_value) = params.self_trade_prevention_mode {
        multipart_form_params.insert("selfTradePreventionMode", param_value.to_string());
    }
    multipart_form_params.insert("side", params.side.to_string());
    if let Some(param_value) = params.strategy_id {
        multipart_form_params.insert("strategyId", param_value.to_string());
    }
    if let Some(param_value) = params.strategy_type {
        multipart_form_params.insert("strategyType", param_value.to_string());
    }
    multipart_form_params.insert("symbol", params.symbol.to_string());
    if let Some(param_value) = params.time_in_force {
        multipart_form_params.insert("timeInForce", param_value.to_string());
    }
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    multipart_form_params.insert("type", params.r#type.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SpotCreateSorOrderTestV3Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SpotCreateSorOrderTestV3Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateSorOrderTestV3Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Places an order using smart order routing (SOR).
pub async fn create_sor_order_v3(configuration: &configuration::Configuration, params: CreateSorOrderV3Params) -> Result<models::CreateSorOrderV3Resp, Error<CreateSorOrderV3Error>> {

    let uri_str = format!("{}/api/v3/sor/order", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    if let Some(param_value) = params.iceberg_qty {
        multipart_form_params.insert("icebergQty", param_value.to_string());
    }
    if let Some(param_value) = params.new_client_order_id {
        multipart_form_params.insert("newClientOrderId", param_value.to_string());
    }
    if let Some(param_value) = params.new_order_resp_type {
        multipart_form_params.insert("newOrderRespType", param_value.to_string());
    }
    if let Some(param_value) = params.price {
        multipart_form_params.insert("price", param_value.to_string());
    }
    multipart_form_params.insert("quantity", params.quantity.to_string());
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    if let Some(param_value) = params.self_trade_prevention_mode {
        multipart_form_params.insert("selfTradePreventionMode", param_value.to_string());
    }
    multipart_form_params.insert("side", params.side.to_string());
    if let Some(param_value) = params.strategy_id {
        multipart_form_params.insert("strategyId", param_value.to_string());
    }
    if let Some(param_value) = params.strategy_type {
        multipart_form_params.insert("strategyType", param_value.to_string());
    }
    multipart_form_params.insert("symbol", params.symbol.to_string());
    if let Some(param_value) = params.time_in_force {
        multipart_form_params.insert("timeInForce", param_value.to_string());
    }
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    multipart_form_params.insert("type", params.r#type.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CreateSorOrderV3Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CreateSorOrderV3Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateSorOrderV3Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Start a new user data stream. The stream will close after 60 minutes unless a keepalive is sent.
pub async fn create_user_data_stream_v3(configuration: &configuration::Configuration) -> Result<models::CreateUserDataStreamV3Resp, Error<CreateUserDataStreamV3Error>> {

    let uri_str = format!("{}/api/v3/userDataStream", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CreateUserDataStreamV3Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CreateUserDataStreamV3Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateUserDataStreamV3Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Cancels all active orders on a symbol. This includes orders that are part of an order list.
pub async fn delete_open_orders_v3(configuration: &configuration::Configuration, params: DeleteOpenOrdersV3Params) -> Result<Vec<Vec<models::SpotDeleteOpenOrdersV3RespInner>>, Error<DeleteOpenOrdersV3Error>> {

    let uri_str = format!("{}/api/v3/openOrders", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;Vec&lt;models::SpotDeleteOpenOrdersV3RespInner&gt;&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;Vec&lt;models::SpotDeleteOpenOrdersV3RespInner&gt;&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteOpenOrdersV3Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Cancel an entire Order list
pub async fn delete_order_list_v3(configuration: &configuration::Configuration, params: DeleteOrderListV3Params) -> Result<models::DeleteOrderListV3Resp, Error<DeleteOrderListV3Error>> {

    let uri_str = format!("{}/api/v3/orderList", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    if let Some(ref param_value) = params.order_list_id {
        query_params.push(("orderListId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.list_client_order_id {
        query_params.push(("listClientOrderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.new_client_order_id {
        query_params.push(("newClientOrderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DeleteOrderListV3Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DeleteOrderListV3Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteOrderListV3Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Cancel an active order.
pub async fn delete_order_v3(configuration: &configuration::Configuration, params: DeleteOrderV3Params) -> Result<models::DeleteOrderV3Resp, Error<DeleteOrderV3Error>> {

    let uri_str = format!("{}/api/v3/order", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    if let Some(ref param_value) = params.order_id {
        query_params.push(("orderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.orig_client_order_id {
        query_params.push(("origClientOrderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.new_client_order_id {
        query_params.push(("newClientOrderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.cancel_restrictions {
        query_params.push(("cancelRestrictions".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DeleteOrderV3Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DeleteOrderV3Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteOrderV3Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Close out a user data stream.
pub async fn delete_user_data_stream_v3(configuration: &configuration::Configuration, params: DeleteUserDataStreamV3Params) -> Result<serde_json::Value, Error<DeleteUserDataStreamV3Error>> {

    let uri_str = format!("{}/api/v3/userDataStream", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("listenKey".to_string(), params.listen_key.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteUserDataStreamV3Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get current account commission rates.
pub async fn get_account_commission_v3(configuration: &configuration::Configuration, params: GetAccountCommissionV3Params) -> Result<models::GetAccountCommissionV3Resp, Error<GetAccountCommissionV3Error>> {

    let uri_str = format!("{}/api/v3/account/commission", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetAccountCommissionV3Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetAccountCommissionV3Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAccountCommissionV3Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get current account information.
pub async fn get_account_v3(configuration: &configuration::Configuration, params: GetAccountV3Params) -> Result<models::GetAccountV3Resp, Error<GetAccountV3Error>> {

    let uri_str = format!("{}/api/v3/account", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.omit_zero_balances {
        query_params.push(("omitZeroBalances".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetAccountV3Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetAccountV3Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAccountV3Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get compressed, aggregate trades. Trades that fill at the time, from the same taker order, with the same price will have the quantity aggregated.
pub async fn get_agg_trades_v3(configuration: &configuration::Configuration, params: GetAggTradesV3Params) -> Result<Vec<models::SpotGetAggTradesV3RespItem>, Error<GetAggTradesV3Error>> {

    let uri_str = format!("{}/api/v3/aggTrades", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    if let Some(ref param_value) = params.from_id {
        query_params.push(("fromId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.start_time {
        query_params.push(("startTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.end_time {
        query_params.push(("endTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.limit {
        query_params.push(("limit".to_string(), param_value.to_string()));
    }

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::SpotGetAggTradesV3RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::SpotGetAggTradesV3RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAggTradesV3Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves all order lists based on provided optional parameters. Note that the time between startTime and endTime can't be longer than 24 hours.
pub async fn get_all_order_list_v3(configuration: &configuration::Configuration, params: GetAllOrderListV3Params) -> Result<Vec<models::GetAllOrderListV3RespItem>, Error<GetAllOrderListV3Error>> {

    let uri_str = format!("{}/api/v3/allOrderList", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.from_id {
        query_params.push(("fromId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.start_time {
        query_params.push(("startTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.end_time {
        query_params.push(("endTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.limit {
        query_params.push(("limit".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GetAllOrderListV3RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GetAllOrderListV3RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAllOrderListV3Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get all account orders; active, canceled, or filled.
pub async fn get_all_orders_v3(configuration: &configuration::Configuration, params: GetAllOrdersV3Params) -> Result<Vec<models::GetAllOrdersV3RespItem>, Error<GetAllOrdersV3Error>> {

    let uri_str = format!("{}/api/v3/allOrders", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    if let Some(ref param_value) = params.order_id {
        query_params.push(("orderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.start_time {
        query_params.push(("startTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.end_time {
        query_params.push(("endTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.limit {
        query_params.push(("limit".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GetAllOrdersV3RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GetAllOrdersV3RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAllOrdersV3Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Current average price for a symbol.
pub async fn get_avg_price_v3(configuration: &configuration::Configuration, params: GetAvgPriceV3Params) -> Result<models::GetAvgPriceV3Resp, Error<GetAvgPriceV3Error>> {

    let uri_str = format!("{}/api/v3/avgPrice", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetAvgPriceV3Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetAvgPriceV3Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAvgPriceV3Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_depth_v3(configuration: &configuration::Configuration, params: GetDepthV3Params) -> Result<models::GetDepthV3Resp, Error<GetDepthV3Error>> {

    let uri_str = format!("{}/api/v3/depth", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    if let Some(ref param_value) = params.limit {
        query_params.push(("limit".to_string(), param_value.to_string()));
    }

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetDepthV3Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetDepthV3Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetDepthV3Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Current exchange trading rules and symbol information
pub async fn get_exchange_info_v3(configuration: &configuration::Configuration, params: GetExchangeInfoV3Params) -> Result<models::SpotGetExchangeInfoV3Resp, Error<GetExchangeInfoV3Error>> {

    let uri_str = format!("{}/api/v3/exchangeInfo", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.symbol {
        query_params.push(("symbol".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.symbols {
        match "multi" {
            "multi" => {
                for p in param_value {
                    query_params.push(("symbols".to_string(), p.to_string()));
                }
            },
            _ => {
                let joined = param_value.iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",");
                query_params.push(("symbols".to_string(), joined));
            }
        };
    }
    if let Some(ref param_value) = params.permissions {
        query_params.push(("permissions".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.show_permission_sets {
        query_params.push(("showPermissionSets".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.symbol_status {
        query_params.push(("symbolStatus".to_string(), param_value.to_string()));
    }

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SpotGetExchangeInfoV3Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SpotGetExchangeInfoV3Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetExchangeInfoV3Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get older trades.
pub async fn get_historical_trades_v3(configuration: &configuration::Configuration, params: GetHistoricalTradesV3Params) -> Result<Vec<models::GetHistoricalTradesV3RespItem>, Error<GetHistoricalTradesV3Error>> {

    let uri_str = format!("{}/api/v3/historicalTrades", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    if let Some(ref param_value) = params.limit {
        query_params.push(("limit".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.from_id {
        query_params.push(("fromId".to_string(), param_value.to_string()));
    }

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GetHistoricalTradesV3RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GetHistoricalTradesV3RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetHistoricalTradesV3Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Kline/candlestick bars for a symbol. Klines are uniquely identified by their open time.
pub async fn get_klines_v3(configuration: &configuration::Configuration, params: GetKlinesV3Params) -> Result<Vec<Vec<models::GetKlinesV3200ResponseInnerInner>>, Error<GetKlinesV3Error>> {

    let uri_str = format!("{}/api/v3/klines", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    query_params.push(("interval".to_string(), params.interval.to_string()));
    if let Some(ref param_value) = params.start_time {
        query_params.push(("startTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.end_time {
        query_params.push(("endTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.time_zone {
        query_params.push(("timeZone".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.limit {
        query_params.push(("limit".to_string(), param_value.to_string()));
    }

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;Vec&lt;models::GetKlinesV3200ResponseInnerInner&gt;&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;Vec&lt;models::GetKlinesV3200ResponseInnerInner&gt;&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetKlinesV3Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves allocations resulting from SOR order placement.
pub async fn get_my_allocations_v3(configuration: &configuration::Configuration, params: GetMyAllocationsV3Params) -> Result<Vec<models::GetMyAllocationsV3RespItem>, Error<GetMyAllocationsV3Error>> {

    let uri_str = format!("{}/api/v3/myAllocations", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    if let Some(ref param_value) = params.start_time {
        query_params.push(("startTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.end_time {
        query_params.push(("endTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.from_allocation_id {
        query_params.push(("fromAllocationId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.limit {
        query_params.push(("limit".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.order_id {
        query_params.push(("orderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.timestamp {
        query_params.push(("timestamp".to_string(), param_value.to_string()));
    }

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GetMyAllocationsV3RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GetMyAllocationsV3RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMyAllocationsV3Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Displays the list of orders that were expired due to STP. These are the combinations supported: - symbol + preventedMatchId - symbol + orderId - symbol + orderId + fromPreventedMatchId (limit will default to 500) - symbol + orderId + fromPreventedMatchId + limit
pub async fn get_my_prevented_matches_v3(configuration: &configuration::Configuration, params: GetMyPreventedMatchesV3Params) -> Result<Vec<models::GetMyPreventedMatchesV3RespItem>, Error<GetMyPreventedMatchesV3Error>> {

    let uri_str = format!("{}/api/v3/myPreventedMatches", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    if let Some(ref param_value) = params.prevented_match_id {
        query_params.push(("preventedMatchId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.order_id {
        query_params.push(("orderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.from_prevented_match_id {
        query_params.push(("fromPreventedMatchId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.limit {
        query_params.push(("limit".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GetMyPreventedMatchesV3RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GetMyPreventedMatchesV3RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMyPreventedMatchesV3Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get trades for a specific account and symbol.
pub async fn get_my_trades_v3(configuration: &configuration::Configuration, params: GetMyTradesV3Params) -> Result<Vec<models::GetMyTradesV3RespItem>, Error<GetMyTradesV3Error>> {

    let uri_str = format!("{}/api/v3/myTrades", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    if let Some(ref param_value) = params.order_id {
        query_params.push(("orderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.start_time {
        query_params.push(("startTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.end_time {
        query_params.push(("endTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.from_id {
        query_params.push(("fromId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.limit {
        query_params.push(("limit".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GetMyTradesV3RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GetMyTradesV3RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMyTradesV3Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_open_order_list_v3(configuration: &configuration::Configuration, params: GetOpenOrderListV3Params) -> Result<Vec<models::GetOpenOrderListV3RespItem>, Error<GetOpenOrderListV3Error>> {

    let uri_str = format!("{}/api/v3/openOrderList", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GetOpenOrderListV3RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GetOpenOrderListV3RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetOpenOrderListV3Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get all open orders on a symbol. Careful when accessing this with no symbol. Weight: 6 for a single symbol; 80 when the symbol parameter is omitted
pub async fn get_open_orders_v3(configuration: &configuration::Configuration, params: GetOpenOrdersV3Params) -> Result<Vec<models::GetOpenOrdersV3RespItem>, Error<GetOpenOrdersV3Error>> {

    let uri_str = format!("{}/api/v3/openOrders", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.symbol {
        query_params.push(("symbol".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GetOpenOrdersV3RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GetOpenOrdersV3RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetOpenOrdersV3Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves a specific order list based on provided optional parameters.
pub async fn get_order_list_v3(configuration: &configuration::Configuration, params: GetOrderListV3Params) -> Result<models::GetOrderListV3Resp, Error<GetOrderListV3Error>> {

    let uri_str = format!("{}/api/v3/orderList", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.order_list_id {
        query_params.push(("orderListId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.orig_client_order_id {
        query_params.push(("origClientOrderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetOrderListV3Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetOrderListV3Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetOrderListV3Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Check an order's status.
pub async fn get_order_v3(configuration: &configuration::Configuration, params: GetOrderV3Params) -> Result<models::GetOrderV3Resp, Error<GetOrderV3Error>> {

    let uri_str = format!("{}/api/v3/order", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    if let Some(ref param_value) = params.order_id {
        query_params.push(("orderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.orig_client_order_id {
        query_params.push(("origClientOrderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetOrderV3Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetOrderV3Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetOrderV3Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Test connectivity to the Rest API.
pub async fn get_ping_v3(configuration: &configuration::Configuration) -> Result<serde_json::Value, Error<GetPingV3Error>> {

    let uri_str = format!("{}/api/v3/ping", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetPingV3Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Displays the user's unfilled order count for all intervals.
pub async fn get_rate_limit_order_v3(configuration: &configuration::Configuration, params: GetRateLimitOrderV3Params) -> Result<Vec<models::GetRateLimitOrderV3RespItem>, Error<GetRateLimitOrderV3Error>> {

    let uri_str = format!("{}/api/v3/rateLimit/order", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GetRateLimitOrderV3RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GetRateLimitOrderV3RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetRateLimitOrderV3Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// 24 hour rolling window price change statistics. Careful when accessing this with no symbol.
pub async fn get_ticker24hr_v3(configuration: &configuration::Configuration, params: GetTicker24hrV3Params) -> Result<models::SpotGetTicker24hrV3Resp, Error<GetTicker24hrV3Error>> {

    let uri_str = format!("{}/api/v3/ticker/24hr", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.symbol {
        query_params.push(("symbol".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.symbols {
        query_params.push(("symbols".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.r#type {
        query_params.push(("type".to_string(), param_value.to_string()));
    }

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SpotGetTicker24hrV3Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SpotGetTicker24hrV3Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTicker24hrV3Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Best price/qty on the order book for a symbol or symbols.
pub async fn get_ticker_book_ticker_v3(configuration: &configuration::Configuration, params: GetTickerBookTickerV3Params) -> Result<models::SpotGetTickerBookTickerV3Resp, Error<GetTickerBookTickerV3Error>> {

    let uri_str = format!("{}/api/v3/ticker/bookTicker", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.symbol {
        query_params.push(("symbol".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.symbols {
        query_params.push(("symbols".to_string(), param_value.to_string()));
    }

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SpotGetTickerBookTickerV3Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SpotGetTickerBookTickerV3Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTickerBookTickerV3Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Latest price for a symbol or symbols.
pub async fn get_ticker_price_v3(configuration: &configuration::Configuration, params: GetTickerPriceV3Params) -> Result<models::SpotGetTickerPriceV3Resp, Error<GetTickerPriceV3Error>> {

    let uri_str = format!("{}/api/v3/ticker/price", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.symbol {
        query_params.push(("symbol".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.symbols {
        query_params.push(("symbols".to_string(), param_value.to_string()));
    }

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SpotGetTickerPriceV3Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SpotGetTickerPriceV3Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTickerPriceV3Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Price change statistics for a trading day. 4 for each requested symbol.  The weight for this request will cap at 200 once the number of symbols in the request is more than 50.
pub async fn get_ticker_trading_day_v3(configuration: &configuration::Configuration, params: GetTickerTradingDayV3Params) -> Result<models::SpotGetTickerTradingDayV3Resp, Error<GetTickerTradingDayV3Error>> {

    let uri_str = format!("{}/api/v3/ticker/tradingDay", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    query_params.push(("symbols".to_string(), params.symbols.to_string()));
    if let Some(ref param_value) = params.time_zone {
        query_params.push(("timeZone".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.r#type {
        query_params.push(("type".to_string(), param_value.to_string()));
    }

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SpotGetTickerTradingDayV3Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SpotGetTickerTradingDayV3Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTickerTradingDayV3Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Note: This endpoint is different from the GET /api/v3/ticker/24hr endpoint. The window used to compute statistics will be no more than 59999ms from the requested windowSize. openTime for /api/v3/ticker always starts on a minute, while the closeTime is the current time of the request. As such, the effective window will be up to 59999ms wider than windowSize. E.g. If the closeTime is 1641287867099 (January 04, 2022 09:17:47:099 UTC) , and the windowSize is 1d. the openTime will be: 1641201420000 (January 3, 2022, 09:17:00) 4 for each requested symbol regardless of windowSize.  The weight for this request will cap at 200 once the number of symbols in the request is more than 50.
pub async fn get_ticker_v3(configuration: &configuration::Configuration, params: GetTickerV3Params) -> Result<models::SpotGetTickerV3Resp, Error<GetTickerV3Error>> {

    let uri_str = format!("{}/api/v3/ticker", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    query_params.push(("symbols".to_string(), params.symbols.to_string()));
    if let Some(ref param_value) = params.window_size {
        query_params.push(("windowSize".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.r#type {
        query_params.push(("type".to_string(), param_value.to_string()));
    }

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SpotGetTickerV3Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SpotGetTickerV3Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTickerV3Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Test connectivity to the Rest API and get the current server time.
pub async fn get_time_v3(configuration: &configuration::Configuration) -> Result<models::GetTimeV3Resp, Error<GetTimeV3Error>> {

    let uri_str = format!("{}/api/v3/time", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTimeV3Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTimeV3Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTimeV3Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get recent trades.
pub async fn get_trades_v3(configuration: &configuration::Configuration, params: GetTradesV3Params) -> Result<Vec<models::GetTradesV3RespItem>, Error<GetTradesV3Error>> {

    let uri_str = format!("{}/api/v3/trades", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    if let Some(ref param_value) = params.limit {
        query_params.push(("limit".to_string(), param_value.to_string()));
    }

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GetTradesV3RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GetTradesV3RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTradesV3Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The request is similar to klines having the same parameters and response. uiKlines return modified kline data, optimized for presentation of candlestick charts.
pub async fn get_ui_klines_v3(configuration: &configuration::Configuration, params: GetUiKlinesV3Params) -> Result<Vec<Vec<models::GetKlinesV3200ResponseInnerInner>>, Error<GetUiKlinesV3Error>> {

    let uri_str = format!("{}/api/v3/uiKlines", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    query_params.push(("interval".to_string(), params.interval.to_string()));
    if let Some(ref param_value) = params.start_time {
        query_params.push(("startTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.end_time {
        query_params.push(("endTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.time_zone {
        query_params.push(("timeZone".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.limit {
        query_params.push(("limit".to_string(), param_value.to_string()));
    }

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;Vec&lt;models::GetKlinesV3200ResponseInnerInner&gt;&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;Vec&lt;models::GetKlinesV3200ResponseInnerInner&gt;&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetUiKlinesV3Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Keepalive a user data stream to prevent a time out. User data streams will close after 60 minutes. It's recommended to send a ping about every 30 minutes.
pub async fn update_user_data_stream_v3(configuration: &configuration::Configuration, params: UpdateUserDataStreamV3Params) -> Result<serde_json::Value, Error<UpdateUserDataStreamV3Error>> {

    let uri_str = format!("{}/api/v3/userDataStream", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("listenKey", params.listen_key.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateUserDataStreamV3Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

