/*
 * Binance Spot API
 *
 * OpenAPI specification for Binance exchange - Spot API
 *
 * The version of the OpenAPI document: 0.3.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::spot::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};

/// struct for passing parameters to the method [`create_margin_api_key_v1`]
#[derive(Clone, Debug, Default)]
pub struct CreateMarginApiKeyV1Params {
    pub api_name: String,
    pub timestamp: i64,
    pub ip: Option<String>,
    pub permission_mode: Option<String>,
    pub public_key: Option<String>,
    pub recv_window: Option<i64>,
    pub symbol: Option<String>
}

/// struct for passing parameters to the method [`create_margin_borrow_repay_v1`]
#[derive(Clone, Debug, Default)]
pub struct CreateMarginBorrowRepayV1Params {
    pub amount: String,
    pub asset: String,
    pub is_isolated: String,
    pub symbol: String,
    pub timestamp: i64,
    pub r#type: String,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`create_margin_exchange_small_liability_v1`]
#[derive(Clone, Debug, Default)]
pub struct CreateMarginExchangeSmallLiabilityV1Params {
    pub asset_names: Vec<String>,
    pub timestamp: i64,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`create_margin_isolated_account_v1`]
#[derive(Clone, Debug, Default)]
pub struct CreateMarginIsolatedAccountV1Params {
    pub symbol: String,
    pub timestamp: i64,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`create_margin_manual_liquidation_v1`]
#[derive(Clone, Debug, Default)]
pub struct CreateMarginManualLiquidationV1Params {
    pub timestamp: i64,
    pub r#type: String,
    pub recv_window: Option<i64>,
    pub symbol: Option<String>
}

/// struct for passing parameters to the method [`create_margin_max_leverage_v1`]
#[derive(Clone, Debug, Default)]
pub struct CreateMarginMaxLeverageV1Params {
    pub max_leverage: i32
}

/// struct for passing parameters to the method [`create_margin_order_oco_v1`]
#[derive(Clone, Debug, Default)]
pub struct CreateMarginOrderOcoV1Params {
    pub price: String,
    pub quantity: String,
    pub side: String,
    pub stop_price: String,
    pub symbol: String,
    pub timestamp: i64,
    pub auto_repay_at_cancel: Option<bool>,
    pub is_isolated: Option<String>,
    pub limit_client_order_id: Option<String>,
    pub limit_iceberg_qty: Option<String>,
    pub list_client_order_id: Option<String>,
    pub new_order_resp_type: Option<String>,
    pub recv_window: Option<i64>,
    pub self_trade_prevention_mode: Option<String>,
    pub side_effect_type: Option<String>,
    pub stop_client_order_id: Option<String>,
    pub stop_iceberg_qty: Option<String>,
    pub stop_limit_price: Option<String>,
    pub stop_limit_time_in_force: Option<String>
}

/// struct for passing parameters to the method [`create_margin_order_oto_v1`]
#[derive(Clone, Debug, Default)]
pub struct CreateMarginOrderOtoV1Params {
    pub pending_quantity: String,
    pub pending_side: String,
    pub pending_type: String,
    pub symbol: String,
    pub working_iceberg_qty: String,
    pub working_price: String,
    pub working_quantity: String,
    pub working_side: String,
    pub working_type: String,
    pub auto_repay_at_cancel: Option<bool>,
    pub is_isolated: Option<String>,
    pub list_client_order_id: Option<String>,
    pub new_order_resp_type: Option<String>,
    pub pending_client_order_id: Option<String>,
    pub pending_iceberg_qty: Option<String>,
    pub pending_price: Option<String>,
    pub pending_stop_price: Option<String>,
    pub pending_time_in_force: Option<String>,
    pub pending_trailing_delta: Option<String>,
    pub self_trade_prevention_mode: Option<String>,
    pub side_effect_type: Option<String>,
    pub working_client_order_id: Option<String>,
    pub working_time_in_force: Option<String>
}

/// struct for passing parameters to the method [`create_margin_order_otoco_v1`]
#[derive(Clone, Debug, Default)]
pub struct CreateMarginOrderOtocoV1Params {
    pub pending_above_type: String,
    pub pending_quantity: String,
    pub pending_side: String,
    pub symbol: String,
    pub working_price: String,
    pub working_quantity: String,
    pub working_side: String,
    pub working_type: String,
    pub auto_repay_at_cancel: Option<bool>,
    pub is_isolated: Option<String>,
    pub list_client_order_id: Option<String>,
    pub new_order_resp_type: Option<String>,
    pub pending_above_client_order_id: Option<String>,
    pub pending_above_iceberg_qty: Option<String>,
    pub pending_above_price: Option<String>,
    pub pending_above_stop_price: Option<String>,
    pub pending_above_time_in_force: Option<String>,
    pub pending_above_trailing_delta: Option<String>,
    pub pending_below_client_order_id: Option<String>,
    pub pending_below_iceberg_qty: Option<String>,
    pub pending_below_price: Option<String>,
    pub pending_below_stop_price: Option<String>,
    pub pending_below_time_in_force: Option<String>,
    pub pending_below_trailing_delta: Option<String>,
    pub pending_below_type: Option<String>,
    pub self_trade_prevention_mode: Option<String>,
    pub side_effect_type: Option<String>,
    pub working_client_order_id: Option<String>,
    pub working_iceberg_qty: Option<String>,
    pub working_time_in_force: Option<String>
}

/// struct for passing parameters to the method [`create_margin_order_v1`]
#[derive(Clone, Debug, Default)]
pub struct CreateMarginOrderV1Params {
    pub side: String,
    pub symbol: String,
    pub timestamp: i64,
    pub r#type: String,
    pub auto_repay_at_cancel: Option<bool>,
    pub iceberg_qty: Option<String>,
    pub is_isolated: Option<String>,
    pub new_client_order_id: Option<String>,
    pub new_order_resp_type: Option<String>,
    pub price: Option<String>,
    pub quantity: Option<String>,
    pub quote_order_qty: Option<String>,
    pub recv_window: Option<i64>,
    pub self_trade_prevention_mode: Option<String>,
    pub side_effect_type: Option<String>,
    pub stop_price: Option<String>,
    pub time_in_force: Option<String>
}

/// struct for passing parameters to the method [`create_user_data_stream_isolated_v1`]
#[derive(Clone, Debug, Default)]
pub struct CreateUserDataStreamIsolatedV1Params {
    pub symbol: String
}

/// struct for passing parameters to the method [`delete_margin_api_key_v1`]
#[derive(Clone, Debug, Default)]
pub struct DeleteMarginApiKeyV1Params {
    pub timestamp: i64,
    pub api_key: Option<String>,
    pub api_name: Option<String>,
    /// isolated margin pair
    pub symbol: Option<String>,
    /// The value cannot be greater than `60000`
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`delete_margin_isolated_account_v1`]
#[derive(Clone, Debug, Default)]
pub struct DeleteMarginIsolatedAccountV1Params {
    pub symbol: String,
    pub timestamp: i64,
    /// No more than 60000
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`delete_margin_open_orders_v1`]
#[derive(Clone, Debug, Default)]
pub struct DeleteMarginOpenOrdersV1Params {
    pub symbol: String,
    pub timestamp: i64,
    /// for isolated margin or not, &#34;TRUE&#34;, &#34;FALSE&#34;，default &#34;FALSE&#34;
    pub is_isolated: Option<String>,
    /// The value cannot be greater than `60000`
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`delete_margin_order_list_v1`]
#[derive(Clone, Debug, Default)]
pub struct DeleteMarginOrderListV1Params {
    pub symbol: String,
    pub timestamp: i64,
    /// for isolated margin or not, &#34;TRUE&#34;, &#34;FALSE&#34;，default &#34;FALSE&#34;
    pub is_isolated: Option<String>,
    /// Either `orderListId` or `listClientOrderId` must be provided
    pub order_list_id: Option<i64>,
    /// Either `orderListId` or `listClientOrderId` must be provided
    pub list_client_order_id: Option<String>,
    /// Used to uniquely identify this cancel. Automatically generated by default
    pub new_client_order_id: Option<String>,
    /// The value cannot be greater than `60000`
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`delete_margin_order_v1`]
#[derive(Clone, Debug, Default)]
pub struct DeleteMarginOrderV1Params {
    pub symbol: String,
    pub timestamp: i64,
    /// for isolated margin or not, &#34;TRUE&#34;, &#34;FALSE&#34;，default &#34;FALSE&#34;
    pub is_isolated: Option<String>,
    pub order_id: Option<i64>,
    pub orig_client_order_id: Option<String>,
    /// Used to uniquely identify this cancel. Automatically generated by default.
    pub new_client_order_id: Option<String>,
    /// The value cannot be greater than `60000`
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`delete_user_data_stream_isolated_v1`]
#[derive(Clone, Debug, Default)]
pub struct DeleteUserDataStreamIsolatedV1Params {
    pub symbol: String,
    pub listenkey: String
}

/// struct for passing parameters to the method [`delete_user_data_stream_v1`]
#[derive(Clone, Debug, Default)]
pub struct DeleteUserDataStreamV1Params {
    pub listenkey: String
}

/// struct for passing parameters to the method [`get_bnb_burn_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetBnbBurnV1Params {
    pub timestamp: i64,
    /// No more than 60000
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_margin_account_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetMarginAccountV1Params {
    pub timestamp: i64,
    /// The value cannot be greater than `60000`
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_margin_all_assets_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetMarginAllAssetsV1Params {
    pub asset: Option<String>
}

/// struct for passing parameters to the method [`get_margin_all_order_list_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetMarginAllOrderListV1Params {
    pub timestamp: i64,
    /// for isolated margin or not, &#34;TRUE&#34;, &#34;FALSE&#34;，default &#34;FALSE&#34;
    pub is_isolated: Option<String>,
    /// mandatory for isolated margin, not supported for cross margin
    pub symbol: Option<String>,
    /// If supplied, neither `startTime` or `endTime` can be provided
    pub from_id: Option<i64>,
    pub start_time: Option<i64>,
    pub end_time: Option<i64>,
    /// Default Value: 500; Max Value: 1000
    pub limit: Option<i32>,
    /// The value cannot be greater than `60000`
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_margin_all_orders_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetMarginAllOrdersV1Params {
    pub symbol: String,
    pub timestamp: i64,
    /// for isolated margin or not, &#34;TRUE&#34;, &#34;FALSE&#34;，default &#34;FALSE&#34;
    pub is_isolated: Option<String>,
    pub order_id: Option<i64>,
    pub start_time: Option<i64>,
    pub end_time: Option<i64>,
    /// Default 500; max 500.
    pub limit: Option<i32>,
    /// The value cannot be greater than `60000`
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_margin_all_pairs_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetMarginAllPairsV1Params {
    pub symbol: Option<String>
}

/// struct for passing parameters to the method [`get_margin_api_key_list_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetMarginApiKeyListV1Params {
    pub timestamp: i64,
    /// isolated margin pair
    pub symbol: Option<String>,
    /// The value cannot be greater than `60000`
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_margin_api_key_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetMarginApiKeyV1Params {
    pub api_key: String,
    pub timestamp: i64,
    /// isolated margin pair
    pub symbol: Option<String>,
    /// The value cannot be greater than `60000`
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_margin_available_inventory_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetMarginAvailableInventoryV1Params {
    /// MARGIN,ISOLATED
    pub r#type: String
}

/// struct for passing parameters to the method [`get_margin_borrow_repay_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetMarginBorrowRepayV1Params {
    /// `BORROW` or `REPAY`
    pub r#type: String,
    pub timestamp: i64,
    pub asset: Option<String>,
    /// Symbol in Isolated Margin
    pub isolated_symbol: Option<String>,
    /// `tranId` in `POST /sapi/v1/margin/loan`
    pub tx_id: Option<i64>,
    pub start_time: Option<i64>,
    pub end_time: Option<i64>,
    /// Current querying page. Start from 1. Default:1
    pub current: Option<i64>,
    /// Default:10 Max:100
    pub size: Option<i64>,
    /// The value cannot be greater than 60000
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_margin_capital_flow_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetMarginCapitalFlowV1Params {
    pub timestamp: i64,
    pub asset: Option<String>,
    /// 查询逐仓数据时必填
    pub symbol: Option<String>,
    pub r#type: Option<String>,
    /// 只支持查询最近90天的数据
    pub start_time: Option<i64>,
    pub end_time: Option<i64>,
    /// 如设置fromId, 将返回id &gt; fromId的数据。否则将返回最新数据
    pub from_id: Option<i64>,
    /// 每次返回的数据条数限制。默认 500; 最大 1000.
    pub limit: Option<i64>,
    /// The value cannot be greater than `60000`
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_margin_cross_margin_data_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetMarginCrossMarginDataV1Params {
    pub timestamp: i64,
    /// User&#39;s current specific margin data will be returned if vipLevel is omitted
    pub vip_level: Option<i32>,
    pub coin: Option<String>,
    /// No more than `60000`
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_margin_delist_schedule_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetMarginDelistScheduleV1Params {
    pub timestamp: i64,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_margin_exchange_small_liability_history_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetMarginExchangeSmallLiabilityHistoryV1Params {
    /// Currently querying page. Start from 1. Default:1
    pub current: i32,
    /// Default:10, Max:100
    pub size: i32,
    pub timestamp: i64,
    /// Default: 30 days from current timestamp
    pub start_time: Option<i64>,
    /// Default: present timestamp
    pub end_time: Option<i64>,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_margin_exchange_small_liability_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetMarginExchangeSmallLiabilityV1Params {
    pub timestamp: i64,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_margin_force_liquidation_rec_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetMarginForceLiquidationRecV1Params {
    pub timestamp: i64,
    pub start_time: Option<i64>,
    pub end_time: Option<i64>,
    pub isolated_symbol: Option<String>,
    /// Currently querying page. Start from 1. Default:1
    pub current: Option<i64>,
    /// Default:10 Max:100
    pub size: Option<i64>,
    /// The value cannot be greater than `60000`
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_margin_interest_history_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetMarginInterestHistoryV1Params {
    pub timestamp: i64,
    pub asset: Option<String>,
    /// isolated symbol
    pub isolated_symbol: Option<String>,
    pub start_time: Option<i64>,
    pub end_time: Option<i64>,
    /// Currently querying page. Start from 1. Default:1
    pub current: Option<i64>,
    /// Default:10 Max:100
    pub size: Option<i64>,
    /// The value cannot be greater than `60000`
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_margin_interest_rate_history_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetMarginInterestRateHistoryV1Params {
    pub asset: String,
    pub timestamp: i64,
    /// Default: user&#39;s vip level
    pub vip_level: Option<i32>,
    /// Default: 7 days ago
    pub start_time: Option<i64>,
    /// Default: present. Maximum range: 1 months.
    pub end_time: Option<i64>,
    /// No more than 60000
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_margin_isolated_account_limit_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetMarginIsolatedAccountLimitV1Params {
    pub timestamp: i64,
    /// No more than 60000
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_margin_isolated_account_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetMarginIsolatedAccountV1Params {
    pub timestamp: i64,
    /// Max 5 symbols can be sent; separated by &#34;,&#34;. e.g. &#34;BTCUSDT,BNBUSDT,ADAUSDT&#34;
    pub symbols: Option<String>,
    /// No more than 60000
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_margin_isolated_all_pairs_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetMarginIsolatedAllPairsV1Params {
    pub timestamp: i64,
    pub symbol: Option<String>,
    /// No more than 60000
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_margin_isolated_margin_data_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetMarginIsolatedMarginDataV1Params {
    pub timestamp: i64,
    /// User&#39;s current specific margin data will be returned if vipLevel is omitted
    pub vip_level: Option<i32>,
    pub symbol: Option<String>,
    /// No more than `60000`
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_margin_isolated_margin_tier_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetMarginIsolatedMarginTierV1Params {
    pub symbol: String,
    pub timestamp: i64,
    /// All margin tier data will be returned if tier is omitted
    pub tier: Option<i32>,
    /// No more than `60000`
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_margin_max_borrowable_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetMarginMaxBorrowableV1Params {
    pub asset: String,
    pub timestamp: i64,
    /// isolated symbol
    pub isolated_symbol: Option<String>,
    /// The value cannot be greater than `60000`
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_margin_max_transferable_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetMarginMaxTransferableV1Params {
    pub asset: String,
    pub timestamp: i64,
    /// isolated symbol
    pub isolated_symbol: Option<String>,
    /// The value cannot be greater than `60000`
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_margin_my_trades_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetMarginMyTradesV1Params {
    pub symbol: String,
    pub timestamp: i64,
    /// for isolated margin or not, &#34;TRUE&#34;, &#34;FALSE&#34;，default &#34;FALSE&#34;
    pub is_isolated: Option<String>,
    pub order_id: Option<i64>,
    pub start_time: Option<i64>,
    pub end_time: Option<i64>,
    /// TradeId to fetch from. Default gets most recent trades.
    pub from_id: Option<i64>,
    /// Default 500; max 1000.
    pub limit: Option<i32>,
    /// The value cannot be greater than `60000`
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_margin_next_hourly_interest_rate_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetMarginNextHourlyInterestRateV1Params {
    /// List of assets, separated by commas, up to 20
    pub assets: String,
    /// for isolated margin or not, &#34;TRUE&#34;, &#34;FALSE&#34;
    pub is_isolated: bool
}

/// struct for passing parameters to the method [`get_margin_open_order_list_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetMarginOpenOrderListV1Params {
    pub timestamp: i64,
    /// for isolated margin or not, &#34;TRUE&#34;, &#34;FALSE&#34;，default &#34;FALSE&#34;
    pub is_isolated: Option<String>,
    /// mandatory for isolated margin, not supported for cross margin
    pub symbol: Option<String>,
    /// The value cannot be greater than `60000`
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_margin_open_orders_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetMarginOpenOrdersV1Params {
    pub timestamp: i64,
    pub symbol: Option<String>,
    /// for isolated margin or not, &#34;TRUE&#34;, &#34;FALSE&#34;，default &#34;FALSE&#34;
    pub is_isolated: Option<String>,
    /// The value cannot be greater than `60000`
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_margin_order_list_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetMarginOrderListV1Params {
    pub timestamp: i64,
    /// for isolated margin or not, &#34;TRUE&#34;, &#34;FALSE&#34;，default &#34;FALSE&#34;
    pub is_isolated: Option<String>,
    /// mandatory for isolated margin, not supported for cross margin
    pub symbol: Option<String>,
    /// Either `orderListId` or `origClientOrderId` must be provided
    pub order_list_id: Option<i64>,
    /// Either `orderListId` or `origClientOrderId` must be provided
    pub orig_client_order_id: Option<String>,
    /// The value cannot be greater than `60000`
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_margin_order_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetMarginOrderV1Params {
    pub symbol: String,
    pub timestamp: i64,
    /// for isolated margin or not, &#34;TRUE&#34;, &#34;FALSE&#34;，default &#34;FALSE&#34;
    pub is_isolated: Option<String>,
    pub order_id: Option<i64>,
    pub orig_client_order_id: Option<String>,
    /// The value cannot be greater than `60000`
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_margin_price_index_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetMarginPriceIndexV1Params {
    pub symbol: String
}

/// struct for passing parameters to the method [`get_margin_rate_limit_order_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetMarginRateLimitOrderV1Params {
    pub timestamp: i64,
    /// for isolated margin or not, &#34;TRUE&#34;, &#34;FALSE&#34;，default &#34;FALSE&#34;
    pub is_isolated: Option<String>,
    /// isolated symbol, mandatory for isolated margin
    pub symbol: Option<String>,
    /// The value cannot be greater than `60000`
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_margin_trade_coeff_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetMarginTradeCoeffV1Params {
    pub timestamp: i64,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_margin_transfer_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetMarginTransferV1Params {
    pub timestamp: i64,
    pub asset: Option<String>,
    /// Transfer Type: ROLL_IN, ROLL_OUT
    pub r#type: Option<String>,
    pub start_time: Option<i64>,
    pub end_time: Option<i64>,
    /// Currently querying page. Start from 1. Default:1
    pub current: Option<i64>,
    /// Default:10 Max:100
    pub size: Option<i64>,
    /// Symbol in Isolated Margin
    pub isolated_symbol: Option<String>,
    /// The value cannot be greater than `60000`
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`update_margin_api_key_ip_v1`]
#[derive(Clone, Debug, Default)]
pub struct UpdateMarginApiKeyIpV1Params {
    pub api_key: String,
    pub ip: String,
    pub timestamp: i64,
    pub recv_window: Option<i64>,
    pub symbol: Option<String>
}

/// struct for passing parameters to the method [`update_margin_listen_key_v1`]
#[derive(Clone, Debug, Default)]
pub struct UpdateMarginListenKeyV1Params {
    pub listen_key: String
}

/// struct for passing parameters to the method [`update_user_data_stream_isolated_v1`]
#[derive(Clone, Debug, Default)]
pub struct UpdateUserDataStreamIsolatedV1Params {
    pub listen_key: String,
    pub symbol: String
}

/// struct for passing parameters to the method [`update_user_data_stream_v1`]
#[derive(Clone, Debug, Default)]
pub struct UpdateUserDataStreamV1Params {
    pub listen_key: String
}


/// struct for typed errors of method [`create_margin_api_key_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateMarginApiKeyV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_margin_borrow_repay_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateMarginBorrowRepayV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_margin_exchange_small_liability_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateMarginExchangeSmallLiabilityV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_margin_isolated_account_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateMarginIsolatedAccountV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_margin_listen_key_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateMarginListenKeyV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_margin_manual_liquidation_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateMarginManualLiquidationV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_margin_max_leverage_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateMarginMaxLeverageV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_margin_order_oco_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateMarginOrderOcoV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_margin_order_oto_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateMarginOrderOtoV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_margin_order_otoco_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateMarginOrderOtocoV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_margin_order_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateMarginOrderV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_user_data_stream_isolated_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateUserDataStreamIsolatedV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_user_data_stream_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateUserDataStreamV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_margin_api_key_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteMarginApiKeyV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_margin_isolated_account_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteMarginIsolatedAccountV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_margin_listen_key_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteMarginListenKeyV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_margin_open_orders_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteMarginOpenOrdersV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_margin_order_list_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteMarginOrderListV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_margin_order_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteMarginOrderV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_user_data_stream_isolated_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteUserDataStreamIsolatedV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_user_data_stream_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteUserDataStreamV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_bnb_burn_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBnbBurnV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_margin_account_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMarginAccountV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_margin_all_assets_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMarginAllAssetsV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_margin_all_order_list_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMarginAllOrderListV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_margin_all_orders_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMarginAllOrdersV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_margin_all_pairs_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMarginAllPairsV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_margin_api_key_list_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMarginApiKeyListV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_margin_api_key_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMarginApiKeyV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_margin_available_inventory_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMarginAvailableInventoryV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_margin_borrow_repay_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMarginBorrowRepayV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_margin_capital_flow_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMarginCapitalFlowV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_margin_cross_margin_collateral_ratio_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMarginCrossMarginCollateralRatioV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_margin_cross_margin_data_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMarginCrossMarginDataV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_margin_delist_schedule_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMarginDelistScheduleV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_margin_exchange_small_liability_history_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMarginExchangeSmallLiabilityHistoryV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_margin_exchange_small_liability_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMarginExchangeSmallLiabilityV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_margin_force_liquidation_rec_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMarginForceLiquidationRecV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_margin_interest_history_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMarginInterestHistoryV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_margin_interest_rate_history_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMarginInterestRateHistoryV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_margin_isolated_account_limit_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMarginIsolatedAccountLimitV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_margin_isolated_account_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMarginIsolatedAccountV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_margin_isolated_all_pairs_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMarginIsolatedAllPairsV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_margin_isolated_margin_data_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMarginIsolatedMarginDataV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_margin_isolated_margin_tier_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMarginIsolatedMarginTierV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_margin_leverage_bracket_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMarginLeverageBracketV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_margin_max_borrowable_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMarginMaxBorrowableV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_margin_max_transferable_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMarginMaxTransferableV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_margin_my_trades_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMarginMyTradesV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_margin_next_hourly_interest_rate_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMarginNextHourlyInterestRateV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_margin_open_order_list_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMarginOpenOrderListV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_margin_open_orders_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMarginOpenOrdersV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_margin_order_list_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMarginOrderListV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_margin_order_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMarginOrderV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_margin_price_index_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMarginPriceIndexV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_margin_rate_limit_order_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMarginRateLimitOrderV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_margin_trade_coeff_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMarginTradeCoeffV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_margin_transfer_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMarginTransferV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_margin_api_key_ip_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateMarginApiKeyIpV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_margin_listen_key_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateMarginListenKeyV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_user_data_stream_isolated_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateUserDataStreamIsolatedV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_user_data_stream_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateUserDataStreamV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}


/// **Binance Margin offers low-latency trading through a special key, available exclusively to users with VIP level 4 or higher. **
pub async fn create_margin_api_key_v1(configuration: &configuration::Configuration, params: CreateMarginApiKeyV1Params) -> Result<models::CreateMarginApiKeyV1Resp, Error<CreateMarginApiKeyV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/apiKey", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("apiName", params.api_name.to_string());
    if let Some(param_value) = params.ip {
        multipart_form_params.insert("ip", param_value.to_string());
    }
    if let Some(param_value) = params.permission_mode {
        multipart_form_params.insert("permissionMode", param_value.to_string());
    }
    if let Some(param_value) = params.public_key {
        multipart_form_params.insert("publicKey", param_value.to_string());
    }
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    if let Some(param_value) = params.symbol {
        multipart_form_params.insert("symbol", param_value.to_string());
    }
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CreateMarginApiKeyV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CreateMarginApiKeyV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateMarginApiKeyV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Margin account borrow/repay(MARGIN)
pub async fn create_margin_borrow_repay_v1(configuration: &configuration::Configuration, params: CreateMarginBorrowRepayV1Params) -> Result<models::CreateMarginBorrowRepayV1Resp, Error<CreateMarginBorrowRepayV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/borrow-repay", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("amount", params.amount.to_string());
    multipart_form_params.insert("asset", params.asset.to_string());
    multipart_form_params.insert("isIsolated", params.is_isolated.to_string());
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    multipart_form_params.insert("symbol", params.symbol.to_string());
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    multipart_form_params.insert("type", params.r#type.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CreateMarginBorrowRepayV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CreateMarginBorrowRepayV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateMarginBorrowRepayV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Small Liability Exchange
pub async fn create_margin_exchange_small_liability_v1(configuration: &configuration::Configuration, params: CreateMarginExchangeSmallLiabilityV1Params) -> Result<models::MarginCreateMarginExchangeSmallLiabilityV1Resp, Error<CreateMarginExchangeSmallLiabilityV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/exchange-small-liability", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("assetNames", params.asset_names.into_iter().map(|p| serde_json::to_string(&p).unwrap_or_default()).collect::<Vec<String>>().join(",").to_string());
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MarginCreateMarginExchangeSmallLiabilityV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MarginCreateMarginExchangeSmallLiabilityV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateMarginExchangeSmallLiabilityV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Enable isolated margin account for a specific symbol(Only supports activation of previously disabled accounts).
pub async fn create_margin_isolated_account_v1(configuration: &configuration::Configuration, params: CreateMarginIsolatedAccountV1Params) -> Result<models::CreateMarginIsolatedAccountV1Resp, Error<CreateMarginIsolatedAccountV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/isolated/account", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    multipart_form_params.insert("symbol", params.symbol.to_string());
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CreateMarginIsolatedAccountV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CreateMarginIsolatedAccountV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateMarginIsolatedAccountV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Start a new user data stream.
pub async fn create_margin_listen_key_v1(configuration: &configuration::Configuration) -> Result<models::CreateMarginListenKeyV1Resp, Error<CreateMarginListenKeyV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/listen-key", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CreateMarginListenKeyV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CreateMarginListenKeyV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateMarginListenKeyV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Margin Manual Liquidation
pub async fn create_margin_manual_liquidation_v1(configuration: &configuration::Configuration, params: CreateMarginManualLiquidationV1Params) -> Result<models::CreateMarginManualLiquidationV1Resp, Error<CreateMarginManualLiquidationV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/manual-liquidation", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    if let Some(param_value) = params.symbol {
        multipart_form_params.insert("symbol", param_value.to_string());
    }
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    multipart_form_params.insert("type", params.r#type.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CreateMarginManualLiquidationV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CreateMarginManualLiquidationV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateMarginManualLiquidationV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Adjust cross margin max leverage
pub async fn create_margin_max_leverage_v1(configuration: &configuration::Configuration, params: CreateMarginMaxLeverageV1Params) -> Result<models::CreateMarginMaxLeverageV1Resp, Error<CreateMarginMaxLeverageV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/max-leverage", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("maxLeverage", params.max_leverage.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CreateMarginMaxLeverageV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CreateMarginMaxLeverageV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateMarginMaxLeverageV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Send in a new OCO for a margin account
pub async fn create_margin_order_oco_v1(configuration: &configuration::Configuration, params: CreateMarginOrderOcoV1Params) -> Result<models::CreateMarginOrderOcoV1Resp, Error<CreateMarginOrderOcoV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/order/oco", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    if let Some(param_value) = params.auto_repay_at_cancel {
        multipart_form_params.insert("autoRepayAtCancel", param_value.to_string());
    }
    if let Some(param_value) = params.is_isolated {
        multipart_form_params.insert("isIsolated", param_value.to_string());
    }
    if let Some(param_value) = params.limit_client_order_id {
        multipart_form_params.insert("limitClientOrderId", param_value.to_string());
    }
    if let Some(param_value) = params.limit_iceberg_qty {
        multipart_form_params.insert("limitIcebergQty", param_value.to_string());
    }
    if let Some(param_value) = params.list_client_order_id {
        multipart_form_params.insert("listClientOrderId", param_value.to_string());
    }
    if let Some(param_value) = params.new_order_resp_type {
        multipart_form_params.insert("newOrderRespType", param_value.to_string());
    }
    multipart_form_params.insert("price", params.price.to_string());
    multipart_form_params.insert("quantity", params.quantity.to_string());
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    if let Some(param_value) = params.self_trade_prevention_mode {
        multipart_form_params.insert("selfTradePreventionMode", param_value.to_string());
    }
    multipart_form_params.insert("side", params.side.to_string());
    if let Some(param_value) = params.side_effect_type {
        multipart_form_params.insert("sideEffectType", param_value.to_string());
    }
    if let Some(param_value) = params.stop_client_order_id {
        multipart_form_params.insert("stopClientOrderId", param_value.to_string());
    }
    if let Some(param_value) = params.stop_iceberg_qty {
        multipart_form_params.insert("stopIcebergQty", param_value.to_string());
    }
    if let Some(param_value) = params.stop_limit_price {
        multipart_form_params.insert("stopLimitPrice", param_value.to_string());
    }
    if let Some(param_value) = params.stop_limit_time_in_force {
        multipart_form_params.insert("stopLimitTimeInForce", param_value.to_string());
    }
    multipart_form_params.insert("stopPrice", params.stop_price.to_string());
    multipart_form_params.insert("symbol", params.symbol.to_string());
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CreateMarginOrderOcoV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CreateMarginOrderOcoV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateMarginOrderOcoV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Post a new OTO order for margin account:
pub async fn create_margin_order_oto_v1(configuration: &configuration::Configuration, params: CreateMarginOrderOtoV1Params) -> Result<models::CreateMarginOrderOtoV1Resp, Error<CreateMarginOrderOtoV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/order/oto", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    if let Some(param_value) = params.auto_repay_at_cancel {
        multipart_form_params.insert("autoRepayAtCancel", param_value.to_string());
    }
    if let Some(param_value) = params.is_isolated {
        multipart_form_params.insert("isIsolated", param_value.to_string());
    }
    if let Some(param_value) = params.list_client_order_id {
        multipart_form_params.insert("listClientOrderId", param_value.to_string());
    }
    if let Some(param_value) = params.new_order_resp_type {
        multipart_form_params.insert("newOrderRespType", param_value.to_string());
    }
    if let Some(param_value) = params.pending_client_order_id {
        multipart_form_params.insert("pendingClientOrderId", param_value.to_string());
    }
    if let Some(param_value) = params.pending_iceberg_qty {
        multipart_form_params.insert("pendingIcebergQty", param_value.to_string());
    }
    if let Some(param_value) = params.pending_price {
        multipart_form_params.insert("pendingPrice", param_value.to_string());
    }
    multipart_form_params.insert("pendingQuantity", params.pending_quantity.to_string());
    multipart_form_params.insert("pendingSide", params.pending_side.to_string());
    if let Some(param_value) = params.pending_stop_price {
        multipart_form_params.insert("pendingStopPrice", param_value.to_string());
    }
    if let Some(param_value) = params.pending_time_in_force {
        multipart_form_params.insert("pendingTimeInForce", param_value.to_string());
    }
    if let Some(param_value) = params.pending_trailing_delta {
        multipart_form_params.insert("pendingTrailingDelta", param_value.to_string());
    }
    multipart_form_params.insert("pendingType", params.pending_type.to_string());
    if let Some(param_value) = params.self_trade_prevention_mode {
        multipart_form_params.insert("selfTradePreventionMode", param_value.to_string());
    }
    if let Some(param_value) = params.side_effect_type {
        multipart_form_params.insert("sideEffectType", param_value.to_string());
    }
    multipart_form_params.insert("symbol", params.symbol.to_string());
    if let Some(param_value) = params.working_client_order_id {
        multipart_form_params.insert("workingClientOrderId", param_value.to_string());
    }
    multipart_form_params.insert("workingIcebergQty", params.working_iceberg_qty.to_string());
    multipart_form_params.insert("workingPrice", params.working_price.to_string());
    multipart_form_params.insert("workingQuantity", params.working_quantity.to_string());
    multipart_form_params.insert("workingSide", params.working_side.to_string());
    if let Some(param_value) = params.working_time_in_force {
        multipart_form_params.insert("workingTimeInForce", param_value.to_string());
    }
    multipart_form_params.insert("workingType", params.working_type.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CreateMarginOrderOtoV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CreateMarginOrderOtoV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateMarginOrderOtoV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Post a new OTOCO order for margin account：
pub async fn create_margin_order_otoco_v1(configuration: &configuration::Configuration, params: CreateMarginOrderOtocoV1Params) -> Result<models::CreateMarginOrderOtocoV1Resp, Error<CreateMarginOrderOtocoV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/order/otoco", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    if let Some(param_value) = params.auto_repay_at_cancel {
        multipart_form_params.insert("autoRepayAtCancel", param_value.to_string());
    }
    if let Some(param_value) = params.is_isolated {
        multipart_form_params.insert("isIsolated", param_value.to_string());
    }
    if let Some(param_value) = params.list_client_order_id {
        multipart_form_params.insert("listClientOrderId", param_value.to_string());
    }
    if let Some(param_value) = params.new_order_resp_type {
        multipart_form_params.insert("newOrderRespType", param_value.to_string());
    }
    if let Some(param_value) = params.pending_above_client_order_id {
        multipart_form_params.insert("pendingAboveClientOrderId", param_value.to_string());
    }
    if let Some(param_value) = params.pending_above_iceberg_qty {
        multipart_form_params.insert("pendingAboveIcebergQty", param_value.to_string());
    }
    if let Some(param_value) = params.pending_above_price {
        multipart_form_params.insert("pendingAbovePrice", param_value.to_string());
    }
    if let Some(param_value) = params.pending_above_stop_price {
        multipart_form_params.insert("pendingAboveStopPrice", param_value.to_string());
    }
    if let Some(param_value) = params.pending_above_time_in_force {
        multipart_form_params.insert("pendingAboveTimeInForce", param_value.to_string());
    }
    if let Some(param_value) = params.pending_above_trailing_delta {
        multipart_form_params.insert("pendingAboveTrailingDelta", param_value.to_string());
    }
    multipart_form_params.insert("pendingAboveType", params.pending_above_type.to_string());
    if let Some(param_value) = params.pending_below_client_order_id {
        multipart_form_params.insert("pendingBelowClientOrderId", param_value.to_string());
    }
    if let Some(param_value) = params.pending_below_iceberg_qty {
        multipart_form_params.insert("pendingBelowIcebergQty", param_value.to_string());
    }
    if let Some(param_value) = params.pending_below_price {
        multipart_form_params.insert("pendingBelowPrice", param_value.to_string());
    }
    if let Some(param_value) = params.pending_below_stop_price {
        multipart_form_params.insert("pendingBelowStopPrice", param_value.to_string());
    }
    if let Some(param_value) = params.pending_below_time_in_force {
        multipart_form_params.insert("pendingBelowTimeInForce", param_value.to_string());
    }
    if let Some(param_value) = params.pending_below_trailing_delta {
        multipart_form_params.insert("pendingBelowTrailingDelta", param_value.to_string());
    }
    if let Some(param_value) = params.pending_below_type {
        multipart_form_params.insert("pendingBelowType", param_value.to_string());
    }
    multipart_form_params.insert("pendingQuantity", params.pending_quantity.to_string());
    multipart_form_params.insert("pendingSide", params.pending_side.to_string());
    if let Some(param_value) = params.self_trade_prevention_mode {
        multipart_form_params.insert("selfTradePreventionMode", param_value.to_string());
    }
    if let Some(param_value) = params.side_effect_type {
        multipart_form_params.insert("sideEffectType", param_value.to_string());
    }
    multipart_form_params.insert("symbol", params.symbol.to_string());
    if let Some(param_value) = params.working_client_order_id {
        multipart_form_params.insert("workingClientOrderId", param_value.to_string());
    }
    if let Some(param_value) = params.working_iceberg_qty {
        multipart_form_params.insert("workingIcebergQty", param_value.to_string());
    }
    multipart_form_params.insert("workingPrice", params.working_price.to_string());
    multipart_form_params.insert("workingQuantity", params.working_quantity.to_string());
    multipart_form_params.insert("workingSide", params.working_side.to_string());
    if let Some(param_value) = params.working_time_in_force {
        multipart_form_params.insert("workingTimeInForce", param_value.to_string());
    }
    multipart_form_params.insert("workingType", params.working_type.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CreateMarginOrderOtocoV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CreateMarginOrderOtocoV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateMarginOrderOtocoV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Post a new order for margin account.
pub async fn create_margin_order_v1(configuration: &configuration::Configuration, params: CreateMarginOrderV1Params) -> Result<models::MarginCreateMarginOrderV1Resp, Error<CreateMarginOrderV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/order", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    if let Some(param_value) = params.auto_repay_at_cancel {
        multipart_form_params.insert("autoRepayAtCancel", param_value.to_string());
    }
    if let Some(param_value) = params.iceberg_qty {
        multipart_form_params.insert("icebergQty", param_value.to_string());
    }
    if let Some(param_value) = params.is_isolated {
        multipart_form_params.insert("isIsolated", param_value.to_string());
    }
    if let Some(param_value) = params.new_client_order_id {
        multipart_form_params.insert("newClientOrderId", param_value.to_string());
    }
    if let Some(param_value) = params.new_order_resp_type {
        multipart_form_params.insert("newOrderRespType", param_value.to_string());
    }
    if let Some(param_value) = params.price {
        multipart_form_params.insert("price", param_value.to_string());
    }
    if let Some(param_value) = params.quantity {
        multipart_form_params.insert("quantity", param_value.to_string());
    }
    if let Some(param_value) = params.quote_order_qty {
        multipart_form_params.insert("quoteOrderQty", param_value.to_string());
    }
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    if let Some(param_value) = params.self_trade_prevention_mode {
        multipart_form_params.insert("selfTradePreventionMode", param_value.to_string());
    }
    multipart_form_params.insert("side", params.side.to_string());
    if let Some(param_value) = params.side_effect_type {
        multipart_form_params.insert("sideEffectType", param_value.to_string());
    }
    if let Some(param_value) = params.stop_price {
        multipart_form_params.insert("stopPrice", param_value.to_string());
    }
    multipart_form_params.insert("symbol", params.symbol.to_string());
    if let Some(param_value) = params.time_in_force {
        multipart_form_params.insert("timeInForce", param_value.to_string());
    }
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    multipart_form_params.insert("type", params.r#type.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MarginCreateMarginOrderV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MarginCreateMarginOrderV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateMarginOrderV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Start a new isolated margin user data stream. The stream will close after 60 minutes unless a keepalive is sent. If the account has an active listenKey, that listenKey will be returned and its validity will be extended for 60 minutes.
pub async fn create_user_data_stream_isolated_v1(configuration: &configuration::Configuration, params: CreateUserDataStreamIsolatedV1Params) -> Result<models::CreateUserDataStreamIsolatedV1Resp, Error<CreateUserDataStreamIsolatedV1Error>> {

    let uri_str = format!("{}/sapi/v1/userDataStream/isolated", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("symbol", params.symbol.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CreateUserDataStreamIsolatedV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CreateUserDataStreamIsolatedV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateUserDataStreamIsolatedV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Start a new margin user data stream. The stream will close after 60 minutes unless a keepalive is sent. If the account has an active listenKey, that listenKey will be returned and its validity will be extended for 60 minutes.
pub async fn create_user_data_stream_v1(configuration: &configuration::Configuration) -> Result<models::CreateUserDataStreamV1Resp, Error<CreateUserDataStreamV1Error>> {

    let uri_str = format!("{}/sapi/v1/userDataStream", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CreateUserDataStreamV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CreateUserDataStreamV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateUserDataStreamV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This only applies to Special Key for Low Latency Trading.
pub async fn delete_margin_api_key_v1(configuration: &configuration::Configuration, params: DeleteMarginApiKeyV1Params) -> Result<serde_json::Value, Error<DeleteMarginApiKeyV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/apiKey", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.api_key {
        query_params.push(("apiKey".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.api_name {
        query_params.push(("apiName".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.symbol {
        query_params.push(("symbol".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteMarginApiKeyV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Disable isolated margin account for a specific symbol. Each trading pair can only be deactivated once every 24 hours.
pub async fn delete_margin_isolated_account_v1(configuration: &configuration::Configuration, params: DeleteMarginIsolatedAccountV1Params) -> Result<models::DeleteMarginIsolatedAccountV1Resp, Error<DeleteMarginIsolatedAccountV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/isolated/account", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DeleteMarginIsolatedAccountV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DeleteMarginIsolatedAccountV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteMarginIsolatedAccountV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Close out a user data stream.
pub async fn delete_margin_listen_key_v1(configuration: &configuration::Configuration) -> Result<serde_json::Value, Error<DeleteMarginListenKeyV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/listen-key", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteMarginListenKeyV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Cancels all active orders on a symbol for margin account. This includes OCO orders.
pub async fn delete_margin_open_orders_v1(configuration: &configuration::Configuration, params: DeleteMarginOpenOrdersV1Params) -> Result<Vec<models::DeleteMarginOpenOrdersV1RespItem>, Error<DeleteMarginOpenOrdersV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/openOrders", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    if let Some(ref param_value) = params.is_isolated {
        query_params.push(("isIsolated".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::DeleteMarginOpenOrdersV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::DeleteMarginOpenOrdersV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteMarginOpenOrdersV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Cancel an entire Order List for a margin account.
pub async fn delete_margin_order_list_v1(configuration: &configuration::Configuration, params: DeleteMarginOrderListV1Params) -> Result<models::DeleteMarginOrderListV1Resp, Error<DeleteMarginOrderListV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/orderList", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    if let Some(ref param_value) = params.is_isolated {
        query_params.push(("isIsolated".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.order_list_id {
        query_params.push(("orderListId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.list_client_order_id {
        query_params.push(("listClientOrderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.new_client_order_id {
        query_params.push(("newClientOrderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DeleteMarginOrderListV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DeleteMarginOrderListV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteMarginOrderListV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Cancel an active order for margin account.
pub async fn delete_margin_order_v1(configuration: &configuration::Configuration, params: DeleteMarginOrderV1Params) -> Result<models::DeleteMarginOrderV1Resp, Error<DeleteMarginOrderV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/order", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    if let Some(ref param_value) = params.is_isolated {
        query_params.push(("isIsolated".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.order_id {
        query_params.push(("orderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.orig_client_order_id {
        query_params.push(("origClientOrderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.new_client_order_id {
        query_params.push(("newClientOrderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DeleteMarginOrderV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DeleteMarginOrderV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteMarginOrderV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Close out a isolated margin user data stream.
pub async fn delete_user_data_stream_isolated_v1(configuration: &configuration::Configuration, params: DeleteUserDataStreamIsolatedV1Params) -> Result<serde_json::Value, Error<DeleteUserDataStreamIsolatedV1Error>> {

    let uri_str = format!("{}/sapi/v1/userDataStream/isolated", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    query_params.push(("listenkey".to_string(), params.listenkey.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteUserDataStreamIsolatedV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Close out a Margin user data stream.
pub async fn delete_user_data_stream_v1(configuration: &configuration::Configuration, params: DeleteUserDataStreamV1Params) -> Result<serde_json::Value, Error<DeleteUserDataStreamV1Error>> {

    let uri_str = format!("{}/sapi/v1/userDataStream", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("listenkey".to_string(), params.listenkey.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteUserDataStreamV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get BNB Burn Status
pub async fn get_bnb_burn_v1(configuration: &configuration::Configuration, params: GetBnbBurnV1Params) -> Result<models::GetBnbBurnV1Resp, Error<GetBnbBurnV1Error>> {

    let uri_str = format!("{}/sapi/v1/bnbBurn", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetBnbBurnV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetBnbBurnV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetBnbBurnV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Query Cross Margin Account Details
pub async fn get_margin_account_v1(configuration: &configuration::Configuration, params: GetMarginAccountV1Params) -> Result<models::GetMarginAccountV1Resp, Error<GetMarginAccountV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/account", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetMarginAccountV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetMarginAccountV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMarginAccountV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get All Margin Assets.
pub async fn get_margin_all_assets_v1(configuration: &configuration::Configuration, params: GetMarginAllAssetsV1Params) -> Result<Vec<models::GetMarginAllAssetsV1RespItem>, Error<GetMarginAllAssetsV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/allAssets", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.asset {
        query_params.push(("asset".to_string(), param_value.to_string()));
    }

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GetMarginAllAssetsV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GetMarginAllAssetsV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMarginAllAssetsV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves all OCO for a specific margin account based on provided optional parameters
pub async fn get_margin_all_order_list_v1(configuration: &configuration::Configuration, params: GetMarginAllOrderListV1Params) -> Result<Vec<models::GetMarginAllOrderListV1RespItem>, Error<GetMarginAllOrderListV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/allOrderList", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.is_isolated {
        query_params.push(("isIsolated".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.symbol {
        query_params.push(("symbol".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.from_id {
        query_params.push(("fromId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.start_time {
        query_params.push(("startTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.end_time {
        query_params.push(("endTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.limit {
        query_params.push(("limit".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GetMarginAllOrderListV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GetMarginAllOrderListV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMarginAllOrderListV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Query Margin Account's All Orders
pub async fn get_margin_all_orders_v1(configuration: &configuration::Configuration, params: GetMarginAllOrdersV1Params) -> Result<Vec<models::GetMarginAllOrdersV1RespItem>, Error<GetMarginAllOrdersV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/allOrders", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    if let Some(ref param_value) = params.is_isolated {
        query_params.push(("isIsolated".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.order_id {
        query_params.push(("orderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.start_time {
        query_params.push(("startTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.end_time {
        query_params.push(("endTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.limit {
        query_params.push(("limit".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GetMarginAllOrdersV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GetMarginAllOrdersV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMarginAllOrdersV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get All Cross Margin Pairs
pub async fn get_margin_all_pairs_v1(configuration: &configuration::Configuration, params: GetMarginAllPairsV1Params) -> Result<Vec<models::GetMarginAllPairsV1RespItem>, Error<GetMarginAllPairsV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/allPairs", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.symbol {
        query_params.push(("symbol".to_string(), param_value.to_string()));
    }

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GetMarginAllPairsV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GetMarginAllPairsV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMarginAllPairsV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This only applies to Special Key for Low Latency Trading.
pub async fn get_margin_api_key_list_v1(configuration: &configuration::Configuration, params: GetMarginApiKeyListV1Params) -> Result<Vec<models::GetMarginApiKeyListV1RespItem>, Error<GetMarginApiKeyListV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/api-key-list", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.symbol {
        query_params.push(("symbol".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GetMarginApiKeyListV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GetMarginApiKeyListV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMarginApiKeyListV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Query Special Key Information.
pub async fn get_margin_api_key_v1(configuration: &configuration::Configuration, params: GetMarginApiKeyV1Params) -> Result<models::GetMarginApiKeyV1Resp, Error<GetMarginApiKeyV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/apiKey", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("apiKey".to_string(), params.api_key.to_string()));
    if let Some(ref param_value) = params.symbol {
        query_params.push(("symbol".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetMarginApiKeyV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetMarginApiKeyV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMarginApiKeyV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Margin available Inventory query
pub async fn get_margin_available_inventory_v1(configuration: &configuration::Configuration, params: GetMarginAvailableInventoryV1Params) -> Result<models::MarginGetMarginAvailableInventoryV1Resp, Error<GetMarginAvailableInventoryV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/available-inventory", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("type".to_string(), params.r#type.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MarginGetMarginAvailableInventoryV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MarginGetMarginAvailableInventoryV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMarginAvailableInventoryV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Query borrow/repay records in Margin account
pub async fn get_margin_borrow_repay_v1(configuration: &configuration::Configuration, params: GetMarginBorrowRepayV1Params) -> Result<models::GetMarginBorrowRepayV1Resp, Error<GetMarginBorrowRepayV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/borrow-repay", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.asset {
        query_params.push(("asset".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.isolated_symbol {
        query_params.push(("isolatedSymbol".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.tx_id {
        query_params.push(("txId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.start_time {
        query_params.push(("startTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.end_time {
        query_params.push(("endTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.current {
        query_params.push(("current".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.size {
        query_params.push(("size".to_string(), param_value.to_string()));
    }
    query_params.push(("type".to_string(), params.r#type.to_string()));
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetMarginBorrowRepayV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetMarginBorrowRepayV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMarginBorrowRepayV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Query Cross Isolated Margin Capital Flow
pub async fn get_margin_capital_flow_v1(configuration: &configuration::Configuration, params: GetMarginCapitalFlowV1Params) -> Result<Vec<models::GetMarginCapitalFlowV1RespItem>, Error<GetMarginCapitalFlowV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/capital-flow", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.asset {
        query_params.push(("asset".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.symbol {
        query_params.push(("symbol".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.r#type {
        query_params.push(("type".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.start_time {
        query_params.push(("startTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.end_time {
        query_params.push(("endTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.from_id {
        query_params.push(("fromId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.limit {
        query_params.push(("limit".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GetMarginCapitalFlowV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GetMarginCapitalFlowV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMarginCapitalFlowV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Cross margin collateral ratio
pub async fn get_margin_cross_margin_collateral_ratio_v1(configuration: &configuration::Configuration) -> Result<Vec<models::GetMarginCrossMarginCollateralRatioV1RespItem>, Error<GetMarginCrossMarginCollateralRatioV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/crossMarginCollateralRatio", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GetMarginCrossMarginCollateralRatioV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GetMarginCrossMarginCollateralRatioV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMarginCrossMarginCollateralRatioV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get cross margin fee data collection with any vip level or user's current specific data as https://www.binance.com/en/margin-fee
pub async fn get_margin_cross_margin_data_v1(configuration: &configuration::Configuration, params: GetMarginCrossMarginDataV1Params) -> Result<Vec<models::GetMarginCrossMarginDataV1RespItem>, Error<GetMarginCrossMarginDataV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/crossMarginData", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.vip_level {
        query_params.push(("vipLevel".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.coin {
        query_params.push(("coin".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GetMarginCrossMarginDataV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GetMarginCrossMarginDataV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMarginCrossMarginDataV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get tokens or symbols delist schedule for cross margin and isolated margin
pub async fn get_margin_delist_schedule_v1(configuration: &configuration::Configuration, params: GetMarginDelistScheduleV1Params) -> Result<Vec<models::GetMarginDelistScheduleV1RespItem>, Error<GetMarginDelistScheduleV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/delist-schedule", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GetMarginDelistScheduleV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GetMarginDelistScheduleV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMarginDelistScheduleV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get Small liability Exchange History
pub async fn get_margin_exchange_small_liability_history_v1(configuration: &configuration::Configuration, params: GetMarginExchangeSmallLiabilityHistoryV1Params) -> Result<models::GetMarginExchangeSmallLiabilityHistoryV1Resp, Error<GetMarginExchangeSmallLiabilityHistoryV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/exchange-small-liability-history", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("current".to_string(), params.current.to_string()));
    query_params.push(("size".to_string(), params.size.to_string()));
    if let Some(ref param_value) = params.start_time {
        query_params.push(("startTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.end_time {
        query_params.push(("endTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetMarginExchangeSmallLiabilityHistoryV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetMarginExchangeSmallLiabilityHistoryV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMarginExchangeSmallLiabilityHistoryV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Query the coins which can be small liability exchange
pub async fn get_margin_exchange_small_liability_v1(configuration: &configuration::Configuration, params: GetMarginExchangeSmallLiabilityV1Params) -> Result<Vec<models::GetMarginExchangeSmallLiabilityV1RespItem>, Error<GetMarginExchangeSmallLiabilityV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/exchange-small-liability", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GetMarginExchangeSmallLiabilityV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GetMarginExchangeSmallLiabilityV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMarginExchangeSmallLiabilityV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get Force Liquidation Record
pub async fn get_margin_force_liquidation_rec_v1(configuration: &configuration::Configuration, params: GetMarginForceLiquidationRecV1Params) -> Result<models::GetMarginForceLiquidationRecV1Resp, Error<GetMarginForceLiquidationRecV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/forceLiquidationRec", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.start_time {
        query_params.push(("startTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.end_time {
        query_params.push(("endTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.isolated_symbol {
        query_params.push(("isolatedSymbol".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.current {
        query_params.push(("current".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.size {
        query_params.push(("size".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetMarginForceLiquidationRecV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetMarginForceLiquidationRecV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMarginForceLiquidationRecV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get Interest History
pub async fn get_margin_interest_history_v1(configuration: &configuration::Configuration, params: GetMarginInterestHistoryV1Params) -> Result<models::GetMarginInterestHistoryV1Resp, Error<GetMarginInterestHistoryV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/interestHistory", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.asset {
        query_params.push(("asset".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.isolated_symbol {
        query_params.push(("isolatedSymbol".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.start_time {
        query_params.push(("startTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.end_time {
        query_params.push(("endTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.current {
        query_params.push(("current".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.size {
        query_params.push(("size".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetMarginInterestHistoryV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetMarginInterestHistoryV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMarginInterestHistoryV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Query Margin Interest Rate History
pub async fn get_margin_interest_rate_history_v1(configuration: &configuration::Configuration, params: GetMarginInterestRateHistoryV1Params) -> Result<Vec<models::GetMarginInterestRateHistoryV1RespItem>, Error<GetMarginInterestRateHistoryV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/interestRateHistory", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("asset".to_string(), params.asset.to_string()));
    if let Some(ref param_value) = params.vip_level {
        query_params.push(("vipLevel".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.start_time {
        query_params.push(("startTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.end_time {
        query_params.push(("endTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GetMarginInterestRateHistoryV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GetMarginInterestRateHistoryV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMarginInterestRateHistoryV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Query enabled isolated margin account limit.
pub async fn get_margin_isolated_account_limit_v1(configuration: &configuration::Configuration, params: GetMarginIsolatedAccountLimitV1Params) -> Result<models::GetMarginIsolatedAccountLimitV1Resp, Error<GetMarginIsolatedAccountLimitV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/isolated/accountLimit", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetMarginIsolatedAccountLimitV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetMarginIsolatedAccountLimitV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMarginIsolatedAccountLimitV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Query Isolated Margin Account Info
pub async fn get_margin_isolated_account_v1(configuration: &configuration::Configuration, params: GetMarginIsolatedAccountV1Params) -> Result<models::GetMarginIsolatedAccountV1Resp, Error<GetMarginIsolatedAccountV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/isolated/account", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.symbols {
        query_params.push(("symbols".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetMarginIsolatedAccountV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetMarginIsolatedAccountV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMarginIsolatedAccountV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get All Isolated Margin Symbol
pub async fn get_margin_isolated_all_pairs_v1(configuration: &configuration::Configuration, params: GetMarginIsolatedAllPairsV1Params) -> Result<Vec<models::GetMarginIsolatedAllPairsV1RespItem>, Error<GetMarginIsolatedAllPairsV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/isolated/allPairs", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.symbol {
        query_params.push(("symbol".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GetMarginIsolatedAllPairsV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GetMarginIsolatedAllPairsV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMarginIsolatedAllPairsV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get isolated margin fee data collection with any vip level or user's current specific data as https://www.binance.com/en/margin-fee
pub async fn get_margin_isolated_margin_data_v1(configuration: &configuration::Configuration, params: GetMarginIsolatedMarginDataV1Params) -> Result<Vec<models::GetMarginIsolatedMarginDataV1RespItem>, Error<GetMarginIsolatedMarginDataV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/isolatedMarginData", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.vip_level {
        query_params.push(("vipLevel".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.symbol {
        query_params.push(("symbol".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GetMarginIsolatedMarginDataV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GetMarginIsolatedMarginDataV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMarginIsolatedMarginDataV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get isolated margin tier data collection with any tier as https://www.binance.com/en/margin-data
pub async fn get_margin_isolated_margin_tier_v1(configuration: &configuration::Configuration, params: GetMarginIsolatedMarginTierV1Params) -> Result<Vec<models::GetMarginIsolatedMarginTierV1RespItem>, Error<GetMarginIsolatedMarginTierV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/isolatedMarginTier", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    if let Some(ref param_value) = params.tier {
        query_params.push(("tier".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GetMarginIsolatedMarginTierV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GetMarginIsolatedMarginTierV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMarginIsolatedMarginTierV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Liability Coin Leverage Bracket in Cross Margin Pro Mode
pub async fn get_margin_leverage_bracket_v1(configuration: &configuration::Configuration) -> Result<Vec<models::GetMarginLeverageBracketV1RespItem>, Error<GetMarginLeverageBracketV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/leverageBracket", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GetMarginLeverageBracketV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GetMarginLeverageBracketV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMarginLeverageBracketV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Query Max Borrow
pub async fn get_margin_max_borrowable_v1(configuration: &configuration::Configuration, params: GetMarginMaxBorrowableV1Params) -> Result<models::GetMarginMaxBorrowableV1Resp, Error<GetMarginMaxBorrowableV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/maxBorrowable", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("asset".to_string(), params.asset.to_string()));
    if let Some(ref param_value) = params.isolated_symbol {
        query_params.push(("isolatedSymbol".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetMarginMaxBorrowableV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetMarginMaxBorrowableV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMarginMaxBorrowableV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Query Max Transfer-Out Amount
pub async fn get_margin_max_transferable_v1(configuration: &configuration::Configuration, params: GetMarginMaxTransferableV1Params) -> Result<models::GetMarginMaxTransferableV1Resp, Error<GetMarginMaxTransferableV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/maxTransferable", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("asset".to_string(), params.asset.to_string()));
    if let Some(ref param_value) = params.isolated_symbol {
        query_params.push(("isolatedSymbol".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetMarginMaxTransferableV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetMarginMaxTransferableV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMarginMaxTransferableV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Query Margin Account's Trade List
pub async fn get_margin_my_trades_v1(configuration: &configuration::Configuration, params: GetMarginMyTradesV1Params) -> Result<Vec<models::GetMarginMyTradesV1RespItem>, Error<GetMarginMyTradesV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/myTrades", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    if let Some(ref param_value) = params.is_isolated {
        query_params.push(("isIsolated".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.order_id {
        query_params.push(("orderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.start_time {
        query_params.push(("startTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.end_time {
        query_params.push(("endTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.from_id {
        query_params.push(("fromId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.limit {
        query_params.push(("limit".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GetMarginMyTradesV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GetMarginMyTradesV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMarginMyTradesV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get future hourly interest rate
pub async fn get_margin_next_hourly_interest_rate_v1(configuration: &configuration::Configuration, params: GetMarginNextHourlyInterestRateV1Params) -> Result<Vec<models::GetMarginNextHourlyInterestRateV1RespItem>, Error<GetMarginNextHourlyInterestRateV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/next-hourly-interest-rate", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("assets".to_string(), params.assets.to_string()));
    query_params.push(("isIsolated".to_string(), params.is_isolated.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GetMarginNextHourlyInterestRateV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GetMarginNextHourlyInterestRateV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMarginNextHourlyInterestRateV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Query Margin Account's Open OCO
pub async fn get_margin_open_order_list_v1(configuration: &configuration::Configuration, params: GetMarginOpenOrderListV1Params) -> Result<Vec<models::GetMarginOpenOrderListV1RespItem>, Error<GetMarginOpenOrderListV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/openOrderList", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.is_isolated {
        query_params.push(("isIsolated".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.symbol {
        query_params.push(("symbol".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GetMarginOpenOrderListV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GetMarginOpenOrderListV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMarginOpenOrderListV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Query Margin Account's Open Orders
pub async fn get_margin_open_orders_v1(configuration: &configuration::Configuration, params: GetMarginOpenOrdersV1Params) -> Result<Vec<models::MarginGetMarginOpenOrdersV1RespItem>, Error<GetMarginOpenOrdersV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/openOrders", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.symbol {
        query_params.push(("symbol".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.is_isolated {
        query_params.push(("isIsolated".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::MarginGetMarginOpenOrdersV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::MarginGetMarginOpenOrdersV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMarginOpenOrdersV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves a specific OCO based on provided optional parameters
pub async fn get_margin_order_list_v1(configuration: &configuration::Configuration, params: GetMarginOrderListV1Params) -> Result<models::GetMarginOrderListV1Resp, Error<GetMarginOrderListV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/orderList", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.is_isolated {
        query_params.push(("isIsolated".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.symbol {
        query_params.push(("symbol".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.order_list_id {
        query_params.push(("orderListId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.orig_client_order_id {
        query_params.push(("origClientOrderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetMarginOrderListV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetMarginOrderListV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMarginOrderListV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Query Margin Account's Order
pub async fn get_margin_order_v1(configuration: &configuration::Configuration, params: GetMarginOrderV1Params) -> Result<models::GetMarginOrderV1Resp, Error<GetMarginOrderV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/order", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    if let Some(ref param_value) = params.is_isolated {
        query_params.push(("isIsolated".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.order_id {
        query_params.push(("orderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.orig_client_order_id {
        query_params.push(("origClientOrderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetMarginOrderV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetMarginOrderV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMarginOrderV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Query Margin PriceIndex
pub async fn get_margin_price_index_v1(configuration: &configuration::Configuration, params: GetMarginPriceIndexV1Params) -> Result<models::GetMarginPriceIndexV1Resp, Error<GetMarginPriceIndexV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/priceIndex", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetMarginPriceIndexV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetMarginPriceIndexV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMarginPriceIndexV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Displays the user's current margin order count usage for all intervals.
pub async fn get_margin_rate_limit_order_v1(configuration: &configuration::Configuration, params: GetMarginRateLimitOrderV1Params) -> Result<Vec<models::GetMarginRateLimitOrderV1RespItem>, Error<GetMarginRateLimitOrderV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/rateLimit/order", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.is_isolated {
        query_params.push(("isIsolated".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.symbol {
        query_params.push(("symbol".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GetMarginRateLimitOrderV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GetMarginRateLimitOrderV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMarginRateLimitOrderV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get personal margin level information
pub async fn get_margin_trade_coeff_v1(configuration: &configuration::Configuration, params: GetMarginTradeCoeffV1Params) -> Result<models::GetMarginTradeCoeffV1Resp, Error<GetMarginTradeCoeffV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/tradeCoeff", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetMarginTradeCoeffV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetMarginTradeCoeffV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMarginTradeCoeffV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get Cross Margin Transfer History
pub async fn get_margin_transfer_v1(configuration: &configuration::Configuration, params: GetMarginTransferV1Params) -> Result<models::GetMarginTransferV1Resp, Error<GetMarginTransferV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/transfer", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.asset {
        query_params.push(("asset".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.r#type {
        query_params.push(("type".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.start_time {
        query_params.push(("startTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.end_time {
        query_params.push(("endTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.current {
        query_params.push(("current".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.size {
        query_params.push(("size".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.isolated_symbol {
        query_params.push(("isolatedSymbol".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetMarginTransferV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetMarginTransferV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMarginTransferV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Edit ip restriction. This only applies to Special Key for Low Latency Trading.
pub async fn update_margin_api_key_ip_v1(configuration: &configuration::Configuration, params: UpdateMarginApiKeyIpV1Params) -> Result<serde_json::Value, Error<UpdateMarginApiKeyIpV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/apiKey/ip", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("apiKey", params.api_key.to_string());
    multipart_form_params.insert("ip", params.ip.to_string());
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    if let Some(param_value) = params.symbol {
        multipart_form_params.insert("symbol", param_value.to_string());
    }
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateMarginApiKeyIpV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Keepalive a user data stream to prevent a time out.
pub async fn update_margin_listen_key_v1(configuration: &configuration::Configuration, params: UpdateMarginListenKeyV1Params) -> Result<serde_json::Value, Error<UpdateMarginListenKeyV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/listen-key", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("listenKey", params.listen_key.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateMarginListenKeyV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Keepalive an isolated margin user data stream to prevent a time out.
pub async fn update_user_data_stream_isolated_v1(configuration: &configuration::Configuration, params: UpdateUserDataStreamIsolatedV1Params) -> Result<serde_json::Value, Error<UpdateUserDataStreamIsolatedV1Error>> {

    let uri_str = format!("{}/sapi/v1/userDataStream/isolated", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("listenKey", params.listen_key.to_string());
    multipart_form_params.insert("symbol", params.symbol.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateUserDataStreamIsolatedV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Keepalive a margin user data stream to prevent a time out.
pub async fn update_user_data_stream_v1(configuration: &configuration::Configuration, params: UpdateUserDataStreamV1Params) -> Result<serde_json::Value, Error<UpdateUserDataStreamV1Error>> {

    let uri_str = format!("{}/sapi/v1/userDataStream", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("listenKey", params.listen_key.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateUserDataStreamV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

