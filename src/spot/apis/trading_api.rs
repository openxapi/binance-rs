/*
 * Binance Spot API
 *
 * OpenAPI specification for Binance exchange - Spot API
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::spot::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};

/// struct for passing parameters to the method [`spot_create_order_cancel_replace_v3`]
#[derive(Clone, Debug)]
pub struct SpotCreateOrderCancelReplaceV3Params {
    pub cancel_replace_mode: String,
    pub side: String,
    pub symbol: String,
    pub timestamp: i64,
    pub r#type: String,
    pub cancel_new_client_order_id: Option<String>,
    pub cancel_order_id: Option<i64>,
    pub cancel_orig_client_order_id: Option<String>,
    pub cancel_restrictions: Option<String>,
    pub iceberg_qty: Option<String>,
    pub new_client_order_id: Option<String>,
    pub new_order_resp_type: Option<String>,
    pub order_rate_limit_exceeded_mode: Option<String>,
    pub price: Option<String>,
    pub quantity: Option<String>,
    pub quote_order_qty: Option<String>,
    pub recv_window: Option<i64>,
    pub self_trade_prevention_mode: Option<String>,
    pub stop_price: Option<String>,
    pub strategy_id: Option<i64>,
    pub strategy_type: Option<i32>,
    pub time_in_force: Option<String>,
    pub trailing_delta: Option<i64>
}

/// struct for passing parameters to the method [`spot_create_order_list_oco_v3`]
#[derive(Clone, Debug)]
pub struct SpotCreateOrderListOcoV3Params {
    pub above_type: String,
    pub below_type: String,
    pub quantity: String,
    pub side: String,
    pub symbol: String,
    pub timestamp: i64,
    pub above_client_order_id: Option<String>,
    pub above_iceberg_qty: Option<i64>,
    pub above_price: Option<String>,
    pub above_stop_price: Option<String>,
    pub above_strategy_id: Option<i64>,
    pub above_strategy_type: Option<i32>,
    pub above_time_in_force: Option<String>,
    pub above_trailing_delta: Option<i64>,
    pub below_client_order_id: Option<String>,
    pub below_iceberg_qty: Option<i64>,
    pub below_price: Option<String>,
    pub below_stop_price: Option<String>,
    pub below_strategy_id: Option<i64>,
    pub below_strategy_type: Option<i32>,
    pub below_time_in_force: Option<String>,
    pub below_trailing_delta: Option<i64>,
    pub list_client_order_id: Option<String>,
    pub new_order_resp_type: Option<String>,
    pub recv_window: Option<i64>,
    pub self_trade_prevention_mode: Option<String>
}

/// struct for passing parameters to the method [`spot_create_order_list_oto_v3`]
#[derive(Clone, Debug)]
pub struct SpotCreateOrderListOtoV3Params {
    pub pending_quantity: String,
    pub pending_side: String,
    pub pending_type: String,
    pub symbol: String,
    pub timestamp: i64,
    pub working_price: String,
    pub working_quantity: String,
    pub working_side: String,
    pub working_type: String,
    pub list_client_order_id: Option<String>,
    pub new_order_resp_type: Option<String>,
    pub pending_client_order_id: Option<String>,
    pub pending_iceberg_qty: Option<String>,
    pub pending_price: Option<String>,
    pub pending_stop_price: Option<String>,
    pub pending_strategy_id: Option<i64>,
    pub pending_strategy_type: Option<i32>,
    pub pending_time_in_force: Option<String>,
    pub pending_trailing_delta: Option<String>,
    pub recv_window: Option<i64>,
    pub self_trade_prevention_mode: Option<String>,
    pub working_client_order_id: Option<String>,
    pub working_iceberg_qty: Option<String>,
    pub working_strategy_id: Option<i64>,
    pub working_strategy_type: Option<i32>,
    pub working_time_in_force: Option<String>
}

/// struct for passing parameters to the method [`spot_create_order_list_otoco_v3`]
#[derive(Clone, Debug)]
pub struct SpotCreateOrderListOtocoV3Params {
    pub pending_above_type: String,
    pub pending_quantity: String,
    pub pending_side: String,
    pub symbol: String,
    pub timestamp: i64,
    pub working_price: String,
    pub working_quantity: String,
    pub working_side: String,
    pub working_type: String,
    pub list_client_order_id: Option<String>,
    pub new_order_resp_type: Option<String>,
    pub pending_above_client_order_id: Option<String>,
    pub pending_above_iceberg_qty: Option<String>,
    pub pending_above_price: Option<String>,
    pub pending_above_stop_price: Option<String>,
    pub pending_above_strategy_id: Option<i64>,
    pub pending_above_strategy_type: Option<i32>,
    pub pending_above_time_in_force: Option<String>,
    pub pending_above_trailing_delta: Option<String>,
    pub pending_below_client_order_id: Option<String>,
    pub pending_below_iceberg_qty: Option<String>,
    pub pending_below_price: Option<String>,
    pub pending_below_stop_price: Option<String>,
    pub pending_below_strategy_id: Option<i64>,
    pub pending_below_strategy_type: Option<i32>,
    pub pending_below_time_in_force: Option<String>,
    pub pending_below_trailing_delta: Option<String>,
    pub pending_below_type: Option<String>,
    pub recv_window: Option<i64>,
    pub self_trade_prevention_mode: Option<String>,
    pub working_client_order_id: Option<String>,
    pub working_iceberg_qty: Option<String>,
    pub working_strategy_id: Option<i64>,
    pub working_strategy_type: Option<i32>,
    pub working_time_in_force: Option<String>
}

/// struct for passing parameters to the method [`spot_create_order_oco_v3`]
#[derive(Clone, Debug)]
pub struct SpotCreateOrderOcoV3Params {
    pub price: String,
    pub quantity: String,
    pub side: String,
    pub stop_price: String,
    pub symbol: String,
    pub timestamp: i64,
    pub limit_client_order_id: Option<String>,
    pub limit_iceberg_qty: Option<String>,
    pub limit_strategy_id: Option<i64>,
    pub limit_strategy_type: Option<i32>,
    pub list_client_order_id: Option<String>,
    pub new_order_resp_type: Option<String>,
    pub recv_window: Option<i64>,
    pub self_trade_prevention_mode: Option<String>,
    pub stop_client_order_id: Option<String>,
    pub stop_iceberg_qty: Option<String>,
    pub stop_limit_price: Option<String>,
    pub stop_limit_time_in_force: Option<String>,
    pub stop_strategy_id: Option<i64>,
    pub stop_strategy_type: Option<i32>,
    pub trailing_delta: Option<i64>
}

/// struct for passing parameters to the method [`spot_create_order_test_v3`]
#[derive(Clone, Debug)]
pub struct SpotCreateOrderTestV3Params {
    pub side: String,
    pub symbol: String,
    pub timestamp: i64,
    pub r#type: String,
    pub compute_commission_rates: Option<bool>,
    pub iceberg_qty: Option<String>,
    pub new_client_order_id: Option<String>,
    pub new_order_resp_type: Option<String>,
    pub price: Option<String>,
    pub quantity: Option<String>,
    pub quote_order_qty: Option<String>,
    pub recv_window: Option<i64>,
    pub self_trade_prevention_mode: Option<String>,
    pub stop_price: Option<String>,
    pub strategy_id: Option<i64>,
    pub strategy_type: Option<i32>,
    pub time_in_force: Option<String>,
    pub trailing_delta: Option<i64>
}

/// struct for passing parameters to the method [`spot_create_order_v3`]
#[derive(Clone, Debug)]
pub struct SpotCreateOrderV3Params {
    pub side: String,
    pub symbol: String,
    pub timestamp: i64,
    pub r#type: String,
    pub iceberg_qty: Option<String>,
    pub new_client_order_id: Option<String>,
    pub new_order_resp_type: Option<String>,
    pub price: Option<String>,
    pub quantity: Option<String>,
    pub quote_order_qty: Option<String>,
    pub recv_window: Option<i64>,
    pub self_trade_prevention_mode: Option<String>,
    pub stop_price: Option<String>,
    pub strategy_id: Option<i64>,
    pub strategy_type: Option<i32>,
    pub time_in_force: Option<String>,
    pub trailing_delta: Option<i64>
}

/// struct for passing parameters to the method [`spot_create_sor_order_test_v3`]
#[derive(Clone, Debug)]
pub struct SpotCreateSorOrderTestV3Params {
    pub quantity: String,
    pub side: String,
    pub symbol: String,
    pub timestamp: i64,
    pub r#type: String,
    pub compute_commission_rates: Option<bool>,
    pub iceberg_qty: Option<String>,
    pub new_client_order_id: Option<String>,
    pub new_order_resp_type: Option<String>,
    pub price: Option<String>,
    pub recv_window: Option<i64>,
    pub self_trade_prevention_mode: Option<String>,
    pub strategy_id: Option<i64>,
    pub strategy_type: Option<i32>,
    pub time_in_force: Option<String>
}

/// struct for passing parameters to the method [`spot_create_sor_order_v3`]
#[derive(Clone, Debug)]
pub struct SpotCreateSorOrderV3Params {
    pub quantity: String,
    pub side: String,
    pub symbol: String,
    pub timestamp: i64,
    pub r#type: String,
    pub iceberg_qty: Option<String>,
    pub new_client_order_id: Option<String>,
    pub new_order_resp_type: Option<String>,
    pub price: Option<String>,
    pub recv_window: Option<i64>,
    pub self_trade_prevention_mode: Option<String>,
    pub strategy_id: Option<i64>,
    pub strategy_type: Option<i32>,
    pub time_in_force: Option<String>
}

/// struct for passing parameters to the method [`spot_delete_open_orders_v3`]
#[derive(Clone, Debug)]
pub struct SpotDeleteOpenOrdersV3Params {
    pub symbol: String,
    pub timestamp: i64,
    /// The value cannot be greater than `60000`
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`spot_delete_order_list_v3`]
#[derive(Clone, Debug)]
pub struct SpotDeleteOrderListV3Params {
    pub symbol: String,
    pub timestamp: i64,
    /// Either `orderListId` or `listClientOrderId` must be provided
    pub order_list_id: Option<i64>,
    /// Either `orderListId` or `listClientOrderId` must be provided
    pub list_client_order_id: Option<String>,
    /// Used to uniquely identify this cancel. Automatically generated by default
    pub new_client_order_id: Option<String>,
    /// The value cannot be greater than `60000`
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`spot_delete_order_v3`]
#[derive(Clone, Debug)]
pub struct SpotDeleteOrderV3Params {
    pub symbol: String,
    pub timestamp: i64,
    pub order_id: Option<i64>,
    pub orig_client_order_id: Option<String>,
    /// Used to uniquely identify this cancel. Automatically generated by default.
    pub new_client_order_id: Option<String>,
    /// Supported values: <br/>`ONLY_NEW` - Cancel will succeed if the order status is `NEW`.<br/> `ONLY_PARTIALLY_FILLED ` - Cancel will succeed if order status is `PARTIALLY_FILLED`.
    pub cancel_restrictions: Option<String>,
    /// The value cannot be greater than `60000`.
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`spot_get_all_order_list_v3`]
#[derive(Clone, Debug)]
pub struct SpotGetAllOrderListV3Params {
    pub timestamp: i64,
    /// If supplied, neither `startTime` or `endTime` can be provided
    pub from_id: Option<i64>,
    pub start_time: Option<i64>,
    pub end_time: Option<i64>,
    /// Default Value: 500; Max Value: 1000
    pub limit: Option<i32>,
    /// The value cannot be greater than `60000`
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`spot_get_all_orders_v3`]
#[derive(Clone, Debug)]
pub struct SpotGetAllOrdersV3Params {
    pub symbol: String,
    pub timestamp: i64,
    pub order_id: Option<i64>,
    pub start_time: Option<i64>,
    pub end_time: Option<i64>,
    /// Default 500; max 1000.
    pub limit: Option<i32>,
    /// The value cannot be greater than `60000`
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`spot_get_open_order_list_v3`]
#[derive(Clone, Debug)]
pub struct SpotGetOpenOrderListV3Params {
    pub timestamp: i64,
    /// The value cannot be greater than `60000`
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`spot_get_open_orders_v3`]
#[derive(Clone, Debug)]
pub struct SpotGetOpenOrdersV3Params {
    pub timestamp: i64,
    pub symbol: Option<String>,
    /// The value cannot be greater than `60000`
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`spot_get_order_list_v3`]
#[derive(Clone, Debug)]
pub struct SpotGetOrderListV3Params {
    pub timestamp: i64,
    /// Either `orderListId` or `listClientOrderId` must be provided
    pub order_list_id: Option<i64>,
    /// Either `orderListId` or `listClientOrderId` must be provided
    pub orig_client_order_id: Option<String>,
    /// The value cannot be greater than `60000`
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`spot_get_order_v3`]
#[derive(Clone, Debug)]
pub struct SpotGetOrderV3Params {
    pub symbol: String,
    pub timestamp: i64,
    pub order_id: Option<i64>,
    pub orig_client_order_id: Option<String>,
    /// The value cannot be greater than `60000`
    pub recv_window: Option<i64>
}


/// struct for typed errors of method [`spot_create_order_cancel_replace_v3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SpotCreateOrderCancelReplaceV3Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`spot_create_order_list_oco_v3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SpotCreateOrderListOcoV3Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`spot_create_order_list_oto_v3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SpotCreateOrderListOtoV3Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`spot_create_order_list_otoco_v3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SpotCreateOrderListOtocoV3Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`spot_create_order_oco_v3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SpotCreateOrderOcoV3Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`spot_create_order_test_v3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SpotCreateOrderTestV3Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`spot_create_order_v3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SpotCreateOrderV3Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`spot_create_sor_order_test_v3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SpotCreateSorOrderTestV3Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`spot_create_sor_order_v3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SpotCreateSorOrderV3Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`spot_delete_open_orders_v3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SpotDeleteOpenOrdersV3Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`spot_delete_order_list_v3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SpotDeleteOrderListV3Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`spot_delete_order_v3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SpotDeleteOrderV3Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`spot_get_all_order_list_v3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SpotGetAllOrderListV3Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`spot_get_all_orders_v3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SpotGetAllOrdersV3Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`spot_get_open_order_list_v3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SpotGetOpenOrderListV3Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`spot_get_open_orders_v3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SpotGetOpenOrdersV3Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`spot_get_order_list_v3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SpotGetOrderListV3Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`spot_get_order_v3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SpotGetOrderV3Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}


/// Cancels an existing order and places a new order on the same symbol. Filters and Order Count are evaluated before the processing of the cancellation and order placement occurs. A new order that was not attempted (i.e. when newOrderResult: NOT_ATTEMPTED ), will still increase the order count by 1.
pub async fn spot_create_order_cancel_replace_v3(configuration: &configuration::Configuration, params: SpotCreateOrderCancelReplaceV3Params) -> Result<models::SpotCreateOrderCancelReplaceV3Resp, Error<SpotCreateOrderCancelReplaceV3Error>> {

    let uri_str = format!("{}/api/v3/order/cancelReplace", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };
    let mut multipart_form_params = std::collections::HashMap::new();
    if let Some(param_value) = params.cancel_new_client_order_id {
        multipart_form_params.insert("cancelNewClientOrderId", param_value.to_string());
    }
    if let Some(param_value) = params.cancel_order_id {
        multipart_form_params.insert("cancelOrderId", param_value.to_string());
    }
    if let Some(param_value) = params.cancel_orig_client_order_id {
        multipart_form_params.insert("cancelOrigClientOrderId", param_value.to_string());
    }
    multipart_form_params.insert("cancelReplaceMode", params.cancel_replace_mode.to_string());
    if let Some(param_value) = params.cancel_restrictions {
        multipart_form_params.insert("cancelRestrictions", param_value.to_string());
    }
    if let Some(param_value) = params.iceberg_qty {
        multipart_form_params.insert("icebergQty", param_value.to_string());
    }
    if let Some(param_value) = params.new_client_order_id {
        multipart_form_params.insert("newClientOrderId", param_value.to_string());
    }
    if let Some(param_value) = params.new_order_resp_type {
        multipart_form_params.insert("newOrderRespType", param_value.to_string());
    }
    if let Some(param_value) = params.order_rate_limit_exceeded_mode {
        multipart_form_params.insert("orderRateLimitExceededMode", param_value.to_string());
    }
    if let Some(param_value) = params.price {
        multipart_form_params.insert("price", param_value.to_string());
    }
    if let Some(param_value) = params.quantity {
        multipart_form_params.insert("quantity", param_value.to_string());
    }
    if let Some(param_value) = params.quote_order_qty {
        multipart_form_params.insert("quoteOrderQty", param_value.to_string());
    }
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    if let Some(param_value) = params.self_trade_prevention_mode {
        multipart_form_params.insert("selfTradePreventionMode", param_value.to_string());
    }
    multipart_form_params.insert("side", params.side.to_string());
    if let Some(param_value) = params.stop_price {
        multipart_form_params.insert("stopPrice", param_value.to_string());
    }
    if let Some(param_value) = params.strategy_id {
        multipart_form_params.insert("strategyId", param_value.to_string());
    }
    if let Some(param_value) = params.strategy_type {
        multipart_form_params.insert("strategyType", param_value.to_string());
    }
    multipart_form_params.insert("symbol", params.symbol.to_string());
    if let Some(param_value) = params.time_in_force {
        multipart_form_params.insert("timeInForce", param_value.to_string());
    }
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    if let Some(param_value) = params.trailing_delta {
        multipart_form_params.insert("trailingDelta", param_value.to_string());
    }
    multipart_form_params.insert("type", params.r#type.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SpotCreateOrderCancelReplaceV3Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SpotCreateOrderCancelReplaceV3Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SpotCreateOrderCancelReplaceV3Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Send in an one-cancels-the-other (OCO) pair, where activation of one order immediately cancels the other. - An OCO has 2 orders called the above order and below order. - One of the orders must be a LIMIT_MAKER/TAKE_PROFIT/TAKE_PROFIT_LIMIT order and the other must be STOP_LOSS or STOP_LOSS_LIMIT order. - Price restrictions  If the OCO is on the SELL side:  LIMIT_MAKER/TAKE_PROFIT_LIMIT price > Last Traded Price >  STOP_LOSS/STOP_LOSS_LIMIT stopPrice TAKE_PROFIT stopPrice > Last Traded Price > STOP_LOSS/STOP_LOSS_LIMIT stopPrice   If the OCO is on the BUY side:  LIMIT_MAKER/TAKE_PROFIT_LIMIT price < Last Traded Price < stopPrice TAKE_PROFIT stopPrice < Last Traded Price < STOP_LOSS/STOP_LOSS_LIMIT stopPrice - OCOs add 2 orders to the unfilled order count, EXCHANGE_MAX_ORDERS filter, and the MAX_NUM_ORDERS filter.
pub async fn spot_create_order_list_oco_v3(configuration: &configuration::Configuration, params: SpotCreateOrderListOcoV3Params) -> Result<models::SpotCreateOrderListOcoV3Resp, Error<SpotCreateOrderListOcoV3Error>> {

    let uri_str = format!("{}/api/v3/orderList/oco", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };
    let mut multipart_form_params = std::collections::HashMap::new();
    if let Some(param_value) = params.above_client_order_id {
        multipart_form_params.insert("aboveClientOrderId", param_value.to_string());
    }
    if let Some(param_value) = params.above_iceberg_qty {
        multipart_form_params.insert("aboveIcebergQty", param_value.to_string());
    }
    if let Some(param_value) = params.above_price {
        multipart_form_params.insert("abovePrice", param_value.to_string());
    }
    if let Some(param_value) = params.above_stop_price {
        multipart_form_params.insert("aboveStopPrice", param_value.to_string());
    }
    if let Some(param_value) = params.above_strategy_id {
        multipart_form_params.insert("aboveStrategyId", param_value.to_string());
    }
    if let Some(param_value) = params.above_strategy_type {
        multipart_form_params.insert("aboveStrategyType", param_value.to_string());
    }
    if let Some(param_value) = params.above_time_in_force {
        multipart_form_params.insert("aboveTimeInForce", param_value.to_string());
    }
    if let Some(param_value) = params.above_trailing_delta {
        multipart_form_params.insert("aboveTrailingDelta", param_value.to_string());
    }
    multipart_form_params.insert("aboveType", params.above_type.to_string());
    if let Some(param_value) = params.below_client_order_id {
        multipart_form_params.insert("belowClientOrderId", param_value.to_string());
    }
    if let Some(param_value) = params.below_iceberg_qty {
        multipart_form_params.insert("belowIcebergQty", param_value.to_string());
    }
    if let Some(param_value) = params.below_price {
        multipart_form_params.insert("belowPrice", param_value.to_string());
    }
    if let Some(param_value) = params.below_stop_price {
        multipart_form_params.insert("belowStopPrice", param_value.to_string());
    }
    if let Some(param_value) = params.below_strategy_id {
        multipart_form_params.insert("belowStrategyId", param_value.to_string());
    }
    if let Some(param_value) = params.below_strategy_type {
        multipart_form_params.insert("belowStrategyType", param_value.to_string());
    }
    if let Some(param_value) = params.below_time_in_force {
        multipart_form_params.insert("belowTimeInForce", param_value.to_string());
    }
    if let Some(param_value) = params.below_trailing_delta {
        multipart_form_params.insert("belowTrailingDelta", param_value.to_string());
    }
    multipart_form_params.insert("belowType", params.below_type.to_string());
    if let Some(param_value) = params.list_client_order_id {
        multipart_form_params.insert("listClientOrderId", param_value.to_string());
    }
    if let Some(param_value) = params.new_order_resp_type {
        multipart_form_params.insert("newOrderRespType", param_value.to_string());
    }
    multipart_form_params.insert("quantity", params.quantity.to_string());
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    if let Some(param_value) = params.self_trade_prevention_mode {
        multipart_form_params.insert("selfTradePreventionMode", param_value.to_string());
    }
    multipart_form_params.insert("side", params.side.to_string());
    multipart_form_params.insert("symbol", params.symbol.to_string());
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SpotCreateOrderListOcoV3Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SpotCreateOrderListOcoV3Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SpotCreateOrderListOcoV3Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Places an OTO. - An OTO (One-Triggers-the-Other) is an order list comprised of 2 orders. - The first order is called the working order and must be LIMIT or LIMIT_MAKER. Initially, only the working order goes on the order book. - The second order is called the pending order. It can be any order type except for MARKET orders using parameter quoteOrderQty. The pending order is only placed on the order book when the working order gets fully filled. - If either the working order or the pending order is cancelled individually, the other order in the order list will also be canceled or expired. - When the order list is placed, if the working order gets immediately fully filled, the placement response will show the working order as FILLED but the pending order will still appear as PENDING_NEW. You need to query the status of the pending order again to see its updated status. - OTOs add 2 orders to the unfilled order count, EXCHANGE_MAX_NUM_ORDERS filter and MAX_NUM_ORDERS filter.
pub async fn spot_create_order_list_oto_v3(configuration: &configuration::Configuration, params: SpotCreateOrderListOtoV3Params) -> Result<models::SpotCreateOrderListOtoV3Resp, Error<SpotCreateOrderListOtoV3Error>> {

    let uri_str = format!("{}/api/v3/orderList/oto", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };
    let mut multipart_form_params = std::collections::HashMap::new();
    if let Some(param_value) = params.list_client_order_id {
        multipart_form_params.insert("listClientOrderId", param_value.to_string());
    }
    if let Some(param_value) = params.new_order_resp_type {
        multipart_form_params.insert("newOrderRespType", param_value.to_string());
    }
    if let Some(param_value) = params.pending_client_order_id {
        multipart_form_params.insert("pendingClientOrderId", param_value.to_string());
    }
    if let Some(param_value) = params.pending_iceberg_qty {
        multipart_form_params.insert("pendingIcebergQty", param_value.to_string());
    }
    if let Some(param_value) = params.pending_price {
        multipart_form_params.insert("pendingPrice", param_value.to_string());
    }
    multipart_form_params.insert("pendingQuantity", params.pending_quantity.to_string());
    multipart_form_params.insert("pendingSide", params.pending_side.to_string());
    if let Some(param_value) = params.pending_stop_price {
        multipart_form_params.insert("pendingStopPrice", param_value.to_string());
    }
    if let Some(param_value) = params.pending_strategy_id {
        multipart_form_params.insert("pendingStrategyId", param_value.to_string());
    }
    if let Some(param_value) = params.pending_strategy_type {
        multipart_form_params.insert("pendingStrategyType", param_value.to_string());
    }
    if let Some(param_value) = params.pending_time_in_force {
        multipart_form_params.insert("pendingTimeInForce", param_value.to_string());
    }
    if let Some(param_value) = params.pending_trailing_delta {
        multipart_form_params.insert("pendingTrailingDelta", param_value.to_string());
    }
    multipart_form_params.insert("pendingType", params.pending_type.to_string());
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    if let Some(param_value) = params.self_trade_prevention_mode {
        multipart_form_params.insert("selfTradePreventionMode", param_value.to_string());
    }
    multipart_form_params.insert("symbol", params.symbol.to_string());
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    if let Some(param_value) = params.working_client_order_id {
        multipart_form_params.insert("workingClientOrderId", param_value.to_string());
    }
    if let Some(param_value) = params.working_iceberg_qty {
        multipart_form_params.insert("workingIcebergQty", param_value.to_string());
    }
    multipart_form_params.insert("workingPrice", params.working_price.to_string());
    multipart_form_params.insert("workingQuantity", params.working_quantity.to_string());
    multipart_form_params.insert("workingSide", params.working_side.to_string());
    if let Some(param_value) = params.working_strategy_id {
        multipart_form_params.insert("workingStrategyId", param_value.to_string());
    }
    if let Some(param_value) = params.working_strategy_type {
        multipart_form_params.insert("workingStrategyType", param_value.to_string());
    }
    if let Some(param_value) = params.working_time_in_force {
        multipart_form_params.insert("workingTimeInForce", param_value.to_string());
    }
    multipart_form_params.insert("workingType", params.working_type.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SpotCreateOrderListOtoV3Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SpotCreateOrderListOtoV3Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SpotCreateOrderListOtoV3Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Place an OTOCO. - An OTOCO (One-Triggers-One-Cancels-the-Other) is an order list comprised of 3 orders. - The first order is called the working order and must be LIMIT or LIMIT_MAKER. Initially, only the working order goes on the order book.  The behavior of the working order is the same as the OTO. - OTOCO has 2 pending orders (pending above and pending below), forming an OCO pair. The pending orders are only placed on the order book when the working order gets fully filled.  The rules of the pending above and pending below follow the same rules as the Order list OCO. - OTOCOs add 3 orders against the unfilled order count, EXCHANGE_MAX_NUM_ORDERS filter, and MAX_NUM_ORDERS filter.
pub async fn spot_create_order_list_otoco_v3(configuration: &configuration::Configuration, params: SpotCreateOrderListOtocoV3Params) -> Result<models::SpotCreateOrderListOtocoV3Resp, Error<SpotCreateOrderListOtocoV3Error>> {

    let uri_str = format!("{}/api/v3/orderList/otoco", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };
    let mut multipart_form_params = std::collections::HashMap::new();
    if let Some(param_value) = params.list_client_order_id {
        multipart_form_params.insert("listClientOrderId", param_value.to_string());
    }
    if let Some(param_value) = params.new_order_resp_type {
        multipart_form_params.insert("newOrderRespType", param_value.to_string());
    }
    if let Some(param_value) = params.pending_above_client_order_id {
        multipart_form_params.insert("pendingAboveClientOrderId", param_value.to_string());
    }
    if let Some(param_value) = params.pending_above_iceberg_qty {
        multipart_form_params.insert("pendingAboveIcebergQty", param_value.to_string());
    }
    if let Some(param_value) = params.pending_above_price {
        multipart_form_params.insert("pendingAbovePrice", param_value.to_string());
    }
    if let Some(param_value) = params.pending_above_stop_price {
        multipart_form_params.insert("pendingAboveStopPrice", param_value.to_string());
    }
    if let Some(param_value) = params.pending_above_strategy_id {
        multipart_form_params.insert("pendingAboveStrategyId", param_value.to_string());
    }
    if let Some(param_value) = params.pending_above_strategy_type {
        multipart_form_params.insert("pendingAboveStrategyType", param_value.to_string());
    }
    if let Some(param_value) = params.pending_above_time_in_force {
        multipart_form_params.insert("pendingAboveTimeInForce", param_value.to_string());
    }
    if let Some(param_value) = params.pending_above_trailing_delta {
        multipart_form_params.insert("pendingAboveTrailingDelta", param_value.to_string());
    }
    multipart_form_params.insert("pendingAboveType", params.pending_above_type.to_string());
    if let Some(param_value) = params.pending_below_client_order_id {
        multipart_form_params.insert("pendingBelowClientOrderId", param_value.to_string());
    }
    if let Some(param_value) = params.pending_below_iceberg_qty {
        multipart_form_params.insert("pendingBelowIcebergQty", param_value.to_string());
    }
    if let Some(param_value) = params.pending_below_price {
        multipart_form_params.insert("pendingBelowPrice", param_value.to_string());
    }
    if let Some(param_value) = params.pending_below_stop_price {
        multipart_form_params.insert("pendingBelowStopPrice", param_value.to_string());
    }
    if let Some(param_value) = params.pending_below_strategy_id {
        multipart_form_params.insert("pendingBelowStrategyId", param_value.to_string());
    }
    if let Some(param_value) = params.pending_below_strategy_type {
        multipart_form_params.insert("pendingBelowStrategyType", param_value.to_string());
    }
    if let Some(param_value) = params.pending_below_time_in_force {
        multipart_form_params.insert("pendingBelowTimeInForce", param_value.to_string());
    }
    if let Some(param_value) = params.pending_below_trailing_delta {
        multipart_form_params.insert("pendingBelowTrailingDelta", param_value.to_string());
    }
    if let Some(param_value) = params.pending_below_type {
        multipart_form_params.insert("pendingBelowType", param_value.to_string());
    }
    multipart_form_params.insert("pendingQuantity", params.pending_quantity.to_string());
    multipart_form_params.insert("pendingSide", params.pending_side.to_string());
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    if let Some(param_value) = params.self_trade_prevention_mode {
        multipart_form_params.insert("selfTradePreventionMode", param_value.to_string());
    }
    multipart_form_params.insert("symbol", params.symbol.to_string());
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    if let Some(param_value) = params.working_client_order_id {
        multipart_form_params.insert("workingClientOrderId", param_value.to_string());
    }
    if let Some(param_value) = params.working_iceberg_qty {
        multipart_form_params.insert("workingIcebergQty", param_value.to_string());
    }
    multipart_form_params.insert("workingPrice", params.working_price.to_string());
    multipart_form_params.insert("workingQuantity", params.working_quantity.to_string());
    multipart_form_params.insert("workingSide", params.working_side.to_string());
    if let Some(param_value) = params.working_strategy_id {
        multipart_form_params.insert("workingStrategyId", param_value.to_string());
    }
    if let Some(param_value) = params.working_strategy_type {
        multipart_form_params.insert("workingStrategyType", param_value.to_string());
    }
    if let Some(param_value) = params.working_time_in_force {
        multipart_form_params.insert("workingTimeInForce", param_value.to_string());
    }
    multipart_form_params.insert("workingType", params.working_type.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SpotCreateOrderListOtocoV3Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SpotCreateOrderListOtocoV3Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SpotCreateOrderListOtocoV3Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Send in a new OCO. - Price Restrictions:  SELL: Limit Price > Last Price > Stop Price BUY: Limit Price < Last Price < Stop Price - Quantity Restrictions:  Both legs must have the same quantity. ICEBERG quantities however do not have to be the same - OCO adds 2 orders to the unfilled order count, EXCHANGE_MAX_ORDERS filter and the MAX_NUM_ORDERS filter.
pub async fn spot_create_order_oco_v3(configuration: &configuration::Configuration, params: SpotCreateOrderOcoV3Params) -> Result<models::SpotCreateOrderOcoV3Resp, Error<SpotCreateOrderOcoV3Error>> {

    let uri_str = format!("{}/api/v3/order/oco", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };
    let mut multipart_form_params = std::collections::HashMap::new();
    if let Some(param_value) = params.limit_client_order_id {
        multipart_form_params.insert("limitClientOrderId", param_value.to_string());
    }
    if let Some(param_value) = params.limit_iceberg_qty {
        multipart_form_params.insert("limitIcebergQty", param_value.to_string());
    }
    if let Some(param_value) = params.limit_strategy_id {
        multipart_form_params.insert("limitStrategyId", param_value.to_string());
    }
    if let Some(param_value) = params.limit_strategy_type {
        multipart_form_params.insert("limitStrategyType", param_value.to_string());
    }
    if let Some(param_value) = params.list_client_order_id {
        multipart_form_params.insert("listClientOrderId", param_value.to_string());
    }
    if let Some(param_value) = params.new_order_resp_type {
        multipart_form_params.insert("newOrderRespType", param_value.to_string());
    }
    multipart_form_params.insert("price", params.price.to_string());
    multipart_form_params.insert("quantity", params.quantity.to_string());
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    if let Some(param_value) = params.self_trade_prevention_mode {
        multipart_form_params.insert("selfTradePreventionMode", param_value.to_string());
    }
    multipart_form_params.insert("side", params.side.to_string());
    if let Some(param_value) = params.stop_client_order_id {
        multipart_form_params.insert("stopClientOrderId", param_value.to_string());
    }
    if let Some(param_value) = params.stop_iceberg_qty {
        multipart_form_params.insert("stopIcebergQty", param_value.to_string());
    }
    if let Some(param_value) = params.stop_limit_price {
        multipart_form_params.insert("stopLimitPrice", param_value.to_string());
    }
    if let Some(param_value) = params.stop_limit_time_in_force {
        multipart_form_params.insert("stopLimitTimeInForce", param_value.to_string());
    }
    multipart_form_params.insert("stopPrice", params.stop_price.to_string());
    if let Some(param_value) = params.stop_strategy_id {
        multipart_form_params.insert("stopStrategyId", param_value.to_string());
    }
    if let Some(param_value) = params.stop_strategy_type {
        multipart_form_params.insert("stopStrategyType", param_value.to_string());
    }
    multipart_form_params.insert("symbol", params.symbol.to_string());
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    if let Some(param_value) = params.trailing_delta {
        multipart_form_params.insert("trailingDelta", param_value.to_string());
    }
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SpotCreateOrderOcoV3Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SpotCreateOrderOcoV3Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SpotCreateOrderOcoV3Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Test new order creation and signature/recvWindow long. Creates and validates a new order but does not send it into the matching engine.
pub async fn spot_create_order_test_v3(configuration: &configuration::Configuration, params: SpotCreateOrderTestV3Params) -> Result<models::SpotCreateOrderTestV3Resp, Error<SpotCreateOrderTestV3Error>> {

    let uri_str = format!("{}/api/v3/order/test", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };
    let mut multipart_form_params = std::collections::HashMap::new();
    if let Some(param_value) = params.compute_commission_rates {
        multipart_form_params.insert("computeCommissionRates", param_value.to_string());
    }
    if let Some(param_value) = params.iceberg_qty {
        multipart_form_params.insert("icebergQty", param_value.to_string());
    }
    if let Some(param_value) = params.new_client_order_id {
        multipart_form_params.insert("newClientOrderId", param_value.to_string());
    }
    if let Some(param_value) = params.new_order_resp_type {
        multipart_form_params.insert("newOrderRespType", param_value.to_string());
    }
    if let Some(param_value) = params.price {
        multipart_form_params.insert("price", param_value.to_string());
    }
    if let Some(param_value) = params.quantity {
        multipart_form_params.insert("quantity", param_value.to_string());
    }
    if let Some(param_value) = params.quote_order_qty {
        multipart_form_params.insert("quoteOrderQty", param_value.to_string());
    }
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    if let Some(param_value) = params.self_trade_prevention_mode {
        multipart_form_params.insert("selfTradePreventionMode", param_value.to_string());
    }
    multipart_form_params.insert("side", params.side.to_string());
    if let Some(param_value) = params.stop_price {
        multipart_form_params.insert("stopPrice", param_value.to_string());
    }
    if let Some(param_value) = params.strategy_id {
        multipart_form_params.insert("strategyId", param_value.to_string());
    }
    if let Some(param_value) = params.strategy_type {
        multipart_form_params.insert("strategyType", param_value.to_string());
    }
    multipart_form_params.insert("symbol", params.symbol.to_string());
    if let Some(param_value) = params.time_in_force {
        multipart_form_params.insert("timeInForce", param_value.to_string());
    }
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    if let Some(param_value) = params.trailing_delta {
        multipart_form_params.insert("trailingDelta", param_value.to_string());
    }
    multipart_form_params.insert("type", params.r#type.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SpotCreateOrderTestV3Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SpotCreateOrderTestV3Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SpotCreateOrderTestV3Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Send in a new order.
pub async fn spot_create_order_v3(configuration: &configuration::Configuration, params: SpotCreateOrderV3Params) -> Result<models::SpotCreateOrderV3Resp, Error<SpotCreateOrderV3Error>> {

    let uri_str = format!("{}/api/v3/order", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };
    let mut multipart_form_params = std::collections::HashMap::new();
    if let Some(param_value) = params.iceberg_qty {
        multipart_form_params.insert("icebergQty", param_value.to_string());
    }
    if let Some(param_value) = params.new_client_order_id {
        multipart_form_params.insert("newClientOrderId", param_value.to_string());
    }
    if let Some(param_value) = params.new_order_resp_type {
        multipart_form_params.insert("newOrderRespType", param_value.to_string());
    }
    if let Some(param_value) = params.price {
        multipart_form_params.insert("price", param_value.to_string());
    }
    if let Some(param_value) = params.quantity {
        multipart_form_params.insert("quantity", param_value.to_string());
    }
    if let Some(param_value) = params.quote_order_qty {
        multipart_form_params.insert("quoteOrderQty", param_value.to_string());
    }
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    if let Some(param_value) = params.self_trade_prevention_mode {
        multipart_form_params.insert("selfTradePreventionMode", param_value.to_string());
    }
    multipart_form_params.insert("side", params.side.to_string());
    if let Some(param_value) = params.stop_price {
        multipart_form_params.insert("stopPrice", param_value.to_string());
    }
    if let Some(param_value) = params.strategy_id {
        multipart_form_params.insert("strategyId", param_value.to_string());
    }
    if let Some(param_value) = params.strategy_type {
        multipart_form_params.insert("strategyType", param_value.to_string());
    }
    multipart_form_params.insert("symbol", params.symbol.to_string());
    if let Some(param_value) = params.time_in_force {
        multipart_form_params.insert("timeInForce", param_value.to_string());
    }
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    if let Some(param_value) = params.trailing_delta {
        multipart_form_params.insert("trailingDelta", param_value.to_string());
    }
    multipart_form_params.insert("type", params.r#type.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SpotCreateOrderV3Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SpotCreateOrderV3Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SpotCreateOrderV3Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Test new order creation and signature/recvWindow using smart order routing (SOR). Creates and validates a new order but does not send it into the matching engine.
pub async fn spot_create_sor_order_test_v3(configuration: &configuration::Configuration, params: SpotCreateSorOrderTestV3Params) -> Result<models::SpotCreateSorOrderTestV3Resp, Error<SpotCreateSorOrderTestV3Error>> {

    let uri_str = format!("{}/api/v3/sor/order/test", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };
    let mut multipart_form_params = std::collections::HashMap::new();
    if let Some(param_value) = params.compute_commission_rates {
        multipart_form_params.insert("computeCommissionRates", param_value.to_string());
    }
    if let Some(param_value) = params.iceberg_qty {
        multipart_form_params.insert("icebergQty", param_value.to_string());
    }
    if let Some(param_value) = params.new_client_order_id {
        multipart_form_params.insert("newClientOrderId", param_value.to_string());
    }
    if let Some(param_value) = params.new_order_resp_type {
        multipart_form_params.insert("newOrderRespType", param_value.to_string());
    }
    if let Some(param_value) = params.price {
        multipart_form_params.insert("price", param_value.to_string());
    }
    multipart_form_params.insert("quantity", params.quantity.to_string());
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    if let Some(param_value) = params.self_trade_prevention_mode {
        multipart_form_params.insert("selfTradePreventionMode", param_value.to_string());
    }
    multipart_form_params.insert("side", params.side.to_string());
    if let Some(param_value) = params.strategy_id {
        multipart_form_params.insert("strategyId", param_value.to_string());
    }
    if let Some(param_value) = params.strategy_type {
        multipart_form_params.insert("strategyType", param_value.to_string());
    }
    multipart_form_params.insert("symbol", params.symbol.to_string());
    if let Some(param_value) = params.time_in_force {
        multipart_form_params.insert("timeInForce", param_value.to_string());
    }
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    multipart_form_params.insert("type", params.r#type.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SpotCreateSorOrderTestV3Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SpotCreateSorOrderTestV3Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SpotCreateSorOrderTestV3Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Places an order using smart order routing (SOR).
pub async fn spot_create_sor_order_v3(configuration: &configuration::Configuration, params: SpotCreateSorOrderV3Params) -> Result<models::SpotCreateSorOrderV3Resp, Error<SpotCreateSorOrderV3Error>> {

    let uri_str = format!("{}/api/v3/sor/order", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };
    let mut multipart_form_params = std::collections::HashMap::new();
    if let Some(param_value) = params.iceberg_qty {
        multipart_form_params.insert("icebergQty", param_value.to_string());
    }
    if let Some(param_value) = params.new_client_order_id {
        multipart_form_params.insert("newClientOrderId", param_value.to_string());
    }
    if let Some(param_value) = params.new_order_resp_type {
        multipart_form_params.insert("newOrderRespType", param_value.to_string());
    }
    if let Some(param_value) = params.price {
        multipart_form_params.insert("price", param_value.to_string());
    }
    multipart_form_params.insert("quantity", params.quantity.to_string());
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    if let Some(param_value) = params.self_trade_prevention_mode {
        multipart_form_params.insert("selfTradePreventionMode", param_value.to_string());
    }
    multipart_form_params.insert("side", params.side.to_string());
    if let Some(param_value) = params.strategy_id {
        multipart_form_params.insert("strategyId", param_value.to_string());
    }
    if let Some(param_value) = params.strategy_type {
        multipart_form_params.insert("strategyType", param_value.to_string());
    }
    multipart_form_params.insert("symbol", params.symbol.to_string());
    if let Some(param_value) = params.time_in_force {
        multipart_form_params.insert("timeInForce", param_value.to_string());
    }
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    multipart_form_params.insert("type", params.r#type.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SpotCreateSorOrderV3Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SpotCreateSorOrderV3Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SpotCreateSorOrderV3Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Cancels all active orders on a symbol. This includes orders that are part of an order list.
pub async fn spot_delete_open_orders_v3(configuration: &configuration::Configuration, params: SpotDeleteOpenOrdersV3Params) -> Result<Vec<Vec<models::SpotDeleteOpenOrdersV3RespInner>>, Error<SpotDeleteOpenOrdersV3Error>> {

    let uri_str = format!("{}/api/v3/openOrders", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;Vec&lt;models::SpotDeleteOpenOrdersV3RespInner&gt;&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;Vec&lt;models::SpotDeleteOpenOrdersV3RespInner&gt;&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SpotDeleteOpenOrdersV3Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Cancel an entire Order list
pub async fn spot_delete_order_list_v3(configuration: &configuration::Configuration, params: SpotDeleteOrderListV3Params) -> Result<models::SpotDeleteOrderListV3Resp, Error<SpotDeleteOrderListV3Error>> {

    let uri_str = format!("{}/api/v3/orderList", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    if let Some(ref param_value) = params.order_list_id {
        query_params.push(("orderListId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.list_client_order_id {
        query_params.push(("listClientOrderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.new_client_order_id {
        query_params.push(("newClientOrderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SpotDeleteOrderListV3Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SpotDeleteOrderListV3Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SpotDeleteOrderListV3Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Cancel an active order.
pub async fn spot_delete_order_v3(configuration: &configuration::Configuration, params: SpotDeleteOrderV3Params) -> Result<models::SpotDeleteOrderV3Resp, Error<SpotDeleteOrderV3Error>> {

    let uri_str = format!("{}/api/v3/order", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    if let Some(ref param_value) = params.order_id {
        query_params.push(("orderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.orig_client_order_id {
        query_params.push(("origClientOrderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.new_client_order_id {
        query_params.push(("newClientOrderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.cancel_restrictions {
        query_params.push(("cancelRestrictions".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SpotDeleteOrderV3Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SpotDeleteOrderV3Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SpotDeleteOrderV3Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves all order lists based on provided optional parameters. Note that the time between startTime and endTime can't be longer than 24 hours.
pub async fn spot_get_all_order_list_v3(configuration: &configuration::Configuration, params: SpotGetAllOrderListV3Params) -> Result<Vec<models::SpotGetAllOrderListV3RespItem>, Error<SpotGetAllOrderListV3Error>> {

    let uri_str = format!("{}/api/v3/allOrderList", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.from_id {
        query_params.push(("fromId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.start_time {
        query_params.push(("startTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.end_time {
        query_params.push(("endTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.limit {
        query_params.push(("limit".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::SpotGetAllOrderListV3RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::SpotGetAllOrderListV3RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SpotGetAllOrderListV3Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get all account orders; active, canceled, or filled.
pub async fn spot_get_all_orders_v3(configuration: &configuration::Configuration, params: SpotGetAllOrdersV3Params) -> Result<Vec<models::SpotGetAllOrdersV3RespItem>, Error<SpotGetAllOrdersV3Error>> {

    let uri_str = format!("{}/api/v3/allOrders", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    if let Some(ref param_value) = params.order_id {
        query_params.push(("orderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.start_time {
        query_params.push(("startTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.end_time {
        query_params.push(("endTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.limit {
        query_params.push(("limit".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::SpotGetAllOrdersV3RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::SpotGetAllOrdersV3RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SpotGetAllOrdersV3Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn spot_get_open_order_list_v3(configuration: &configuration::Configuration, params: SpotGetOpenOrderListV3Params) -> Result<Vec<models::SpotGetOpenOrderListV3RespItem>, Error<SpotGetOpenOrderListV3Error>> {

    let uri_str = format!("{}/api/v3/openOrderList", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::SpotGetOpenOrderListV3RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::SpotGetOpenOrderListV3RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SpotGetOpenOrderListV3Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get all open orders on a symbol. Careful when accessing this with no symbol. Weight: 6 for a single symbol; 80 when the symbol parameter is omitted
pub async fn spot_get_open_orders_v3(configuration: &configuration::Configuration, params: SpotGetOpenOrdersV3Params) -> Result<Vec<models::SpotGetOpenOrdersV3RespItem>, Error<SpotGetOpenOrdersV3Error>> {

    let uri_str = format!("{}/api/v3/openOrders", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.symbol {
        query_params.push(("symbol".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::SpotGetOpenOrdersV3RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::SpotGetOpenOrdersV3RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SpotGetOpenOrdersV3Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves a specific order list based on provided optional parameters.
pub async fn spot_get_order_list_v3(configuration: &configuration::Configuration, params: SpotGetOrderListV3Params) -> Result<models::SpotGetOrderListV3Resp, Error<SpotGetOrderListV3Error>> {

    let uri_str = format!("{}/api/v3/orderList", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.order_list_id {
        query_params.push(("orderListId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.orig_client_order_id {
        query_params.push(("origClientOrderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SpotGetOrderListV3Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SpotGetOrderListV3Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SpotGetOrderListV3Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Check an order's status.
pub async fn spot_get_order_v3(configuration: &configuration::Configuration, params: SpotGetOrderV3Params) -> Result<models::SpotGetOrderV3Resp, Error<SpotGetOrderV3Error>> {

    let uri_str = format!("{}/api/v3/order", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    if let Some(ref param_value) = params.order_id {
        query_params.push(("orderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.orig_client_order_id {
        query_params.push(("origClientOrderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-MBX-APIKEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SpotGetOrderV3Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SpotGetOrderV3Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SpotGetOrderV3Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

