/*
 * Binance Spot API
 *
 * OpenAPI specification for Binance exchange - Spot API
 *
 * The version of the OpenAPI document: 0.2.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::spot::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};

/// struct for passing parameters to the method [`create_account_disable_fast_withdraw_switch_v1`]
#[derive(Clone, Debug, Default)]
pub struct CreateAccountDisableFastWithdrawSwitchV1Params {
    pub timestamp: i64,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`create_account_enable_fast_withdraw_switch_v1`]
#[derive(Clone, Debug, Default)]
pub struct CreateAccountEnableFastWithdrawSwitchV1Params {
    pub timestamp: i64,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`create_asset_dust_btc_v1`]
#[derive(Clone, Debug, Default)]
pub struct CreateAssetDustBtcV1Params {
    pub timestamp: i64,
    pub account_type: Option<String>,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`create_asset_dust_v1`]
#[derive(Clone, Debug, Default)]
pub struct CreateAssetDustV1Params {
    pub asset: Vec<String>,
    pub timestamp: i64,
    pub account_type: Option<String>,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`create_asset_get_funding_asset_v1`]
#[derive(Clone, Debug, Default)]
pub struct CreateAssetGetFundingAssetV1Params {
    pub timestamp: i64,
    pub asset: Option<String>,
    pub need_btc_valuation: Option<String>,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`create_asset_get_user_asset_v3`]
#[derive(Clone, Debug, Default)]
pub struct CreateAssetGetUserAssetV3Params {
    pub timestamp: i64,
    pub asset: Option<String>,
    pub need_btc_valuation: Option<bool>,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`create_asset_transfer_v1`]
#[derive(Clone, Debug, Default)]
pub struct CreateAssetTransferV1Params {
    pub amount: String,
    pub asset: String,
    pub timestamp: i64,
    pub r#type: String,
    pub from_symbol: Option<String>,
    pub recv_window: Option<i64>,
    pub to_symbol: Option<String>
}

/// struct for passing parameters to the method [`create_bnb_burn_v1`]
#[derive(Clone, Debug, Default)]
pub struct CreateBnbBurnV1Params {
    pub timestamp: i64,
    pub interest_bnb_burn: Option<String>,
    pub recv_window: Option<i64>,
    pub spot_bnb_burn: Option<String>
}

/// struct for passing parameters to the method [`create_capital_deposit_credit_apply_v1`]
#[derive(Clone, Debug, Default)]
pub struct CreateCapitalDepositCreditApplyV1Params {
    pub deposit_id: Option<i64>,
    pub sub_account_id: Option<i64>,
    pub sub_user_id: Option<i64>,
    pub tx_id: Option<String>
}

/// struct for passing parameters to the method [`create_capital_withdraw_apply_v1`]
#[derive(Clone, Debug, Default)]
pub struct CreateCapitalWithdrawApplyV1Params {
    pub address: String,
    pub amount: String,
    pub coin: String,
    pub timestamp: i64,
    pub address_tag: Option<String>,
    pub name: Option<String>,
    pub network: Option<String>,
    pub recv_window: Option<i64>,
    pub transaction_fee_flag: Option<bool>,
    pub wallet_type: Option<i32>,
    pub withdraw_order_id: Option<String>
}

/// struct for passing parameters to the method [`create_localentity_broker_withdraw_apply_v1`]
#[derive(Clone, Debug, Default)]
pub struct CreateLocalentityBrokerWithdrawApplyV1Params {
    pub address: String,
    pub amount: String,
    pub coin: String,
    pub originator_pii: String,
    pub questionnaire: String,
    pub signature: String,
    pub sub_account_id: String,
    pub timestamp: i64,
    pub withdraw_order_id: String,
    pub address_name: Option<String>,
    pub address_tag: Option<String>,
    pub network: Option<String>,
    pub transaction_fee_flag: Option<bool>,
    pub wallet_type: Option<i32>
}

/// struct for passing parameters to the method [`create_localentity_withdraw_apply_v1`]
#[derive(Clone, Debug, Default)]
pub struct CreateLocalentityWithdrawApplyV1Params {
    pub address: String,
    pub amount: String,
    pub coin: String,
    pub questionnaire: String,
    pub timestamp: i64,
    pub address_tag: Option<String>,
    pub name: Option<String>,
    pub network: Option<String>,
    pub recv_window: Option<i64>,
    pub transaction_fee_flag: Option<bool>,
    pub wallet_type: Option<i32>,
    pub withdraw_order_id: Option<String>
}

/// struct for passing parameters to the method [`get_account_api_restrictions_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetAccountApiRestrictionsV1Params {
    pub timestamp: i64,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_account_api_trading_status_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetAccountApiTradingStatusV1Params {
    pub timestamp: i64,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_account_info_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetAccountInfoV1Params {
    pub timestamp: i64,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_account_snapshot_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetAccountSnapshotV1Params {
    /// &#34;SPOT&#34;, &#34;MARGIN&#34;, &#34;FUTURES&#34;
    pub r#type: String,
    pub timestamp: i64,
    pub start_time: Option<i64>,
    pub end_time: Option<i64>,
    /// min 7, max 30, default 7
    pub limit: Option<i32>,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_account_status_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetAccountStatusV1Params {
    pub timestamp: i64,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_asset_asset_detail_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetAssetAssetDetailV1Params {
    pub timestamp: i64,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_asset_asset_dividend_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetAssetAssetDividendV1Params {
    pub timestamp: i64,
    pub asset: Option<String>,
    pub start_time: Option<i64>,
    pub end_time: Option<i64>,
    /// Default 20, max 500
    pub limit: Option<i32>,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_asset_custody_transfer_history_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetAssetCustodyTransferHistoryV1Params {
    pub email: String,
    pub start_time: i64,
    pub end_time: i64,
    pub timestamp: i64,
    /// Delegate/Undelegate
    pub r#type: Option<String>,
    pub asset: Option<String>,
    /// default 1
    pub current: Option<i32>,
    /// default 10, max 100
    pub size: Option<i32>,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_asset_dribblet_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetAssetDribbletV1Params {
    pub timestamp: i64,
    pub start_time: Option<i64>,
    pub end_time: Option<i64>,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_asset_ledger_transfer_cloud_mining_query_by_page_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetAssetLedgerTransferCloudMiningQueryByPageV1Params {
    /// inclusive, unit: ms
    pub start_time: i64,
    /// exclusive, unit: ms
    pub end_time: i64,
    /// The transaction id
    pub tran_id: Option<i64>,
    /// The unique flag
    pub client_tran_id: Option<String>,
    /// If it is blank, we will query all assets
    pub asset: Option<String>,
    /// current page, default 1, the min value is 1
    pub current: Option<i32>,
    /// page size, default 10, the max value is 100
    pub size: Option<i32>
}

/// struct for passing parameters to the method [`get_asset_trade_fee_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetAssetTradeFeeV1Params {
    pub timestamp: i64,
    pub symbol: Option<String>,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_asset_transfer_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetAssetTransferV1Params {
    pub r#type: String,
    pub timestamp: i64,
    pub start_time: Option<i64>,
    pub end_time: Option<i64>,
    /// Default 1
    pub current: Option<i32>,
    /// Default 10, Max 100
    pub size: Option<i32>,
    pub from_symbol: Option<String>,
    pub to_symbol: Option<String>,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_asset_wallet_balance_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetAssetWalletBalanceV1Params {
    pub timestamp: i64,
    /// `USDT`, `ETH`, `USDC`, `BNB`, etc. default `BTC`
    pub quote_asset: Option<String>,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_capital_config_getall_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetCapitalConfigGetallV1Params {
    pub timestamp: i64,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_capital_deposit_address_list_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetCapitalDepositAddressListV1Params {
    /// `coin` refers to the parent network address format that the address is using
    pub coin: String,
    pub timestamp: i64,
    pub network: Option<String>
}

/// struct for passing parameters to the method [`get_capital_deposit_address_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetCapitalDepositAddressV1Params {
    pub coin: String,
    pub timestamp: i64,
    pub network: Option<String>,
    pub amount: Option<String>,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_capital_deposit_hisrec_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetCapitalDepositHisrecV1Params {
    pub timestamp: i64,
    /// Default: `false`, return `sourceAddress`field when set to `true`
    pub include_source: Option<bool>,
    pub coin: Option<String>,
    /// 0(0:pending, 6:credited but cannot withdraw, 7:Wrong Deposit, 8:Waiting User confirm, 1:success, 2:rejected)
    pub status: Option<i32>,
    /// Default: 90 days from current timestamp
    pub start_time: Option<i64>,
    /// Default: present timestamp
    pub end_time: Option<i64>,
    /// Default:0
    pub offset: Option<i32>,
    /// Default:1000, Max:1000
    pub limit: Option<i32>,
    pub recv_window: Option<i64>,
    pub tx_id: Option<String>
}

/// struct for passing parameters to the method [`get_capital_withdraw_history_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetCapitalWithdrawHistoryV1Params {
    pub timestamp: i64,
    pub coin: Option<String>,
    pub withdraw_order_id: Option<String>,
    /// 0(0:Email Sent, 2:Awaiting Approval 3:Rejected 4:Processing 6:Completed)
    pub status: Option<i32>,
    pub offset: Option<i32>,
    /// Default: 1000, Max: 1000
    pub limit: Option<i32>,
    /// id list returned in the response of POST `/sapi/v1/capital/withdraw/apply`, separated by `,`
    pub id_list: Option<String>,
    /// Default: 90 days from current timestamp
    pub start_time: Option<i64>,
    /// Default: present timestamp
    pub end_time: Option<i64>,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_localentity_deposit_history_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetLocalentityDepositHistoryV1Params {
    pub timestamp: i64,
    /// Comma(,) separated list of travel rule record Ids.
    pub tr_id: Option<String>,
    /// Comma(,) separated list of transaction Ids.
    pub tx_id: Option<String>,
    /// Comma(,) separated list of wallet tran Ids.
    pub tran_id: Option<String>,
    pub network: Option<String>,
    pub coin: Option<String>,
    /// 0:Completed,1:Pending,2:Failed
    pub travel_rule_status: Option<i32>,
    /// true: Only return records that pending deposit questionnaire. false/not provided: return all records.
    pub pending_questionnaire: Option<bool>,
    /// Default: 90 days from current timestamp
    pub start_time: Option<i64>,
    /// Default: present timestamp
    pub end_time: Option<i64>,
    /// Default:0
    pub offset: Option<i32>,
    /// Default:1000, Max:1000
    pub limit: Option<i32>
}

/// struct for passing parameters to the method [`get_localentity_withdraw_history_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetLocalentityWithdrawHistoryV1Params {
    pub timestamp: i64,
    /// Comma(,) separated list of travel rule record Ids.
    pub tr_id: Option<String>,
    /// Comma(,) separated list of transaction Ids.
    pub tx_id: Option<String>,
    /// Comma(,) separated list of withdrawID defined by the client (i.e. client&#39;s internal withdrawID).
    pub withdraw_order_id: Option<String>,
    pub network: Option<String>,
    pub coin: Option<String>,
    /// 0:Completed,1:Pending,2:Failed
    pub travel_rule_status: Option<i32>,
    /// Default: 0
    pub offset: Option<i32>,
    /// Default: 1000, Max: 1000
    pub limit: Option<i32>,
    /// Default: 90 days from current timestamp
    pub start_time: Option<i64>,
    /// Default: present timestamp
    pub end_time: Option<i64>,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_localentity_withdraw_history_v2`]
#[derive(Clone, Debug, Default)]
pub struct GetLocalentityWithdrawHistoryV2Params {
    pub timestamp: i64,
    /// Comma(,) separated list of travel rule record Ids.
    pub tr_id: Option<String>,
    /// Comma(,) separated list of transaction Ids.
    pub tx_id: Option<String>,
    /// Withdraw ID defined by the client (i.e. client&#39;s internal withdrawID).
    pub withdraw_order_id: Option<String>,
    pub network: Option<String>,
    pub coin: Option<String>,
    /// 0:Completed,1:Pending,2:Failed
    pub travel_rule_status: Option<i32>,
    /// Default: 0
    pub offset: Option<i32>,
    /// Default: 1000, Max: 1000
    pub limit: Option<i32>,
    /// Default: 90 days from current timestamp
    pub start_time: Option<i64>,
    /// Default: present timestamp
    pub end_time: Option<i64>,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_spot_delist_schedule_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetSpotDelistScheduleV1Params {
    pub timestamp: i64,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`update_localentity_broker_deposit_provide_info_v1`]
#[derive(Clone, Debug, Default)]
pub struct UpdateLocalentityBrokerDepositProvideInfoV1Params {
    pub beneficiary_pii: String,
    pub deposit_id: String,
    pub questionnaire: String,
    pub signature: String,
    pub sub_account_id: String,
    pub timestamp: i64,
    pub address: Option<String>,
    pub address_tag: Option<String>,
    pub amount: Option<String>,
    pub coin: Option<String>,
    pub network: Option<String>
}

/// struct for passing parameters to the method [`update_localentity_deposit_provide_info_v1`]
#[derive(Clone, Debug, Default)]
pub struct UpdateLocalentityDepositProvideInfoV1Params {
    pub questionnaire: String,
    pub timestamp: i64,
    pub tran_id: i64
}


/// struct for typed errors of method [`create_account_disable_fast_withdraw_switch_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateAccountDisableFastWithdrawSwitchV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_account_enable_fast_withdraw_switch_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateAccountEnableFastWithdrawSwitchV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_asset_dust_btc_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateAssetDustBtcV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_asset_dust_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateAssetDustV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_asset_get_funding_asset_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateAssetGetFundingAssetV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_asset_get_user_asset_v3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateAssetGetUserAssetV3Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_asset_transfer_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateAssetTransferV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_bnb_burn_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateBnbBurnV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_capital_deposit_credit_apply_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateCapitalDepositCreditApplyV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_capital_withdraw_apply_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateCapitalWithdrawApplyV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_localentity_broker_withdraw_apply_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateLocalentityBrokerWithdrawApplyV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_localentity_withdraw_apply_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateLocalentityWithdrawApplyV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_account_api_restrictions_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAccountApiRestrictionsV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_account_api_trading_status_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAccountApiTradingStatusV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_account_info_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAccountInfoV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_account_snapshot_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAccountSnapshotV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_account_status_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAccountStatusV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_asset_asset_detail_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAssetAssetDetailV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_asset_asset_dividend_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAssetAssetDividendV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_asset_custody_transfer_history_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAssetCustodyTransferHistoryV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_asset_dribblet_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAssetDribbletV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_asset_ledger_transfer_cloud_mining_query_by_page_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAssetLedgerTransferCloudMiningQueryByPageV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_asset_trade_fee_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAssetTradeFeeV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_asset_transfer_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAssetTransferV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_asset_wallet_balance_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAssetWalletBalanceV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_capital_config_getall_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetCapitalConfigGetallV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_capital_deposit_address_list_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetCapitalDepositAddressListV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_capital_deposit_address_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetCapitalDepositAddressV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_capital_deposit_hisrec_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetCapitalDepositHisrecV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_capital_withdraw_address_list_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetCapitalWithdrawAddressListV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_capital_withdraw_history_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetCapitalWithdrawHistoryV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_localentity_deposit_history_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetLocalentityDepositHistoryV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_localentity_vasp_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetLocalentityVaspV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_localentity_withdraw_history_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetLocalentityWithdrawHistoryV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_localentity_withdraw_history_v2`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetLocalentityWithdrawHistoryV2Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_spot_delist_schedule_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSpotDelistScheduleV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_spot_open_symbol_list_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSpotOpenSymbolListV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_system_status_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSystemStatusV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_localentity_broker_deposit_provide_info_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateLocalentityBrokerDepositProvideInfoV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_localentity_deposit_provide_info_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateLocalentityDepositProvideInfoV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}


pub async fn create_account_disable_fast_withdraw_switch_v1(configuration: &configuration::Configuration, params: CreateAccountDisableFastWithdrawSwitchV1Params) -> Result<serde_json::Value, Error<CreateAccountDisableFastWithdrawSwitchV1Error>> {

    let uri_str = format!("{}/sapi/v1/account/disableFastWithdrawSwitch", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateAccountDisableFastWithdrawSwitchV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Enable Fast Withdraw Switch (USER_DATA)
pub async fn create_account_enable_fast_withdraw_switch_v1(configuration: &configuration::Configuration, params: CreateAccountEnableFastWithdrawSwitchV1Params) -> Result<serde_json::Value, Error<CreateAccountEnableFastWithdrawSwitchV1Error>> {

    let uri_str = format!("{}/sapi/v1/account/enableFastWithdrawSwitch", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateAccountEnableFastWithdrawSwitchV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get Assets That Can Be Converted Into BNB
pub async fn create_asset_dust_btc_v1(configuration: &configuration::Configuration, params: CreateAssetDustBtcV1Params) -> Result<models::CreateAssetDustBtcV1Resp, Error<CreateAssetDustBtcV1Error>> {

    let uri_str = format!("{}/sapi/v1/asset/dust-btc", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    if let Some(param_value) = params.account_type {
        multipart_form_params.insert("accountType", param_value.to_string());
    }
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CreateAssetDustBtcV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CreateAssetDustBtcV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateAssetDustBtcV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Convert dust assets to BNB.
pub async fn create_asset_dust_v1(configuration: &configuration::Configuration, params: CreateAssetDustV1Params) -> Result<models::CreateAssetDustV1Resp, Error<CreateAssetDustV1Error>> {

    let uri_str = format!("{}/sapi/v1/asset/dust", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    if let Some(param_value) = params.account_type {
        multipart_form_params.insert("accountType", param_value.to_string());
    }
    multipart_form_params.insert("asset", params.asset.into_iter().map(|p| serde_json::to_string(&p).unwrap_or_default()).collect::<Vec<String>>().join(",").to_string());
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CreateAssetDustV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CreateAssetDustV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateAssetDustV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Query Funding Wallet
pub async fn create_asset_get_funding_asset_v1(configuration: &configuration::Configuration, params: CreateAssetGetFundingAssetV1Params) -> Result<Vec<models::CreateAssetGetFundingAssetV1RespItem>, Error<CreateAssetGetFundingAssetV1Error>> {

    let uri_str = format!("{}/sapi/v1/asset/get-funding-asset", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    if let Some(param_value) = params.asset {
        multipart_form_params.insert("asset", param_value.to_string());
    }
    if let Some(param_value) = params.need_btc_valuation {
        multipart_form_params.insert("needBtcValuation", param_value.to_string());
    }
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::CreateAssetGetFundingAssetV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::CreateAssetGetFundingAssetV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateAssetGetFundingAssetV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get user assets, just for positive data.
pub async fn create_asset_get_user_asset_v3(configuration: &configuration::Configuration, params: CreateAssetGetUserAssetV3Params) -> Result<Vec<models::CreateAssetGetUserAssetV3RespItem>, Error<CreateAssetGetUserAssetV3Error>> {

    let uri_str = format!("{}/sapi/v3/asset/getUserAsset", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    if let Some(param_value) = params.asset {
        multipart_form_params.insert("asset", param_value.to_string());
    }
    if let Some(param_value) = params.need_btc_valuation {
        multipart_form_params.insert("needBtcValuation", param_value.to_string());
    }
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::CreateAssetGetUserAssetV3RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::CreateAssetGetUserAssetV3RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateAssetGetUserAssetV3Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// user universal transfer
pub async fn create_asset_transfer_v1(configuration: &configuration::Configuration, params: CreateAssetTransferV1Params) -> Result<models::CreateAssetTransferV1Resp, Error<CreateAssetTransferV1Error>> {

    let uri_str = format!("{}/sapi/v1/asset/transfer", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("amount", params.amount.to_string());
    multipart_form_params.insert("asset", params.asset.to_string());
    if let Some(param_value) = params.from_symbol {
        multipart_form_params.insert("fromSymbol", param_value.to_string());
    }
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    if let Some(param_value) = params.to_symbol {
        multipart_form_params.insert("toSymbol", param_value.to_string());
    }
    multipart_form_params.insert("type", params.r#type.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CreateAssetTransferV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CreateAssetTransferV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateAssetTransferV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Toggle BNB Burn On Spot Trade And Margin Interest
pub async fn create_bnb_burn_v1(configuration: &configuration::Configuration, params: CreateBnbBurnV1Params) -> Result<models::CreateBnbBurnV1Resp, Error<CreateBnbBurnV1Error>> {

    let uri_str = format!("{}/sapi/v1/bnbBurn", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    if let Some(param_value) = params.interest_bnb_burn {
        multipart_form_params.insert("interestBNBBurn", param_value.to_string());
    }
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    if let Some(param_value) = params.spot_bnb_burn {
        multipart_form_params.insert("spotBNBBurn", param_value.to_string());
    }
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CreateBnbBurnV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CreateBnbBurnV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateBnbBurnV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Apply deposit credit for expired address (One click arrival)
pub async fn create_capital_deposit_credit_apply_v1(configuration: &configuration::Configuration, params: CreateCapitalDepositCreditApplyV1Params) -> Result<models::CreateCapitalDepositCreditApplyV1Resp, Error<CreateCapitalDepositCreditApplyV1Error>> {

    let uri_str = format!("{}/sapi/v1/capital/deposit/credit-apply", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    if let Some(param_value) = params.deposit_id {
        multipart_form_params.insert("depositId", param_value.to_string());
    }
    if let Some(param_value) = params.sub_account_id {
        multipart_form_params.insert("subAccountId", param_value.to_string());
    }
    if let Some(param_value) = params.sub_user_id {
        multipart_form_params.insert("subUserId", param_value.to_string());
    }
    if let Some(param_value) = params.tx_id {
        multipart_form_params.insert("txId", param_value.to_string());
    }
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CreateCapitalDepositCreditApplyV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CreateCapitalDepositCreditApplyV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateCapitalDepositCreditApplyV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Submit a withdraw request.
pub async fn create_capital_withdraw_apply_v1(configuration: &configuration::Configuration, params: CreateCapitalWithdrawApplyV1Params) -> Result<models::CreateCapitalWithdrawApplyV1Resp, Error<CreateCapitalWithdrawApplyV1Error>> {

    let uri_str = format!("{}/sapi/v1/capital/withdraw/apply", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("address", params.address.to_string());
    if let Some(param_value) = params.address_tag {
        multipart_form_params.insert("addressTag", param_value.to_string());
    }
    multipart_form_params.insert("amount", params.amount.to_string());
    multipart_form_params.insert("coin", params.coin.to_string());
    if let Some(param_value) = params.name {
        multipart_form_params.insert("name", param_value.to_string());
    }
    if let Some(param_value) = params.network {
        multipart_form_params.insert("network", param_value.to_string());
    }
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    if let Some(param_value) = params.transaction_fee_flag {
        multipart_form_params.insert("transactionFeeFlag", param_value.to_string());
    }
    if let Some(param_value) = params.wallet_type {
        multipart_form_params.insert("walletType", param_value.to_string());
    }
    if let Some(param_value) = params.withdraw_order_id {
        multipart_form_params.insert("withdrawOrderId", param_value.to_string());
    }
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CreateCapitalWithdrawApplyV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CreateCapitalWithdrawApplyV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateCapitalWithdrawApplyV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Submit a withdrawal request for brokers of local entities that required travel rule.
pub async fn create_localentity_broker_withdraw_apply_v1(configuration: &configuration::Configuration, params: CreateLocalentityBrokerWithdrawApplyV1Params) -> Result<models::CreateLocalentityBrokerWithdrawApplyV1Resp, Error<CreateLocalentityBrokerWithdrawApplyV1Error>> {

    let uri_str = format!("{}/sapi/v1/localentity/broker/withdraw/apply", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("address", params.address.to_string());
    if let Some(param_value) = params.address_name {
        multipart_form_params.insert("addressName", param_value.to_string());
    }
    if let Some(param_value) = params.address_tag {
        multipart_form_params.insert("addressTag", param_value.to_string());
    }
    multipart_form_params.insert("amount", params.amount.to_string());
    multipart_form_params.insert("coin", params.coin.to_string());
    if let Some(param_value) = params.network {
        multipart_form_params.insert("network", param_value.to_string());
    }
    multipart_form_params.insert("originatorPii", params.originator_pii.to_string());
    multipart_form_params.insert("questionnaire", params.questionnaire.to_string());
    multipart_form_params.insert("signature", params.signature.to_string());
    multipart_form_params.insert("subAccountId", params.sub_account_id.to_string());
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    if let Some(param_value) = params.transaction_fee_flag {
        multipart_form_params.insert("transactionFeeFlag", param_value.to_string());
    }
    if let Some(param_value) = params.wallet_type {
        multipart_form_params.insert("walletType", param_value.to_string());
    }
    multipart_form_params.insert("withdrawOrderId", params.withdraw_order_id.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CreateLocalentityBrokerWithdrawApplyV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CreateLocalentityBrokerWithdrawApplyV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateLocalentityBrokerWithdrawApplyV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Submit a withdrawal request for local entities that required travel rule.
pub async fn create_localentity_withdraw_apply_v1(configuration: &configuration::Configuration, params: CreateLocalentityWithdrawApplyV1Params) -> Result<models::CreateLocalentityWithdrawApplyV1Resp, Error<CreateLocalentityWithdrawApplyV1Error>> {

    let uri_str = format!("{}/sapi/v1/localentity/withdraw/apply", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("address", params.address.to_string());
    if let Some(param_value) = params.address_tag {
        multipart_form_params.insert("addressTag", param_value.to_string());
    }
    multipart_form_params.insert("amount", params.amount.to_string());
    multipart_form_params.insert("coin", params.coin.to_string());
    if let Some(param_value) = params.name {
        multipart_form_params.insert("name", param_value.to_string());
    }
    if let Some(param_value) = params.network {
        multipart_form_params.insert("network", param_value.to_string());
    }
    multipart_form_params.insert("questionnaire", params.questionnaire.to_string());
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    if let Some(param_value) = params.transaction_fee_flag {
        multipart_form_params.insert("transactionFeeFlag", param_value.to_string());
    }
    if let Some(param_value) = params.wallet_type {
        multipart_form_params.insert("walletType", param_value.to_string());
    }
    if let Some(param_value) = params.withdraw_order_id {
        multipart_form_params.insert("withdrawOrderId", param_value.to_string());
    }
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CreateLocalentityWithdrawApplyV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CreateLocalentityWithdrawApplyV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateLocalentityWithdrawApplyV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get API Key Permission
pub async fn get_account_api_restrictions_v1(configuration: &configuration::Configuration, params: GetAccountApiRestrictionsV1Params) -> Result<models::GetAccountApiRestrictionsV1Resp, Error<GetAccountApiRestrictionsV1Error>> {

    let uri_str = format!("{}/sapi/v1/account/apiRestrictions", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetAccountApiRestrictionsV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetAccountApiRestrictionsV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAccountApiRestrictionsV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fetch account api trading status detail.
pub async fn get_account_api_trading_status_v1(configuration: &configuration::Configuration, params: GetAccountApiTradingStatusV1Params) -> Result<models::GetAccountApiTradingStatusV1Resp, Error<GetAccountApiTradingStatusV1Error>> {

    let uri_str = format!("{}/sapi/v1/account/apiTradingStatus", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetAccountApiTradingStatusV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetAccountApiTradingStatusV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAccountApiTradingStatusV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fetch account info detail.
pub async fn get_account_info_v1(configuration: &configuration::Configuration, params: GetAccountInfoV1Params) -> Result<models::GetAccountInfoV1Resp, Error<GetAccountInfoV1Error>> {

    let uri_str = format!("{}/sapi/v1/account/info", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetAccountInfoV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetAccountInfoV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAccountInfoV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Daily account snapshot
pub async fn get_account_snapshot_v1(configuration: &configuration::Configuration, params: GetAccountSnapshotV1Params) -> Result<models::GetAccountSnapshotV1Resp, Error<GetAccountSnapshotV1Error>> {

    let uri_str = format!("{}/sapi/v1/accountSnapshot", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("type".to_string(), params.r#type.to_string()));
    if let Some(ref param_value) = params.start_time {
        query_params.push(("startTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.end_time {
        query_params.push(("endTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.limit {
        query_params.push(("limit".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetAccountSnapshotV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetAccountSnapshotV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAccountSnapshotV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fetch account status detail.
pub async fn get_account_status_v1(configuration: &configuration::Configuration, params: GetAccountStatusV1Params) -> Result<models::GetAccountStatusV1Resp, Error<GetAccountStatusV1Error>> {

    let uri_str = format!("{}/sapi/v1/account/status", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetAccountStatusV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetAccountStatusV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAccountStatusV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fetch details of assets supported on Binance.
pub async fn get_asset_asset_detail_v1(configuration: &configuration::Configuration, params: GetAssetAssetDetailV1Params) -> Result<std::collections::HashMap<String, models::WalletGetAssetAssetDetailV1RespValue>, Error<GetAssetAssetDetailV1Error>> {

    let uri_str = format!("{}/sapi/v1/asset/assetDetail", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `std::collections::HashMap&lt;String, models::WalletGetAssetAssetDetailV1RespValue&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `std::collections::HashMap&lt;String, models::WalletGetAssetAssetDetailV1RespValue&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAssetAssetDetailV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Query asset dividend record.
pub async fn get_asset_asset_dividend_v1(configuration: &configuration::Configuration, params: GetAssetAssetDividendV1Params) -> Result<models::GetAssetAssetDividendV1Resp, Error<GetAssetAssetDividendV1Error>> {

    let uri_str = format!("{}/sapi/v1/asset/assetDividend", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.asset {
        query_params.push(("asset".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.start_time {
        query_params.push(("startTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.end_time {
        query_params.push(("endTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.limit {
        query_params.push(("limit".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetAssetAssetDividendV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetAssetAssetDividendV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAssetAssetDividendV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Query User Delegation History
pub async fn get_asset_custody_transfer_history_v1(configuration: &configuration::Configuration, params: GetAssetCustodyTransferHistoryV1Params) -> Result<models::GetAssetCustodyTransferHistoryV1Resp, Error<GetAssetCustodyTransferHistoryV1Error>> {

    let uri_str = format!("{}/sapi/v1/asset/custody/transfer-history", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("email".to_string(), params.email.to_string()));
    query_params.push(("startTime".to_string(), params.start_time.to_string()));
    query_params.push(("endTime".to_string(), params.end_time.to_string()));
    if let Some(ref param_value) = params.r#type {
        query_params.push(("type".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.asset {
        query_params.push(("asset".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.current {
        query_params.push(("current".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.size {
        query_params.push(("size".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetAssetCustodyTransferHistoryV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetAssetCustodyTransferHistoryV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAssetCustodyTransferHistoryV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Dustlog
pub async fn get_asset_dribblet_v1(configuration: &configuration::Configuration, params: GetAssetDribbletV1Params) -> Result<models::GetAssetDribbletV1Resp, Error<GetAssetDribbletV1Error>> {

    let uri_str = format!("{}/sapi/v1/asset/dribblet", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.start_time {
        query_params.push(("startTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.end_time {
        query_params.push(("endTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetAssetDribbletV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetAssetDribbletV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAssetDribbletV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The query of Cloud-Mining payment and refund history
pub async fn get_asset_ledger_transfer_cloud_mining_query_by_page_v1(configuration: &configuration::Configuration, params: GetAssetLedgerTransferCloudMiningQueryByPageV1Params) -> Result<models::GetAssetLedgerTransferCloudMiningQueryByPageV1Resp, Error<GetAssetLedgerTransferCloudMiningQueryByPageV1Error>> {

    let uri_str = format!("{}/sapi/v1/asset/ledger-transfer/cloud-mining/queryByPage", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.tran_id {
        query_params.push(("tranId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.client_tran_id {
        query_params.push(("clientTranId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.asset {
        query_params.push(("asset".to_string(), param_value.to_string()));
    }
    query_params.push(("startTime".to_string(), params.start_time.to_string()));
    query_params.push(("endTime".to_string(), params.end_time.to_string()));
    if let Some(ref param_value) = params.current {
        query_params.push(("current".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.size {
        query_params.push(("size".to_string(), param_value.to_string()));
    }

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetAssetLedgerTransferCloudMiningQueryByPageV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetAssetLedgerTransferCloudMiningQueryByPageV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAssetLedgerTransferCloudMiningQueryByPageV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fetch trade fee
pub async fn get_asset_trade_fee_v1(configuration: &configuration::Configuration, params: GetAssetTradeFeeV1Params) -> Result<Vec<models::GetAssetTradeFeeV1RespItem>, Error<GetAssetTradeFeeV1Error>> {

    let uri_str = format!("{}/sapi/v1/asset/tradeFee", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.symbol {
        query_params.push(("symbol".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GetAssetTradeFeeV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GetAssetTradeFeeV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAssetTradeFeeV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Query User Universal Transfer History
pub async fn get_asset_transfer_v1(configuration: &configuration::Configuration, params: GetAssetTransferV1Params) -> Result<models::GetAssetTransferV1Resp, Error<GetAssetTransferV1Error>> {

    let uri_str = format!("{}/sapi/v1/asset/transfer", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("type".to_string(), params.r#type.to_string()));
    if let Some(ref param_value) = params.start_time {
        query_params.push(("startTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.end_time {
        query_params.push(("endTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.current {
        query_params.push(("current".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.size {
        query_params.push(("size".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.from_symbol {
        query_params.push(("fromSymbol".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.to_symbol {
        query_params.push(("toSymbol".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetAssetTransferV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetAssetTransferV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAssetTransferV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Query User Wallet Balance
pub async fn get_asset_wallet_balance_v1(configuration: &configuration::Configuration, params: GetAssetWalletBalanceV1Params) -> Result<Vec<models::GetAssetWalletBalanceV1RespItem>, Error<GetAssetWalletBalanceV1Error>> {

    let uri_str = format!("{}/sapi/v1/asset/wallet/balance", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.quote_asset {
        query_params.push(("quoteAsset".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GetAssetWalletBalanceV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GetAssetWalletBalanceV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAssetWalletBalanceV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get information of coins (available for deposit and withdraw) for user.
pub async fn get_capital_config_getall_v1(configuration: &configuration::Configuration, params: GetCapitalConfigGetallV1Params) -> Result<Vec<models::GetCapitalConfigGetallV1RespItem>, Error<GetCapitalConfigGetallV1Error>> {

    let uri_str = format!("{}/sapi/v1/capital/config/getall", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GetCapitalConfigGetallV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GetCapitalConfigGetallV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetCapitalConfigGetallV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fetch deposit address list with network.
pub async fn get_capital_deposit_address_list_v1(configuration: &configuration::Configuration, params: GetCapitalDepositAddressListV1Params) -> Result<Vec<models::GetCapitalDepositAddressListV1RespItem>, Error<GetCapitalDepositAddressListV1Error>> {

    let uri_str = format!("{}/sapi/v1/capital/deposit/address/list", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("coin".to_string(), params.coin.to_string()));
    if let Some(ref param_value) = params.network {
        query_params.push(("network".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GetCapitalDepositAddressListV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GetCapitalDepositAddressListV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetCapitalDepositAddressListV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fetch deposit address with network.
pub async fn get_capital_deposit_address_v1(configuration: &configuration::Configuration, params: GetCapitalDepositAddressV1Params) -> Result<models::GetCapitalDepositAddressV1Resp, Error<GetCapitalDepositAddressV1Error>> {

    let uri_str = format!("{}/sapi/v1/capital/deposit/address", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("coin".to_string(), params.coin.to_string()));
    if let Some(ref param_value) = params.network {
        query_params.push(("network".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.amount {
        query_params.push(("amount".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetCapitalDepositAddressV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetCapitalDepositAddressV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetCapitalDepositAddressV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fetch deposit history.
pub async fn get_capital_deposit_hisrec_v1(configuration: &configuration::Configuration, params: GetCapitalDepositHisrecV1Params) -> Result<Vec<models::GetCapitalDepositHisrecV1RespItem>, Error<GetCapitalDepositHisrecV1Error>> {

    let uri_str = format!("{}/sapi/v1/capital/deposit/hisrec", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.include_source {
        query_params.push(("includeSource".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.coin {
        query_params.push(("coin".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.status {
        query_params.push(("status".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.start_time {
        query_params.push(("startTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.end_time {
        query_params.push(("endTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.offset {
        query_params.push(("offset".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.limit {
        query_params.push(("limit".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));
    if let Some(ref param_value) = params.tx_id {
        query_params.push(("txId".to_string(), param_value.to_string()));
    }

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GetCapitalDepositHisrecV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GetCapitalDepositHisrecV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetCapitalDepositHisrecV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fetch withdraw address list
pub async fn get_capital_withdraw_address_list_v1(configuration: &configuration::Configuration) -> Result<Vec<models::GetCapitalWithdrawAddressListV1RespItem>, Error<GetCapitalWithdrawAddressListV1Error>> {

    let uri_str = format!("{}/sapi/v1/capital/withdraw/address/list", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GetCapitalWithdrawAddressListV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GetCapitalWithdrawAddressListV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetCapitalWithdrawAddressListV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fetch withdraw history.
pub async fn get_capital_withdraw_history_v1(configuration: &configuration::Configuration, params: GetCapitalWithdrawHistoryV1Params) -> Result<Vec<models::GetCapitalWithdrawHistoryV1RespItem>, Error<GetCapitalWithdrawHistoryV1Error>> {

    let uri_str = format!("{}/sapi/v1/capital/withdraw/history", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.coin {
        query_params.push(("coin".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.withdraw_order_id {
        query_params.push(("withdrawOrderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.status {
        query_params.push(("status".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.offset {
        query_params.push(("offset".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.limit {
        query_params.push(("limit".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.id_list {
        query_params.push(("idList".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.start_time {
        query_params.push(("startTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.end_time {
        query_params.push(("endTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GetCapitalWithdrawHistoryV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GetCapitalWithdrawHistoryV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetCapitalWithdrawHistoryV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fetch deposit history for local entities that required travel rule.
pub async fn get_localentity_deposit_history_v1(configuration: &configuration::Configuration, params: GetLocalentityDepositHistoryV1Params) -> Result<Vec<models::GetLocalentityDepositHistoryV1RespItem>, Error<GetLocalentityDepositHistoryV1Error>> {

    let uri_str = format!("{}/sapi/v1/localentity/deposit/history", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.tr_id {
        query_params.push(("trId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.tx_id {
        query_params.push(("txId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.tran_id {
        query_params.push(("tranId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.network {
        query_params.push(("network".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.coin {
        query_params.push(("coin".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.travel_rule_status {
        query_params.push(("travelRuleStatus".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.pending_questionnaire {
        query_params.push(("pendingQuestionnaire".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.start_time {
        query_params.push(("startTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.end_time {
        query_params.push(("endTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.offset {
        query_params.push(("offset".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.limit {
        query_params.push(("limit".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GetLocalentityDepositHistoryV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GetLocalentityDepositHistoryV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetLocalentityDepositHistoryV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fetch the onboarded VASP list for local entities that required travel rule.
pub async fn get_localentity_vasp_v1(configuration: &configuration::Configuration) -> Result<Vec<models::GetLocalentityVaspV1RespItem>, Error<GetLocalentityVaspV1Error>> {

    let uri_str = format!("{}/sapi/v1/localentity/vasp", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GetLocalentityVaspV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GetLocalentityVaspV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetLocalentityVaspV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fetch withdraw history for local entities that required travel rule.
pub async fn get_localentity_withdraw_history_v1(configuration: &configuration::Configuration, params: GetLocalentityWithdrawHistoryV1Params) -> Result<Vec<models::GetLocalentityWithdrawHistoryV1RespItem>, Error<GetLocalentityWithdrawHistoryV1Error>> {

    let uri_str = format!("{}/sapi/v1/localentity/withdraw/history", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.tr_id {
        query_params.push(("trId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.tx_id {
        query_params.push(("txId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.withdraw_order_id {
        query_params.push(("withdrawOrderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.network {
        query_params.push(("network".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.coin {
        query_params.push(("coin".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.travel_rule_status {
        query_params.push(("travelRuleStatus".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.offset {
        query_params.push(("offset".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.limit {
        query_params.push(("limit".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.start_time {
        query_params.push(("startTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.end_time {
        query_params.push(("endTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GetLocalentityWithdrawHistoryV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GetLocalentityWithdrawHistoryV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetLocalentityWithdrawHistoryV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fetch withdraw history for local entities that required travel rule.
pub async fn get_localentity_withdraw_history_v2(configuration: &configuration::Configuration, params: GetLocalentityWithdrawHistoryV2Params) -> Result<Vec<models::GetLocalentityWithdrawHistoryV2RespItem>, Error<GetLocalentityWithdrawHistoryV2Error>> {

    let uri_str = format!("{}/sapi/v2/localentity/withdraw/history", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.tr_id {
        query_params.push(("trId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.tx_id {
        query_params.push(("txId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.withdraw_order_id {
        query_params.push(("withdrawOrderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.network {
        query_params.push(("network".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.coin {
        query_params.push(("coin".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.travel_rule_status {
        query_params.push(("travelRuleStatus".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.offset {
        query_params.push(("offset".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.limit {
        query_params.push(("limit".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.start_time {
        query_params.push(("startTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.end_time {
        query_params.push(("endTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GetLocalentityWithdrawHistoryV2RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GetLocalentityWithdrawHistoryV2RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetLocalentityWithdrawHistoryV2Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get symbols delist schedule for spot
pub async fn get_spot_delist_schedule_v1(configuration: &configuration::Configuration, params: GetSpotDelistScheduleV1Params) -> Result<Vec<models::GetSpotDelistScheduleV1RespItem>, Error<GetSpotDelistScheduleV1Error>> {

    let uri_str = format!("{}/sapi/v1/spot/delist-schedule", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GetSpotDelistScheduleV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GetSpotDelistScheduleV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSpotDelistScheduleV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the list of symbols that are scheduled to be opened for trading in the market.
pub async fn get_spot_open_symbol_list_v1(configuration: &configuration::Configuration) -> Result<Vec<models::GetSpotOpenSymbolListV1RespItem>, Error<GetSpotOpenSymbolListV1Error>> {

    let uri_str = format!("{}/sapi/v1/spot/open-symbol-list", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GetSpotOpenSymbolListV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GetSpotOpenSymbolListV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSpotOpenSymbolListV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fetch system status.
pub async fn get_system_status_v1(configuration: &configuration::Configuration) -> Result<models::GetSystemStatusV1Resp, Error<GetSystemStatusV1Error>> {

    let uri_str = format!("{}/sapi/v1/system/status", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetSystemStatusV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetSystemStatusV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSystemStatusV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Submit questionnaire for brokers of local entities that require travel rule. The questionnaire is only applies to transactions from un-hosted wallets or VASPs that are not yet onboarded with GTR.
pub async fn update_localentity_broker_deposit_provide_info_v1(configuration: &configuration::Configuration, params: UpdateLocalentityBrokerDepositProvideInfoV1Params) -> Result<models::UpdateLocalentityBrokerDepositProvideInfoV1Resp, Error<UpdateLocalentityBrokerDepositProvideInfoV1Error>> {

    let uri_str = format!("{}/sapi/v1/localentity/broker/deposit/provide-info", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    if let Some(param_value) = params.address {
        multipart_form_params.insert("address", param_value.to_string());
    }
    if let Some(param_value) = params.address_tag {
        multipart_form_params.insert("addressTag", param_value.to_string());
    }
    if let Some(param_value) = params.amount {
        multipart_form_params.insert("amount", param_value.to_string());
    }
    multipart_form_params.insert("beneficiaryPii", params.beneficiary_pii.to_string());
    if let Some(param_value) = params.coin {
        multipart_form_params.insert("coin", param_value.to_string());
    }
    multipart_form_params.insert("depositId", params.deposit_id.to_string());
    if let Some(param_value) = params.network {
        multipart_form_params.insert("network", param_value.to_string());
    }
    multipart_form_params.insert("questionnaire", params.questionnaire.to_string());
    multipart_form_params.insert("signature", params.signature.to_string());
    multipart_form_params.insert("subAccountId", params.sub_account_id.to_string());
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UpdateLocalentityBrokerDepositProvideInfoV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UpdateLocalentityBrokerDepositProvideInfoV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateLocalentityBrokerDepositProvideInfoV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Submit questionnaire for local entities that require travel rule. The questionnaire is only applies to transactions from unhosted wallets or VASPs that are not yet onboarded with GTR.
pub async fn update_localentity_deposit_provide_info_v1(configuration: &configuration::Configuration, params: UpdateLocalentityDepositProvideInfoV1Params) -> Result<models::UpdateLocalentityDepositProvideInfoV1Resp, Error<UpdateLocalentityDepositProvideInfoV1Error>> {

    let uri_str = format!("{}/sapi/v1/localentity/deposit/provide-info", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("questionnaire", params.questionnaire.to_string());
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    multipart_form_params.insert("tranId", params.tran_id.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UpdateLocalentityDepositProvideInfoV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UpdateLocalentityDepositProvideInfoV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateLocalentityDepositProvideInfoV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

