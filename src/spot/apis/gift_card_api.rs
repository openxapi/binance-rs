/*
 * Binance Spot API
 *
 * OpenAPI specification for Binance exchange - Spot API
 *
 * The version of the OpenAPI document: 0.3.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::spot::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};

/// struct for passing parameters to the method [`create_giftcard_buy_code_v1`]
#[derive(Clone, Debug, Default)]
pub struct CreateGiftcardBuyCodeV1Params {
    pub base_token: String,
    pub base_token_amount: f64,
    pub face_token: String,
    pub timestamp: i64,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`create_giftcard_create_code_v1`]
#[derive(Clone, Debug, Default)]
pub struct CreateGiftcardCreateCodeV1Params {
    pub amount: f64,
    pub timestamp: i64,
    pub token: String,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`create_giftcard_redeem_code_v1`]
#[derive(Clone, Debug, Default)]
pub struct CreateGiftcardRedeemCodeV1Params {
    pub code: String,
    pub timestamp: i64,
    pub external_uid: Option<String>,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_giftcard_buy_code_token_limit_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetGiftcardBuyCodeTokenLimitV1Params {
    /// The token you want to pay, example: BUSD
    pub base_token: String,
    pub timestamp: i64,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_giftcard_cryptography_rsa_public_key_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetGiftcardCryptographyRsaPublicKeyV1Params {
    pub timestamp: i64,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_giftcard_verify_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetGiftcardVerifyV1Params {
    /// Enter the Gift Card Number
    pub reference_no: String,
    pub timestamp: i64,
    pub recv_window: Option<i64>
}


/// struct for typed errors of method [`create_giftcard_buy_code_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateGiftcardBuyCodeV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_giftcard_create_code_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateGiftcardCreateCodeV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_giftcard_redeem_code_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateGiftcardRedeemCodeV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_giftcard_buy_code_token_limit_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetGiftcardBuyCodeTokenLimitV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_giftcard_cryptography_rsa_public_key_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetGiftcardCryptographyRsaPublicKeyV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_giftcard_verify_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetGiftcardVerifyV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}


/// This API is for creating a dual-token ( stablecoin-denominated) Binance Gift Card. You may create a gift card using USDT as baseToken, that is redeemable to another designated token (faceToken). For example, you can create a fixed-value BTC gift card and pay with 100 USDT plus 1 USDT fee. This gift card can keep the value fixed at 100 USDT before redemption, and will be redeemable to BTC equivalent to 100 USDT upon redemption.   Once successfully created, the amount of baseToken (e.g. USDT) in the fixed-value gift card along with the fee would be deducted from your funding wallet.   To get started with, please make sure:  You have a Binance account You have passed KYB You have a sufﬁcient balance(Gift Card amount and fee amount) in your Binance funding wallet You need Enable Withdrawals for the API Key which requests this endpoint.
pub async fn create_giftcard_buy_code_v1(configuration: &configuration::Configuration, params: CreateGiftcardBuyCodeV1Params) -> Result<models::CreateGiftcardBuyCodeV1Resp, Error<CreateGiftcardBuyCodeV1Error>> {

    let uri_str = format!("{}/sapi/v1/giftcard/buyCode", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("baseToken", params.base_token.to_string());
    multipart_form_params.insert("baseTokenAmount", params.base_token_amount.to_string());
    multipart_form_params.insert("faceToken", params.face_token.to_string());
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CreateGiftcardBuyCodeV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CreateGiftcardBuyCodeV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateGiftcardBuyCodeV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This API is for creating a Binance Gift Card.
pub async fn create_giftcard_create_code_v1(configuration: &configuration::Configuration, params: CreateGiftcardCreateCodeV1Params) -> Result<models::CreateGiftcardCreateCodeV1Resp, Error<CreateGiftcardCreateCodeV1Error>> {

    let uri_str = format!("{}/sapi/v1/giftcard/createCode", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("amount", params.amount.to_string());
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    multipart_form_params.insert("token", params.token.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CreateGiftcardCreateCodeV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CreateGiftcardCreateCodeV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateGiftcardCreateCodeV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This API is for redeeming a Binance Gift Card Once redeemed, the coins will be deposited in your funding wallet.
pub async fn create_giftcard_redeem_code_v1(configuration: &configuration::Configuration, params: CreateGiftcardRedeemCodeV1Params) -> Result<models::CreateGiftcardRedeemCodeV1Resp, Error<CreateGiftcardRedeemCodeV1Error>> {

    let uri_str = format!("{}/sapi/v1/giftcard/redeemCode", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("code", params.code.to_string());
    if let Some(param_value) = params.external_uid {
        multipart_form_params.insert("externalUid", param_value.to_string());
    }
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CreateGiftcardRedeemCodeV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CreateGiftcardRedeemCodeV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateGiftcardRedeemCodeV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This API is to help you verify which tokens are available for you to create Stablecoin-Denominated gift cards as mentioned in section 2 and its’ limitation.
pub async fn get_giftcard_buy_code_token_limit_v1(configuration: &configuration::Configuration, params: GetGiftcardBuyCodeTokenLimitV1Params) -> Result<models::GetGiftcardBuyCodeTokenLimitV1Resp, Error<GetGiftcardBuyCodeTokenLimitV1Error>> {

    let uri_str = format!("{}/sapi/v1/giftcard/buyCode/token-limit", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("baseToken".to_string(), params.base_token.to_string()));
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetGiftcardBuyCodeTokenLimitV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetGiftcardBuyCodeTokenLimitV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetGiftcardBuyCodeTokenLimitV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This API is for fetching the RSA Public Key. This RSA Public key will be used to encrypt the card code.
pub async fn get_giftcard_cryptography_rsa_public_key_v1(configuration: &configuration::Configuration, params: GetGiftcardCryptographyRsaPublicKeyV1Params) -> Result<models::GetGiftcardCryptographyRsaPublicKeyV1Resp, Error<GetGiftcardCryptographyRsaPublicKeyV1Error>> {

    let uri_str = format!("{}/sapi/v1/giftcard/cryptography/rsa-public-key", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetGiftcardCryptographyRsaPublicKeyV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetGiftcardCryptographyRsaPublicKeyV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetGiftcardCryptographyRsaPublicKeyV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This API is for verifying whether the Binance Gift Card is valid or not by entering Gift Card Number.
pub async fn get_giftcard_verify_v1(configuration: &configuration::Configuration, params: GetGiftcardVerifyV1Params) -> Result<models::GetGiftcardVerifyV1Resp, Error<GetGiftcardVerifyV1Error>> {

    let uri_str = format!("{}/sapi/v1/giftcard/verify", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("referenceNo".to_string(), params.reference_no.to_string()));
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetGiftcardVerifyV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetGiftcardVerifyV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetGiftcardVerifyV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

