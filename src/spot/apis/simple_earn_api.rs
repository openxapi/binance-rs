/*
 * Binance Spot API
 *
 * OpenAPI specification for Binance exchange - Spot API
 *
 * The version of the OpenAPI document: 0.3.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::spot::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};

/// struct for passing parameters to the method [`create_simple_earn_flexible_redeem_v1`]
#[derive(Clone, Debug, Default)]
pub struct CreateSimpleEarnFlexibleRedeemV1Params {
    pub product_id: String,
    pub timestamp: i64,
    pub amount: Option<String>,
    pub dest_account: Option<String>,
    pub recv_window: Option<i64>,
    pub redeem_all: Option<bool>
}

/// struct for passing parameters to the method [`create_simple_earn_flexible_set_auto_subscribe_v1`]
#[derive(Clone, Debug, Default)]
pub struct CreateSimpleEarnFlexibleSetAutoSubscribeV1Params {
    pub auto_subscribe: bool,
    pub product_id: String,
    pub timestamp: i64,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`create_simple_earn_flexible_subscribe_v1`]
#[derive(Clone, Debug, Default)]
pub struct CreateSimpleEarnFlexibleSubscribeV1Params {
    pub amount: String,
    pub product_id: String,
    pub timestamp: i64,
    pub auto_subscribe: Option<bool>,
    pub recv_window: Option<i64>,
    pub source_account: Option<String>
}

/// struct for passing parameters to the method [`create_simple_earn_locked_redeem_v1`]
#[derive(Clone, Debug, Default)]
pub struct CreateSimpleEarnLockedRedeemV1Params {
    pub position_id: i32,
    pub timestamp: i64,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`create_simple_earn_locked_set_auto_subscribe_v1`]
#[derive(Clone, Debug, Default)]
pub struct CreateSimpleEarnLockedSetAutoSubscribeV1Params {
    pub auto_subscribe: bool,
    pub position_id: i32,
    pub timestamp: i64,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`create_simple_earn_locked_set_redeem_option_v1`]
#[derive(Clone, Debug, Default)]
pub struct CreateSimpleEarnLockedSetRedeemOptionV1Params {
    pub position_id: String,
    pub redeem_to: String,
    pub timestamp: i64,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`create_simple_earn_locked_subscribe_v1`]
#[derive(Clone, Debug, Default)]
pub struct CreateSimpleEarnLockedSubscribeV1Params {
    pub amount: String,
    pub project_id: String,
    pub timestamp: i64,
    pub auto_subscribe: Option<bool>,
    pub recv_window: Option<i64>,
    pub redeem_to: Option<String>,
    pub source_account: Option<String>
}

/// struct for passing parameters to the method [`get_simple_earn_account_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetSimpleEarnAccountV1Params {
    pub timestamp: i64,
    /// The value cannot be greater than `60000`
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_simple_earn_flexible_history_collateral_record_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetSimpleEarnFlexibleHistoryCollateralRecordV1Params {
    pub timestamp: i64,
    pub product_id: Option<String>,
    pub start_time: Option<i64>,
    pub end_time: Option<i64>,
    /// Currently querying page. Start from 1. Default:1
    pub current: Option<i64>,
    /// Default:10, Max:100
    pub size: Option<i64>,
    /// The value cannot be greater than 60000
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_simple_earn_flexible_history_rate_history_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetSimpleEarnFlexibleHistoryRateHistoryV1Params {
    pub product_id: String,
    pub timestamp: i64,
    /// &#34;DAY&#34;,&#34;YEAR&#34;,default&#34;DAY&#34;
    pub apr_period: Option<String>,
    pub start_time: Option<i64>,
    pub end_time: Option<i64>,
    /// Currently querying page. Start from 1. Default:1
    pub current: Option<i64>,
    /// Default:10, Max:100
    pub size: Option<i64>,
    /// The value cannot be greater than 60000
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_simple_earn_flexible_history_redemption_record_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetSimpleEarnFlexibleHistoryRedemptionRecordV1Params {
    pub product_id: Option<String>,
    pub redeem_id: Option<String>,
    pub asset: Option<String>,
    pub start_time: Option<i64>,
    pub end_time: Option<i64>,
    /// Currently querying the page. Start from 1. Default:1
    pub current: Option<i64>,
    /// Default:10, Max:100
    pub size: Option<i64>
}

/// struct for passing parameters to the method [`get_simple_earn_flexible_history_rewards_record_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetSimpleEarnFlexibleHistoryRewardsRecordV1Params {
    /// `Bonus` - Bonus tiered APR, `REALTIME` Real-time APR, `REWARDS` Historical rewards,`ALL`(set to default)
    pub r#type: String,
    pub timestamp: i64,
    pub product_id: Option<String>,
    pub asset: Option<String>,
    pub start_time: Option<i64>,
    pub end_time: Option<i64>,
    /// Currently querying the page. Start from 1. Default:1
    pub current: Option<i64>,
    /// Default:10, Max:100
    pub size: Option<i64>,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_simple_earn_flexible_history_subscription_record_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetSimpleEarnFlexibleHistorySubscriptionRecordV1Params {
    pub timestamp: i64,
    pub product_id: Option<String>,
    pub purchase_id: Option<String>,
    pub asset: Option<String>,
    pub start_time: Option<i64>,
    pub end_time: Option<i64>,
    /// Currently querying the page. Start from 1. Default:1
    pub current: Option<i64>,
    /// Default:10, Max:100
    pub size: Option<i64>,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_simple_earn_flexible_list_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetSimpleEarnFlexibleListV1Params {
    pub timestamp: i64,
    pub asset: Option<String>,
    /// Currently querying page. Start from 1. Default:1
    pub current: Option<i64>,
    /// Default:10, Max:100
    pub size: Option<i64>,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_simple_earn_flexible_personal_left_quota_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetSimpleEarnFlexiblePersonalLeftQuotaV1Params {
    pub product_id: String,
    pub timestamp: i64,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_simple_earn_flexible_position_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetSimpleEarnFlexiblePositionV1Params {
    pub timestamp: i64,
    pub asset: Option<String>,
    pub product_id: Option<String>,
    /// Currently querying the page. Start from 1. Default:1
    pub current: Option<i64>,
    /// Default:10, Max:100
    pub size: Option<i64>,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_simple_earn_flexible_subscription_preview_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetSimpleEarnFlexibleSubscriptionPreviewV1Params {
    pub product_id: String,
    pub amount: String,
    pub timestamp: i64,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_simple_earn_locked_history_redemption_record_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetSimpleEarnLockedHistoryRedemptionRecordV1Params {
    pub timestamp: i64,
    pub position_id: Option<i32>,
    pub redeem_id: Option<String>,
    pub asset: Option<String>,
    pub start_time: Option<i64>,
    pub end_time: Option<i64>,
    /// Currently querying the page. Start from 1. Default:1
    pub current: Option<i64>,
    /// Default:10, Max:100
    pub size: Option<i64>,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_simple_earn_locked_history_rewards_record_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetSimpleEarnLockedHistoryRewardsRecordV1Params {
    pub timestamp: i64,
    pub position_id: Option<i32>,
    pub asset: Option<String>,
    pub start_time: Option<i64>,
    pub end_time: Option<i64>,
    /// Currently querying the page. Start from 1, Default:1, Max: 1,000
    pub current: Option<i64>,
    /// Default:10, Max:100
    pub size: Option<i64>,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_simple_earn_locked_history_subscription_record_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetSimpleEarnLockedHistorySubscriptionRecordV1Params {
    pub timestamp: i64,
    pub purchase_id: Option<String>,
    pub asset: Option<String>,
    pub start_time: Option<i64>,
    pub end_time: Option<i64>,
    /// Currently querying the page. Start from 1. Default:1
    pub current: Option<i64>,
    /// Default:10, Max:100
    pub size: Option<i64>,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_simple_earn_locked_list_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetSimpleEarnLockedListV1Params {
    pub timestamp: i64,
    pub asset: Option<String>,
    /// Currently querying page. Start from 1. Default:1
    pub current: Option<i64>,
    /// Default:10, Max:100
    pub size: Option<i64>,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_simple_earn_locked_personal_left_quota_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetSimpleEarnLockedPersonalLeftQuotaV1Params {
    pub project_id: String,
    pub timestamp: i64,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_simple_earn_locked_position_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetSimpleEarnLockedPositionV1Params {
    pub timestamp: i64,
    pub asset: Option<String>,
    pub position_id: Option<i32>,
    pub project_id: Option<String>,
    /// Currently querying the page. Start from 1. Default:1
    pub current: Option<i64>,
    /// Default:10, Max:100
    pub size: Option<i64>,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`get_simple_earn_locked_subscription_preview_v1`]
#[derive(Clone, Debug, Default)]
pub struct GetSimpleEarnLockedSubscriptionPreviewV1Params {
    pub project_id: String,
    pub amount: String,
    pub timestamp: i64,
    /// true or false, default true.
    pub auto_subscribe: Option<bool>,
    pub recv_window: Option<i64>
}


/// struct for typed errors of method [`create_simple_earn_flexible_redeem_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSimpleEarnFlexibleRedeemV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_simple_earn_flexible_set_auto_subscribe_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSimpleEarnFlexibleSetAutoSubscribeV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_simple_earn_flexible_subscribe_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSimpleEarnFlexibleSubscribeV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_simple_earn_locked_redeem_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSimpleEarnLockedRedeemV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_simple_earn_locked_set_auto_subscribe_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSimpleEarnLockedSetAutoSubscribeV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_simple_earn_locked_set_redeem_option_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSimpleEarnLockedSetRedeemOptionV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_simple_earn_locked_subscribe_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSimpleEarnLockedSubscribeV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_simple_earn_account_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSimpleEarnAccountV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_simple_earn_flexible_history_collateral_record_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSimpleEarnFlexibleHistoryCollateralRecordV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_simple_earn_flexible_history_rate_history_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSimpleEarnFlexibleHistoryRateHistoryV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_simple_earn_flexible_history_redemption_record_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSimpleEarnFlexibleHistoryRedemptionRecordV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_simple_earn_flexible_history_rewards_record_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSimpleEarnFlexibleHistoryRewardsRecordV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_simple_earn_flexible_history_subscription_record_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSimpleEarnFlexibleHistorySubscriptionRecordV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_simple_earn_flexible_list_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSimpleEarnFlexibleListV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_simple_earn_flexible_personal_left_quota_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSimpleEarnFlexiblePersonalLeftQuotaV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_simple_earn_flexible_position_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSimpleEarnFlexiblePositionV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_simple_earn_flexible_subscription_preview_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSimpleEarnFlexibleSubscriptionPreviewV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_simple_earn_locked_history_redemption_record_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSimpleEarnLockedHistoryRedemptionRecordV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_simple_earn_locked_history_rewards_record_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSimpleEarnLockedHistoryRewardsRecordV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_simple_earn_locked_history_subscription_record_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSimpleEarnLockedHistorySubscriptionRecordV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_simple_earn_locked_list_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSimpleEarnLockedListV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_simple_earn_locked_personal_left_quota_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSimpleEarnLockedPersonalLeftQuotaV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_simple_earn_locked_position_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSimpleEarnLockedPositionV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_simple_earn_locked_subscription_preview_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSimpleEarnLockedSubscriptionPreviewV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}


/// Redeem Flexible Product
pub async fn create_simple_earn_flexible_redeem_v1(configuration: &configuration::Configuration, params: CreateSimpleEarnFlexibleRedeemV1Params) -> Result<models::CreateSimpleEarnFlexibleRedeemV1Resp, Error<CreateSimpleEarnFlexibleRedeemV1Error>> {

    let uri_str = format!("{}/sapi/v1/simple-earn/flexible/redeem", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    if let Some(param_value) = params.amount {
        multipart_form_params.insert("amount", param_value.to_string());
    }
    if let Some(param_value) = params.dest_account {
        multipart_form_params.insert("destAccount", param_value.to_string());
    }
    multipart_form_params.insert("productId", params.product_id.to_string());
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    if let Some(param_value) = params.redeem_all {
        multipart_form_params.insert("redeemAll", param_value.to_string());
    }
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CreateSimpleEarnFlexibleRedeemV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CreateSimpleEarnFlexibleRedeemV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateSimpleEarnFlexibleRedeemV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Set Flexible Auto Subscribe
pub async fn create_simple_earn_flexible_set_auto_subscribe_v1(configuration: &configuration::Configuration, params: CreateSimpleEarnFlexibleSetAutoSubscribeV1Params) -> Result<models::CreateSimpleEarnFlexibleSetAutoSubscribeV1Resp, Error<CreateSimpleEarnFlexibleSetAutoSubscribeV1Error>> {

    let uri_str = format!("{}/sapi/v1/simple-earn/flexible/setAutoSubscribe", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("autoSubscribe", params.auto_subscribe.to_string());
    multipart_form_params.insert("productId", params.product_id.to_string());
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CreateSimpleEarnFlexibleSetAutoSubscribeV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CreateSimpleEarnFlexibleSetAutoSubscribeV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateSimpleEarnFlexibleSetAutoSubscribeV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Subscribe Flexible Product
pub async fn create_simple_earn_flexible_subscribe_v1(configuration: &configuration::Configuration, params: CreateSimpleEarnFlexibleSubscribeV1Params) -> Result<models::CreateSimpleEarnFlexibleSubscribeV1Resp, Error<CreateSimpleEarnFlexibleSubscribeV1Error>> {

    let uri_str = format!("{}/sapi/v1/simple-earn/flexible/subscribe", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("amount", params.amount.to_string());
    if let Some(param_value) = params.auto_subscribe {
        multipart_form_params.insert("autoSubscribe", param_value.to_string());
    }
    multipart_form_params.insert("productId", params.product_id.to_string());
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    if let Some(param_value) = params.source_account {
        multipart_form_params.insert("sourceAccount", param_value.to_string());
    }
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CreateSimpleEarnFlexibleSubscribeV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CreateSimpleEarnFlexibleSubscribeV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateSimpleEarnFlexibleSubscribeV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Redeem Locked Product
pub async fn create_simple_earn_locked_redeem_v1(configuration: &configuration::Configuration, params: CreateSimpleEarnLockedRedeemV1Params) -> Result<models::CreateSimpleEarnLockedRedeemV1Resp, Error<CreateSimpleEarnLockedRedeemV1Error>> {

    let uri_str = format!("{}/sapi/v1/simple-earn/locked/redeem", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("positionId", params.position_id.to_string());
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CreateSimpleEarnLockedRedeemV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CreateSimpleEarnLockedRedeemV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateSimpleEarnLockedRedeemV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Set locked auto subscribe
pub async fn create_simple_earn_locked_set_auto_subscribe_v1(configuration: &configuration::Configuration, params: CreateSimpleEarnLockedSetAutoSubscribeV1Params) -> Result<models::CreateSimpleEarnLockedSetAutoSubscribeV1Resp, Error<CreateSimpleEarnLockedSetAutoSubscribeV1Error>> {

    let uri_str = format!("{}/sapi/v1/simple-earn/locked/setAutoSubscribe", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("autoSubscribe", params.auto_subscribe.to_string());
    multipart_form_params.insert("positionId", params.position_id.to_string());
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CreateSimpleEarnLockedSetAutoSubscribeV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CreateSimpleEarnLockedSetAutoSubscribeV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateSimpleEarnLockedSetAutoSubscribeV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Set redeem option for Locked product
pub async fn create_simple_earn_locked_set_redeem_option_v1(configuration: &configuration::Configuration, params: CreateSimpleEarnLockedSetRedeemOptionV1Params) -> Result<models::CreateSimpleEarnLockedSetRedeemOptionV1Resp, Error<CreateSimpleEarnLockedSetRedeemOptionV1Error>> {

    let uri_str = format!("{}/sapi/v1/simple-earn/locked/setRedeemOption", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("positionId", params.position_id.to_string());
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    multipart_form_params.insert("redeemTo", params.redeem_to.to_string());
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CreateSimpleEarnLockedSetRedeemOptionV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CreateSimpleEarnLockedSetRedeemOptionV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateSimpleEarnLockedSetRedeemOptionV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Subscribe Locked Product
pub async fn create_simple_earn_locked_subscribe_v1(configuration: &configuration::Configuration, params: CreateSimpleEarnLockedSubscribeV1Params) -> Result<models::CreateSimpleEarnLockedSubscribeV1Resp, Error<CreateSimpleEarnLockedSubscribeV1Error>> {

    let uri_str = format!("{}/sapi/v1/simple-earn/locked/subscribe", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("amount", params.amount.to_string());
    if let Some(param_value) = params.auto_subscribe {
        multipart_form_params.insert("autoSubscribe", param_value.to_string());
    }
    multipart_form_params.insert("projectId", params.project_id.to_string());
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    if let Some(param_value) = params.redeem_to {
        multipart_form_params.insert("redeemTo", param_value.to_string());
    }
    if let Some(param_value) = params.source_account {
        multipart_form_params.insert("sourceAccount", param_value.to_string());
    }
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CreateSimpleEarnLockedSubscribeV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CreateSimpleEarnLockedSubscribeV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateSimpleEarnLockedSubscribeV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Simple Account query
pub async fn get_simple_earn_account_v1(configuration: &configuration::Configuration, params: GetSimpleEarnAccountV1Params) -> Result<models::GetSimpleEarnAccountV1Resp, Error<GetSimpleEarnAccountV1Error>> {

    let uri_str = format!("{}/sapi/v1/simple-earn/account", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetSimpleEarnAccountV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetSimpleEarnAccountV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSimpleEarnAccountV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get Collateral Record
pub async fn get_simple_earn_flexible_history_collateral_record_v1(configuration: &configuration::Configuration, params: GetSimpleEarnFlexibleHistoryCollateralRecordV1Params) -> Result<models::GetSimpleEarnFlexibleHistoryCollateralRecordV1Resp, Error<GetSimpleEarnFlexibleHistoryCollateralRecordV1Error>> {

    let uri_str = format!("{}/sapi/v1/simple-earn/flexible/history/collateralRecord", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.product_id {
        query_params.push(("productId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.start_time {
        query_params.push(("startTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.end_time {
        query_params.push(("endTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.current {
        query_params.push(("current".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.size {
        query_params.push(("size".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetSimpleEarnFlexibleHistoryCollateralRecordV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetSimpleEarnFlexibleHistoryCollateralRecordV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSimpleEarnFlexibleHistoryCollateralRecordV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get Rate History
pub async fn get_simple_earn_flexible_history_rate_history_v1(configuration: &configuration::Configuration, params: GetSimpleEarnFlexibleHistoryRateHistoryV1Params) -> Result<models::GetSimpleEarnFlexibleHistoryRateHistoryV1Resp, Error<GetSimpleEarnFlexibleHistoryRateHistoryV1Error>> {

    let uri_str = format!("{}/sapi/v1/simple-earn/flexible/history/rateHistory", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("productId".to_string(), params.product_id.to_string()));
    if let Some(ref param_value) = params.apr_period {
        query_params.push(("aprPeriod".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.start_time {
        query_params.push(("startTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.end_time {
        query_params.push(("endTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.current {
        query_params.push(("current".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.size {
        query_params.push(("size".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetSimpleEarnFlexibleHistoryRateHistoryV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetSimpleEarnFlexibleHistoryRateHistoryV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSimpleEarnFlexibleHistoryRateHistoryV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get Flexible Redemption Record
pub async fn get_simple_earn_flexible_history_redemption_record_v1(configuration: &configuration::Configuration, params: GetSimpleEarnFlexibleHistoryRedemptionRecordV1Params) -> Result<models::GetSimpleEarnFlexibleHistoryRedemptionRecordV1Resp, Error<GetSimpleEarnFlexibleHistoryRedemptionRecordV1Error>> {

    let uri_str = format!("{}/sapi/v1/simple-earn/flexible/history/redemptionRecord", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.product_id {
        query_params.push(("productId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.redeem_id {
        query_params.push(("redeemId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.asset {
        query_params.push(("asset".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.start_time {
        query_params.push(("startTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.end_time {
        query_params.push(("endTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.current {
        query_params.push(("current".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.size {
        query_params.push(("size".to_string(), param_value.to_string()));
    }

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetSimpleEarnFlexibleHistoryRedemptionRecordV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetSimpleEarnFlexibleHistoryRedemptionRecordV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSimpleEarnFlexibleHistoryRedemptionRecordV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get Flexible Rewards History
pub async fn get_simple_earn_flexible_history_rewards_record_v1(configuration: &configuration::Configuration, params: GetSimpleEarnFlexibleHistoryRewardsRecordV1Params) -> Result<models::GetSimpleEarnFlexibleHistoryRewardsRecordV1Resp, Error<GetSimpleEarnFlexibleHistoryRewardsRecordV1Error>> {

    let uri_str = format!("{}/sapi/v1/simple-earn/flexible/history/rewardsRecord", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.product_id {
        query_params.push(("productId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.asset {
        query_params.push(("asset".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.start_time {
        query_params.push(("startTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.end_time {
        query_params.push(("endTime".to_string(), param_value.to_string()));
    }
    query_params.push(("type".to_string(), params.r#type.to_string()));
    if let Some(ref param_value) = params.current {
        query_params.push(("current".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.size {
        query_params.push(("size".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetSimpleEarnFlexibleHistoryRewardsRecordV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetSimpleEarnFlexibleHistoryRewardsRecordV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSimpleEarnFlexibleHistoryRewardsRecordV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get Flexible Subscription Record
pub async fn get_simple_earn_flexible_history_subscription_record_v1(configuration: &configuration::Configuration, params: GetSimpleEarnFlexibleHistorySubscriptionRecordV1Params) -> Result<models::GetSimpleEarnFlexibleHistorySubscriptionRecordV1Resp, Error<GetSimpleEarnFlexibleHistorySubscriptionRecordV1Error>> {

    let uri_str = format!("{}/sapi/v1/simple-earn/flexible/history/subscriptionRecord", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.product_id {
        query_params.push(("productId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.purchase_id {
        query_params.push(("purchaseId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.asset {
        query_params.push(("asset".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.start_time {
        query_params.push(("startTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.end_time {
        query_params.push(("endTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.current {
        query_params.push(("current".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.size {
        query_params.push(("size".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetSimpleEarnFlexibleHistorySubscriptionRecordV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetSimpleEarnFlexibleHistorySubscriptionRecordV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSimpleEarnFlexibleHistorySubscriptionRecordV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get available Simple Earn flexible product list
pub async fn get_simple_earn_flexible_list_v1(configuration: &configuration::Configuration, params: GetSimpleEarnFlexibleListV1Params) -> Result<models::GetSimpleEarnFlexibleListV1Resp, Error<GetSimpleEarnFlexibleListV1Error>> {

    let uri_str = format!("{}/sapi/v1/simple-earn/flexible/list", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.asset {
        query_params.push(("asset".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.current {
        query_params.push(("current".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.size {
        query_params.push(("size".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetSimpleEarnFlexibleListV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetSimpleEarnFlexibleListV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSimpleEarnFlexibleListV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get Flexible Personal Left Quota
pub async fn get_simple_earn_flexible_personal_left_quota_v1(configuration: &configuration::Configuration, params: GetSimpleEarnFlexiblePersonalLeftQuotaV1Params) -> Result<models::GetSimpleEarnFlexiblePersonalLeftQuotaV1Resp, Error<GetSimpleEarnFlexiblePersonalLeftQuotaV1Error>> {

    let uri_str = format!("{}/sapi/v1/simple-earn/flexible/personalLeftQuota", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("productId".to_string(), params.product_id.to_string()));
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetSimpleEarnFlexiblePersonalLeftQuotaV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetSimpleEarnFlexiblePersonalLeftQuotaV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSimpleEarnFlexiblePersonalLeftQuotaV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get Flexible Product Position
pub async fn get_simple_earn_flexible_position_v1(configuration: &configuration::Configuration, params: GetSimpleEarnFlexiblePositionV1Params) -> Result<models::GetSimpleEarnFlexiblePositionV1Resp, Error<GetSimpleEarnFlexiblePositionV1Error>> {

    let uri_str = format!("{}/sapi/v1/simple-earn/flexible/position", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.asset {
        query_params.push(("asset".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.product_id {
        query_params.push(("productId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.current {
        query_params.push(("current".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.size {
        query_params.push(("size".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetSimpleEarnFlexiblePositionV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetSimpleEarnFlexiblePositionV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSimpleEarnFlexiblePositionV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get Flexible Subscription Preview
pub async fn get_simple_earn_flexible_subscription_preview_v1(configuration: &configuration::Configuration, params: GetSimpleEarnFlexibleSubscriptionPreviewV1Params) -> Result<models::GetSimpleEarnFlexibleSubscriptionPreviewV1Resp, Error<GetSimpleEarnFlexibleSubscriptionPreviewV1Error>> {

    let uri_str = format!("{}/sapi/v1/simple-earn/flexible/subscriptionPreview", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("productId".to_string(), params.product_id.to_string()));
    query_params.push(("amount".to_string(), params.amount.to_string()));
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetSimpleEarnFlexibleSubscriptionPreviewV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetSimpleEarnFlexibleSubscriptionPreviewV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSimpleEarnFlexibleSubscriptionPreviewV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get Locked Redemption Record
pub async fn get_simple_earn_locked_history_redemption_record_v1(configuration: &configuration::Configuration, params: GetSimpleEarnLockedHistoryRedemptionRecordV1Params) -> Result<models::GetSimpleEarnLockedHistoryRedemptionRecordV1Resp, Error<GetSimpleEarnLockedHistoryRedemptionRecordV1Error>> {

    let uri_str = format!("{}/sapi/v1/simple-earn/locked/history/redemptionRecord", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.position_id {
        query_params.push(("positionId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.redeem_id {
        query_params.push(("redeemId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.asset {
        query_params.push(("asset".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.start_time {
        query_params.push(("startTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.end_time {
        query_params.push(("endTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.current {
        query_params.push(("current".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.size {
        query_params.push(("size".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetSimpleEarnLockedHistoryRedemptionRecordV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetSimpleEarnLockedHistoryRedemptionRecordV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSimpleEarnLockedHistoryRedemptionRecordV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get Locked Rewards History
pub async fn get_simple_earn_locked_history_rewards_record_v1(configuration: &configuration::Configuration, params: GetSimpleEarnLockedHistoryRewardsRecordV1Params) -> Result<models::GetSimpleEarnLockedHistoryRewardsRecordV1Resp, Error<GetSimpleEarnLockedHistoryRewardsRecordV1Error>> {

    let uri_str = format!("{}/sapi/v1/simple-earn/locked/history/rewardsRecord", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.position_id {
        query_params.push(("positionId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.asset {
        query_params.push(("asset".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.start_time {
        query_params.push(("startTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.end_time {
        query_params.push(("endTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.current {
        query_params.push(("current".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.size {
        query_params.push(("size".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetSimpleEarnLockedHistoryRewardsRecordV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetSimpleEarnLockedHistoryRewardsRecordV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSimpleEarnLockedHistoryRewardsRecordV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get Locked Subscription Record
pub async fn get_simple_earn_locked_history_subscription_record_v1(configuration: &configuration::Configuration, params: GetSimpleEarnLockedHistorySubscriptionRecordV1Params) -> Result<models::GetSimpleEarnLockedHistorySubscriptionRecordV1Resp, Error<GetSimpleEarnLockedHistorySubscriptionRecordV1Error>> {

    let uri_str = format!("{}/sapi/v1/simple-earn/locked/history/subscriptionRecord", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.purchase_id {
        query_params.push(("purchaseId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.asset {
        query_params.push(("asset".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.start_time {
        query_params.push(("startTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.end_time {
        query_params.push(("endTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.current {
        query_params.push(("current".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.size {
        query_params.push(("size".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetSimpleEarnLockedHistorySubscriptionRecordV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetSimpleEarnLockedHistorySubscriptionRecordV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSimpleEarnLockedHistorySubscriptionRecordV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get Simple Earn Locked Product List
pub async fn get_simple_earn_locked_list_v1(configuration: &configuration::Configuration, params: GetSimpleEarnLockedListV1Params) -> Result<models::GetSimpleEarnLockedListV1Resp, Error<GetSimpleEarnLockedListV1Error>> {

    let uri_str = format!("{}/sapi/v1/simple-earn/locked/list", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.asset {
        query_params.push(("asset".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.current {
        query_params.push(("current".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.size {
        query_params.push(("size".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetSimpleEarnLockedListV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetSimpleEarnLockedListV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSimpleEarnLockedListV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get Locked Personal Left Quota
pub async fn get_simple_earn_locked_personal_left_quota_v1(configuration: &configuration::Configuration, params: GetSimpleEarnLockedPersonalLeftQuotaV1Params) -> Result<models::GetSimpleEarnLockedPersonalLeftQuotaV1Resp, Error<GetSimpleEarnLockedPersonalLeftQuotaV1Error>> {

    let uri_str = format!("{}/sapi/v1/simple-earn/locked/personalLeftQuota", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("projectId".to_string(), params.project_id.to_string()));
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetSimpleEarnLockedPersonalLeftQuotaV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetSimpleEarnLockedPersonalLeftQuotaV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSimpleEarnLockedPersonalLeftQuotaV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get Locked Product Position
pub async fn get_simple_earn_locked_position_v1(configuration: &configuration::Configuration, params: GetSimpleEarnLockedPositionV1Params) -> Result<models::GetSimpleEarnLockedPositionV1Resp, Error<GetSimpleEarnLockedPositionV1Error>> {

    let uri_str = format!("{}/sapi/v1/simple-earn/locked/position", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.asset {
        query_params.push(("asset".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.position_id {
        query_params.push(("positionId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.project_id {
        query_params.push(("projectId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.current {
        query_params.push(("current".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.size {
        query_params.push(("size".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetSimpleEarnLockedPositionV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetSimpleEarnLockedPositionV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSimpleEarnLockedPositionV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get Locked Subscription Preview
pub async fn get_simple_earn_locked_subscription_preview_v1(configuration: &configuration::Configuration, params: GetSimpleEarnLockedSubscriptionPreviewV1Params) -> Result<Vec<models::GetSimpleEarnLockedSubscriptionPreviewV1RespItem>, Error<GetSimpleEarnLockedSubscriptionPreviewV1Error>> {

    let uri_str = format!("{}/sapi/v1/simple-earn/locked/subscriptionPreview", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("projectId".to_string(), params.project_id.to_string()));
    query_params.push(("amount".to_string(), params.amount.to_string()));
    if let Some(ref param_value) = params.auto_subscribe {
        query_params.push(("autoSubscribe".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GetSimpleEarnLockedSubscriptionPreviewV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GetSimpleEarnLockedSubscriptionPreviewV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSimpleEarnLockedSubscriptionPreviewV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

