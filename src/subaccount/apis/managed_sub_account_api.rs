/*
 * Binance Sub Account API
 *
 * OpenAPI specification for Binance exchange - Subaccount API
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::subaccount::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};

/// struct for passing parameters to the method [`subaccount_create_managed_subaccount_deposit_v1`]
#[derive(Clone, Debug, Default)]
pub struct SubaccountCreateManagedSubaccountDepositV1Params {
    pub amount: String,
    pub asset: String,
    pub timestamp: i64,
    pub to_email: String,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`subaccount_create_managed_subaccount_withdraw_v1`]
#[derive(Clone, Debug, Default)]
pub struct SubaccountCreateManagedSubaccountWithdrawV1Params {
    pub amount: String,
    pub asset: String,
    pub from_email: String,
    pub timestamp: i64,
    pub recv_window: Option<i64>,
    pub transfer_date: Option<i64>
}

/// struct for passing parameters to the method [`subaccount_get_managed_subaccount_account_snapshot_v1`]
#[derive(Clone, Debug, Default)]
pub struct SubaccountGetManagedSubaccountAccountSnapshotV1Params {
    pub email: String,
    /// &#34;SPOT&#34;, &#34;MARGIN&#34;（cross）, &#34;FUTURES&#34;（UM）
    pub r#type: String,
    pub timestamp: i64,
    pub start_time: Option<i64>,
    pub end_time: Option<i64>,
    /// min 7, max 30, default 7
    pub limit: Option<i32>,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`subaccount_get_managed_subaccount_asset_v1`]
#[derive(Clone, Debug, Default)]
pub struct SubaccountGetManagedSubaccountAssetV1Params {
    pub email: String,
    pub timestamp: i64,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`subaccount_get_managed_subaccount_deposit_address_v1`]
#[derive(Clone, Debug, Default)]
pub struct SubaccountGetManagedSubaccountDepositAddressV1Params {
    /// Sub user email
    pub email: String,
    pub coin: String,
    pub timestamp: i64,
    /// networks can be found in `GET /sapi/v1/capital/deposit/address`
    pub network: Option<String>,
    pub amount: Option<String>,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`subaccount_get_managed_subaccount_fetch_future_asset_v1`]
#[derive(Clone, Debug, Default)]
pub struct SubaccountGetManagedSubaccountFetchFutureAssetV1Params {
    /// Managed Sub Account Email
    pub email: String,
    /// No input or input &#34;USDT_FUTURE&#34; to get UM Futures account details. Input &#34;COIN_FUTURE&#34; to get CM Futures account details.
    pub account_type: Option<String>
}

/// struct for passing parameters to the method [`subaccount_get_managed_subaccount_info_v1`]
#[derive(Clone, Debug, Default)]
pub struct SubaccountGetManagedSubaccountInfoV1Params {
    pub timestamp: i64,
    /// Managed sub-account email
    pub email: Option<String>,
    /// Default value: 1
    pub page: Option<i32>,
    /// Default value: 20, Max value: 20
    pub limit: Option<i32>,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`subaccount_get_managed_subaccount_margin_asset_v1`]
#[derive(Clone, Debug, Default)]
pub struct SubaccountGetManagedSubaccountMarginAssetV1Params {
    /// Managed Sub Account Email
    pub email: String,
    /// No input or input &#34;MARGIN&#34; to get Cross Margin account details. Input &#34;ISOLATED_MARGIN&#34; to get Isolated Margin account details.
    pub account_type: Option<String>
}

/// struct for passing parameters to the method [`subaccount_get_managed_subaccount_query_trans_log_for_investor_v1`]
#[derive(Clone, Debug, Default)]
pub struct SubaccountGetManagedSubaccountQueryTransLogForInvestorV1Params {
    /// Managed Sub Account Email
    pub email: String,
    /// Start Time
    pub start_time: i64,
    /// End Time (The start time and end time interval cannot exceed half a year)
    pub end_time: i64,
    /// Page
    pub page: i32,
    /// Limit (Max: 500)
    pub limit: i32,
    /// Transfer Direction (FROM/TO)
    pub transfers: Option<String>,
    /// Transfer function account type (SPOT/MARGIN/ISOLATED_MARGIN/USDT_FUTURE/COIN_FUTURE)
    pub transfer_function_account_type: Option<String>
}

/// struct for passing parameters to the method [`subaccount_get_managed_subaccount_query_trans_log_for_trade_parent_v1`]
#[derive(Clone, Debug, Default)]
pub struct SubaccountGetManagedSubaccountQueryTransLogForTradeParentV1Params {
    /// Managed Sub Account Email
    pub email: String,
    /// Start Time
    pub start_time: i64,
    /// End Time (The start time and end time interval cannot exceed half a year)
    pub end_time: i64,
    /// Page
    pub page: i32,
    /// Limit (Max: 500)
    pub limit: i32,
    /// Transfer Direction (FROM/TO)
    pub transfers: Option<String>,
    /// Transfer function account type (SPOT/MARGIN/ISOLATED_MARGIN/USDT_FUTURE/COIN_FUTURE)
    pub transfer_function_account_type: Option<String>
}

/// struct for passing parameters to the method [`subaccount_get_managed_subaccount_query_trans_log_v1`]
#[derive(Clone, Debug, Default)]
pub struct SubaccountGetManagedSubaccountQueryTransLogV1Params {
    /// Start Time
    pub start_time: i64,
    /// End Time (The start time and end time interval cannot exceed half a year)
    pub end_time: i64,
    /// Page
    pub page: i32,
    /// Limit (Max: 500)
    pub limit: i32,
    pub timestamp: i64,
    /// Transfer Direction (FROM/TO)
    pub transfers: Option<String>,
    /// Transfer function account type (SPOT/MARGIN/ISOLATED_MARGIN/USDT_FUTURE/COIN_FUTURE)
    pub transfer_function_account_type: Option<String>,
    pub recv_window: Option<i64>
}


/// struct for typed errors of method [`subaccount_create_managed_subaccount_deposit_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SubaccountCreateManagedSubaccountDepositV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`subaccount_create_managed_subaccount_withdraw_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SubaccountCreateManagedSubaccountWithdrawV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`subaccount_get_managed_subaccount_account_snapshot_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SubaccountGetManagedSubaccountAccountSnapshotV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`subaccount_get_managed_subaccount_asset_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SubaccountGetManagedSubaccountAssetV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`subaccount_get_managed_subaccount_deposit_address_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SubaccountGetManagedSubaccountDepositAddressV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`subaccount_get_managed_subaccount_fetch_future_asset_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SubaccountGetManagedSubaccountFetchFutureAssetV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`subaccount_get_managed_subaccount_info_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SubaccountGetManagedSubaccountInfoV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`subaccount_get_managed_subaccount_margin_asset_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SubaccountGetManagedSubaccountMarginAssetV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`subaccount_get_managed_subaccount_query_trans_log_for_investor_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SubaccountGetManagedSubaccountQueryTransLogForInvestorV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`subaccount_get_managed_subaccount_query_trans_log_for_trade_parent_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SubaccountGetManagedSubaccountQueryTransLogForTradeParentV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`subaccount_get_managed_subaccount_query_trans_log_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SubaccountGetManagedSubaccountQueryTransLogV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}


/// Deposit Assets Into The Managed Sub-account
pub async fn subaccount_create_managed_subaccount_deposit_v1(configuration: &configuration::Configuration, params: SubaccountCreateManagedSubaccountDepositV1Params) -> Result<models::SubaccountCreateManagedSubaccountDepositV1Resp, Error<SubaccountCreateManagedSubaccountDepositV1Error>> {

    let uri_str = format!("{}/sapi/v1/managed-subaccount/deposit", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("amount", params.amount.to_string());
    multipart_form_params.insert("asset", params.asset.to_string());
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    multipart_form_params.insert("toEmail", params.to_email.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SubaccountCreateManagedSubaccountDepositV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SubaccountCreateManagedSubaccountDepositV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SubaccountCreateManagedSubaccountDepositV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Withdrawl Assets From The Managed Sub-account
pub async fn subaccount_create_managed_subaccount_withdraw_v1(configuration: &configuration::Configuration, params: SubaccountCreateManagedSubaccountWithdrawV1Params) -> Result<models::SubaccountCreateManagedSubaccountWithdrawV1Resp, Error<SubaccountCreateManagedSubaccountWithdrawV1Error>> {

    let uri_str = format!("{}/sapi/v1/managed-subaccount/withdraw", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("amount", params.amount.to_string());
    multipart_form_params.insert("asset", params.asset.to_string());
    multipart_form_params.insert("fromEmail", params.from_email.to_string());
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    if let Some(param_value) = params.transfer_date {
        multipart_form_params.insert("transferDate", param_value.to_string());
    }
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SubaccountCreateManagedSubaccountWithdrawV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SubaccountCreateManagedSubaccountWithdrawV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SubaccountCreateManagedSubaccountWithdrawV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Query Managed Sub-account Snapshot
pub async fn subaccount_get_managed_subaccount_account_snapshot_v1(configuration: &configuration::Configuration, params: SubaccountGetManagedSubaccountAccountSnapshotV1Params) -> Result<models::SubaccountGetManagedSubaccountAccountSnapshotV1Resp, Error<SubaccountGetManagedSubaccountAccountSnapshotV1Error>> {

    let uri_str = format!("{}/sapi/v1/managed-subaccount/accountSnapshot", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("email".to_string(), params.email.to_string()));
    query_params.push(("type".to_string(), params.r#type.to_string()));
    if let Some(ref param_value) = params.start_time {
        query_params.push(("startTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.end_time {
        query_params.push(("endTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.limit {
        query_params.push(("limit".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SubaccountGetManagedSubaccountAccountSnapshotV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SubaccountGetManagedSubaccountAccountSnapshotV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SubaccountGetManagedSubaccountAccountSnapshotV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Query Managed Sub-account Asset Details
pub async fn subaccount_get_managed_subaccount_asset_v1(configuration: &configuration::Configuration, params: SubaccountGetManagedSubaccountAssetV1Params) -> Result<Vec<models::SubaccountGetManagedSubaccountAssetV1RespItem>, Error<SubaccountGetManagedSubaccountAssetV1Error>> {

    let uri_str = format!("{}/sapi/v1/managed-subaccount/asset", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("email".to_string(), params.email.to_string()));
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::SubaccountGetManagedSubaccountAssetV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::SubaccountGetManagedSubaccountAssetV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SubaccountGetManagedSubaccountAssetV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get investor's managed sub-account deposit address.
pub async fn subaccount_get_managed_subaccount_deposit_address_v1(configuration: &configuration::Configuration, params: SubaccountGetManagedSubaccountDepositAddressV1Params) -> Result<models::SubaccountGetManagedSubaccountDepositAddressV1Resp, Error<SubaccountGetManagedSubaccountDepositAddressV1Error>> {

    let uri_str = format!("{}/sapi/v1/managed-subaccount/deposit/address", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("email".to_string(), params.email.to_string()));
    query_params.push(("coin".to_string(), params.coin.to_string()));
    if let Some(ref param_value) = params.network {
        query_params.push(("network".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.amount {
        query_params.push(("amount".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SubaccountGetManagedSubaccountDepositAddressV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SubaccountGetManagedSubaccountDepositAddressV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SubaccountGetManagedSubaccountDepositAddressV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Investor can use this api to query managed sub account futures asset details
pub async fn subaccount_get_managed_subaccount_fetch_future_asset_v1(configuration: &configuration::Configuration, params: SubaccountGetManagedSubaccountFetchFutureAssetV1Params) -> Result<models::SubaccountGetManagedSubaccountFetchFutureAssetV1Resp, Error<SubaccountGetManagedSubaccountFetchFutureAssetV1Error>> {

    let uri_str = format!("{}/sapi/v1/managed-subaccount/fetch-future-asset", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("email".to_string(), params.email.to_string()));
    if let Some(ref param_value) = params.account_type {
        query_params.push(("accountType".to_string(), param_value.to_string()));
    }

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SubaccountGetManagedSubaccountFetchFutureAssetV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SubaccountGetManagedSubaccountFetchFutureAssetV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SubaccountGetManagedSubaccountFetchFutureAssetV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get investor's managed sub-account list.
pub async fn subaccount_get_managed_subaccount_info_v1(configuration: &configuration::Configuration, params: SubaccountGetManagedSubaccountInfoV1Params) -> Result<models::SubaccountGetManagedSubaccountInfoV1Resp, Error<SubaccountGetManagedSubaccountInfoV1Error>> {

    let uri_str = format!("{}/sapi/v1/managed-subaccount/info", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.email {
        query_params.push(("email".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.page {
        query_params.push(("page".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.limit {
        query_params.push(("limit".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SubaccountGetManagedSubaccountInfoV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SubaccountGetManagedSubaccountInfoV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SubaccountGetManagedSubaccountInfoV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Investor can use this api to query managed sub account margin asset details
pub async fn subaccount_get_managed_subaccount_margin_asset_v1(configuration: &configuration::Configuration, params: SubaccountGetManagedSubaccountMarginAssetV1Params) -> Result<models::SubaccountGetManagedSubaccountMarginAssetV1Resp, Error<SubaccountGetManagedSubaccountMarginAssetV1Error>> {

    let uri_str = format!("{}/sapi/v1/managed-subaccount/marginAsset", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("email".to_string(), params.email.to_string()));
    if let Some(ref param_value) = params.account_type {
        query_params.push(("accountType".to_string(), param_value.to_string()));
    }

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SubaccountGetManagedSubaccountMarginAssetV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SubaccountGetManagedSubaccountMarginAssetV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SubaccountGetManagedSubaccountMarginAssetV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Investor can use this api to query managed sub account transfer log. This endpoint is available for investor of Managed Sub-Account. A Managed Sub-Account is an account type for investors who value flexibility in asset allocation and account application, while delegating trades to a professional trading team. Please refer to link
pub async fn subaccount_get_managed_subaccount_query_trans_log_for_investor_v1(configuration: &configuration::Configuration, params: SubaccountGetManagedSubaccountQueryTransLogForInvestorV1Params) -> Result<models::SubaccountGetManagedSubaccountQueryTransLogForInvestorV1Resp, Error<SubaccountGetManagedSubaccountQueryTransLogForInvestorV1Error>> {

    let uri_str = format!("{}/sapi/v1/managed-subaccount/queryTransLogForInvestor", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("email".to_string(), params.email.to_string()));
    query_params.push(("startTime".to_string(), params.start_time.to_string()));
    query_params.push(("endTime".to_string(), params.end_time.to_string()));
    query_params.push(("page".to_string(), params.page.to_string()));
    query_params.push(("limit".to_string(), params.limit.to_string()));
    if let Some(ref param_value) = params.transfers {
        query_params.push(("transfers".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.transfer_function_account_type {
        query_params.push(("transferFunctionAccountType".to_string(), param_value.to_string()));
    }

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SubaccountGetManagedSubaccountQueryTransLogForInvestorV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SubaccountGetManagedSubaccountQueryTransLogForInvestorV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SubaccountGetManagedSubaccountQueryTransLogForInvestorV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Trading team can use this api to query managed sub account transfer log. This endpoint is available for trading team of Managed Sub-Account. A Managed Sub-Account is an account type for investors who value flexibility in asset allocation and account application, while delegating trades to a professional trading team. Please refer to link
pub async fn subaccount_get_managed_subaccount_query_trans_log_for_trade_parent_v1(configuration: &configuration::Configuration, params: SubaccountGetManagedSubaccountQueryTransLogForTradeParentV1Params) -> Result<models::SubaccountGetManagedSubaccountQueryTransLogForTradeParentV1Resp, Error<SubaccountGetManagedSubaccountQueryTransLogForTradeParentV1Error>> {

    let uri_str = format!("{}/sapi/v1/managed-subaccount/queryTransLogForTradeParent", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("email".to_string(), params.email.to_string()));
    query_params.push(("startTime".to_string(), params.start_time.to_string()));
    query_params.push(("endTime".to_string(), params.end_time.to_string()));
    query_params.push(("page".to_string(), params.page.to_string()));
    query_params.push(("limit".to_string(), params.limit.to_string()));
    if let Some(ref param_value) = params.transfers {
        query_params.push(("transfers".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.transfer_function_account_type {
        query_params.push(("transferFunctionAccountType".to_string(), param_value.to_string()));
    }

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SubaccountGetManagedSubaccountQueryTransLogForTradeParentV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SubaccountGetManagedSubaccountQueryTransLogForTradeParentV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SubaccountGetManagedSubaccountQueryTransLogForTradeParentV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Query Managed Sub Account Transfer Log (For Trading Team Sub Account)
pub async fn subaccount_get_managed_subaccount_query_trans_log_v1(configuration: &configuration::Configuration, params: SubaccountGetManagedSubaccountQueryTransLogV1Params) -> Result<models::SubaccountGetManagedSubaccountQueryTransLogV1Resp, Error<SubaccountGetManagedSubaccountQueryTransLogV1Error>> {

    let uri_str = format!("{}/sapi/v1/managed-subaccount/query-trans-log", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("startTime".to_string(), params.start_time.to_string()));
    query_params.push(("endTime".to_string(), params.end_time.to_string()));
    query_params.push(("page".to_string(), params.page.to_string()));
    query_params.push(("limit".to_string(), params.limit.to_string()));
    if let Some(ref param_value) = params.transfers {
        query_params.push(("transfers".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.transfer_function_account_type {
        query_params.push(("transferFunctionAccountType".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SubaccountGetManagedSubaccountQueryTransLogV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SubaccountGetManagedSubaccountQueryTransLogV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SubaccountGetManagedSubaccountQueryTransLogV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

