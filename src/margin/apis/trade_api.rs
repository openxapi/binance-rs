/*
 * Binance Margin Trading API
 *
 * OpenAPI specification for Binance exchange - Margin API
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::margin::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};

/// struct for passing parameters to the method [`margin_create_margin_api_key_v1`]
#[derive(Clone, Debug, Default)]
pub struct MarginCreateMarginApiKeyV1Params {
    pub api_name: String,
    pub timestamp: i64,
    pub ip: Option<String>,
    pub permission_mode: Option<String>,
    pub public_key: Option<String>,
    pub recv_window: Option<i64>,
    pub symbol: Option<String>
}

/// struct for passing parameters to the method [`margin_create_margin_exchange_small_liability_v1`]
#[derive(Clone, Debug, Default)]
pub struct MarginCreateMarginExchangeSmallLiabilityV1Params {
    pub asset_names: Vec<String>,
    pub timestamp: i64,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`margin_create_margin_manual_liquidation_v1`]
#[derive(Clone, Debug, Default)]
pub struct MarginCreateMarginManualLiquidationV1Params {
    pub timestamp: i64,
    pub r#type: String,
    pub recv_window: Option<i64>,
    pub symbol: Option<String>
}

/// struct for passing parameters to the method [`margin_create_margin_order_oco_v1`]
#[derive(Clone, Debug, Default)]
pub struct MarginCreateMarginOrderOcoV1Params {
    pub price: String,
    pub quantity: String,
    pub side: String,
    pub stop_price: String,
    pub symbol: String,
    pub timestamp: i64,
    pub auto_repay_at_cancel: Option<bool>,
    pub is_isolated: Option<String>,
    pub limit_client_order_id: Option<String>,
    pub limit_iceberg_qty: Option<String>,
    pub list_client_order_id: Option<String>,
    pub new_order_resp_type: Option<String>,
    pub recv_window: Option<i64>,
    pub self_trade_prevention_mode: Option<String>,
    pub side_effect_type: Option<String>,
    pub stop_client_order_id: Option<String>,
    pub stop_iceberg_qty: Option<String>,
    pub stop_limit_price: Option<String>,
    pub stop_limit_time_in_force: Option<String>
}

/// struct for passing parameters to the method [`margin_create_margin_order_oto_v1`]
#[derive(Clone, Debug, Default)]
pub struct MarginCreateMarginOrderOtoV1Params {
    pub pending_quantity: String,
    pub pending_side: String,
    pub pending_type: String,
    pub symbol: String,
    pub working_iceberg_qty: String,
    pub working_price: String,
    pub working_quantity: String,
    pub working_side: String,
    pub working_type: String,
    pub auto_repay_at_cancel: Option<bool>,
    pub is_isolated: Option<String>,
    pub list_client_order_id: Option<String>,
    pub new_order_resp_type: Option<String>,
    pub pending_client_order_id: Option<String>,
    pub pending_iceberg_qty: Option<String>,
    pub pending_price: Option<String>,
    pub pending_stop_price: Option<String>,
    pub pending_time_in_force: Option<String>,
    pub pending_trailing_delta: Option<String>,
    pub self_trade_prevention_mode: Option<String>,
    pub side_effect_type: Option<String>,
    pub working_client_order_id: Option<String>,
    pub working_time_in_force: Option<String>
}

/// struct for passing parameters to the method [`margin_create_margin_order_otoco_v1`]
#[derive(Clone, Debug, Default)]
pub struct MarginCreateMarginOrderOtocoV1Params {
    pub pending_above_type: String,
    pub pending_quantity: String,
    pub pending_side: String,
    pub symbol: String,
    pub working_price: String,
    pub working_quantity: String,
    pub working_side: String,
    pub working_type: String,
    pub auto_repay_at_cancel: Option<bool>,
    pub is_isolated: Option<String>,
    pub list_client_order_id: Option<String>,
    pub new_order_resp_type: Option<String>,
    pub pending_above_client_order_id: Option<String>,
    pub pending_above_iceberg_qty: Option<String>,
    pub pending_above_price: Option<String>,
    pub pending_above_stop_price: Option<String>,
    pub pending_above_time_in_force: Option<String>,
    pub pending_above_trailing_delta: Option<String>,
    pub pending_below_client_order_id: Option<String>,
    pub pending_below_iceberg_qty: Option<String>,
    pub pending_below_price: Option<String>,
    pub pending_below_stop_price: Option<String>,
    pub pending_below_time_in_force: Option<String>,
    pub pending_below_trailing_delta: Option<String>,
    pub pending_below_type: Option<String>,
    pub self_trade_prevention_mode: Option<String>,
    pub side_effect_type: Option<String>,
    pub working_client_order_id: Option<String>,
    pub working_iceberg_qty: Option<String>,
    pub working_time_in_force: Option<String>
}

/// struct for passing parameters to the method [`margin_create_margin_order_v1`]
#[derive(Clone, Debug, Default)]
pub struct MarginCreateMarginOrderV1Params {
    pub side: String,
    pub symbol: String,
    pub timestamp: i64,
    pub r#type: String,
    pub auto_repay_at_cancel: Option<bool>,
    pub iceberg_qty: Option<String>,
    pub is_isolated: Option<String>,
    pub new_client_order_id: Option<String>,
    pub new_order_resp_type: Option<String>,
    pub price: Option<String>,
    pub quantity: Option<String>,
    pub quote_order_qty: Option<String>,
    pub recv_window: Option<i64>,
    pub self_trade_prevention_mode: Option<String>,
    pub side_effect_type: Option<String>,
    pub stop_price: Option<String>,
    pub time_in_force: Option<String>
}

/// struct for passing parameters to the method [`margin_delete_margin_api_key_v1`]
#[derive(Clone, Debug, Default)]
pub struct MarginDeleteMarginApiKeyV1Params {
    pub timestamp: i64,
    pub api_key: Option<String>,
    pub api_name: Option<String>,
    /// isolated margin pair
    pub symbol: Option<String>,
    /// The value cannot be greater than `60000`
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`margin_delete_margin_open_orders_v1`]
#[derive(Clone, Debug, Default)]
pub struct MarginDeleteMarginOpenOrdersV1Params {
    pub symbol: String,
    pub timestamp: i64,
    /// for isolated margin or not, &#34;TRUE&#34;, &#34;FALSE&#34;，default &#34;FALSE&#34;
    pub is_isolated: Option<String>,
    /// The value cannot be greater than `60000`
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`margin_delete_margin_order_list_v1`]
#[derive(Clone, Debug, Default)]
pub struct MarginDeleteMarginOrderListV1Params {
    pub symbol: String,
    pub timestamp: i64,
    /// for isolated margin or not, &#34;TRUE&#34;, &#34;FALSE&#34;，default &#34;FALSE&#34;
    pub is_isolated: Option<String>,
    /// Either `orderListId` or `listClientOrderId` must be provided
    pub order_list_id: Option<i64>,
    /// Either `orderListId` or `listClientOrderId` must be provided
    pub list_client_order_id: Option<String>,
    /// Used to uniquely identify this cancel. Automatically generated by default
    pub new_client_order_id: Option<String>,
    /// The value cannot be greater than `60000`
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`margin_delete_margin_order_v1`]
#[derive(Clone, Debug, Default)]
pub struct MarginDeleteMarginOrderV1Params {
    pub symbol: String,
    pub timestamp: i64,
    /// for isolated margin or not, &#34;TRUE&#34;, &#34;FALSE&#34;，default &#34;FALSE&#34;
    pub is_isolated: Option<String>,
    pub order_id: Option<i64>,
    pub orig_client_order_id: Option<String>,
    /// Used to uniquely identify this cancel. Automatically generated by default.
    pub new_client_order_id: Option<String>,
    /// The value cannot be greater than `60000`
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`margin_get_margin_all_order_list_v1`]
#[derive(Clone, Debug, Default)]
pub struct MarginGetMarginAllOrderListV1Params {
    pub timestamp: i64,
    /// for isolated margin or not, &#34;TRUE&#34;, &#34;FALSE&#34;，default &#34;FALSE&#34;
    pub is_isolated: Option<String>,
    /// mandatory for isolated margin, not supported for cross margin
    pub symbol: Option<String>,
    /// If supplied, neither `startTime` or `endTime` can be provided
    pub from_id: Option<i64>,
    pub start_time: Option<i64>,
    pub end_time: Option<i64>,
    /// Default Value: 500; Max Value: 1000
    pub limit: Option<i32>,
    /// The value cannot be greater than `60000`
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`margin_get_margin_all_orders_v1`]
#[derive(Clone, Debug, Default)]
pub struct MarginGetMarginAllOrdersV1Params {
    pub symbol: String,
    pub timestamp: i64,
    /// for isolated margin or not, &#34;TRUE&#34;, &#34;FALSE&#34;，default &#34;FALSE&#34;
    pub is_isolated: Option<String>,
    pub order_id: Option<i64>,
    pub start_time: Option<i64>,
    pub end_time: Option<i64>,
    /// Default 500; max 500.
    pub limit: Option<i32>,
    /// The value cannot be greater than `60000`
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`margin_get_margin_api_key_list_v1`]
#[derive(Clone, Debug, Default)]
pub struct MarginGetMarginApiKeyListV1Params {
    pub timestamp: i64,
    /// isolated margin pair
    pub symbol: Option<String>,
    /// The value cannot be greater than `60000`
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`margin_get_margin_api_key_v1`]
#[derive(Clone, Debug, Default)]
pub struct MarginGetMarginApiKeyV1Params {
    pub api_key: String,
    pub timestamp: i64,
    /// isolated margin pair
    pub symbol: Option<String>,
    /// The value cannot be greater than `60000`
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`margin_get_margin_exchange_small_liability_history_v1`]
#[derive(Clone, Debug, Default)]
pub struct MarginGetMarginExchangeSmallLiabilityHistoryV1Params {
    /// Currently querying page. Start from 1. Default:1
    pub current: i32,
    /// Default:10, Max:100
    pub size: i32,
    pub timestamp: i64,
    /// Default: 30 days from current timestamp
    pub start_time: Option<i64>,
    /// Default: present timestamp
    pub end_time: Option<i64>,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`margin_get_margin_exchange_small_liability_v1`]
#[derive(Clone, Debug, Default)]
pub struct MarginGetMarginExchangeSmallLiabilityV1Params {
    pub timestamp: i64,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`margin_get_margin_force_liquidation_rec_v1`]
#[derive(Clone, Debug, Default)]
pub struct MarginGetMarginForceLiquidationRecV1Params {
    pub timestamp: i64,
    pub start_time: Option<i64>,
    pub end_time: Option<i64>,
    pub isolated_symbol: Option<String>,
    /// Currently querying page. Start from 1. Default:1
    pub current: Option<i64>,
    /// Default:10 Max:100
    pub size: Option<i64>,
    /// The value cannot be greater than `60000`
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`margin_get_margin_my_trades_v1`]
#[derive(Clone, Debug, Default)]
pub struct MarginGetMarginMyTradesV1Params {
    pub symbol: String,
    pub timestamp: i64,
    /// for isolated margin or not, &#34;TRUE&#34;, &#34;FALSE&#34;，default &#34;FALSE&#34;
    pub is_isolated: Option<String>,
    pub order_id: Option<i64>,
    pub start_time: Option<i64>,
    pub end_time: Option<i64>,
    /// TradeId to fetch from. Default gets most recent trades.
    pub from_id: Option<i64>,
    /// Default 500; max 1000.
    pub limit: Option<i32>,
    /// The value cannot be greater than `60000`
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`margin_get_margin_open_order_list_v1`]
#[derive(Clone, Debug, Default)]
pub struct MarginGetMarginOpenOrderListV1Params {
    pub timestamp: i64,
    /// for isolated margin or not, &#34;TRUE&#34;, &#34;FALSE&#34;，default &#34;FALSE&#34;
    pub is_isolated: Option<String>,
    /// mandatory for isolated margin, not supported for cross margin
    pub symbol: Option<String>,
    /// The value cannot be greater than `60000`
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`margin_get_margin_open_orders_v1`]
#[derive(Clone, Debug, Default)]
pub struct MarginGetMarginOpenOrdersV1Params {
    pub timestamp: i64,
    pub symbol: Option<String>,
    /// for isolated margin or not, &#34;TRUE&#34;, &#34;FALSE&#34;，default &#34;FALSE&#34;
    pub is_isolated: Option<String>,
    /// The value cannot be greater than `60000`
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`margin_get_margin_order_list_v1`]
#[derive(Clone, Debug, Default)]
pub struct MarginGetMarginOrderListV1Params {
    pub timestamp: i64,
    /// for isolated margin or not, &#34;TRUE&#34;, &#34;FALSE&#34;，default &#34;FALSE&#34;
    pub is_isolated: Option<String>,
    /// mandatory for isolated margin, not supported for cross margin
    pub symbol: Option<String>,
    /// Either `orderListId` or `origClientOrderId` must be provided
    pub order_list_id: Option<i64>,
    /// Either `orderListId` or `origClientOrderId` must be provided
    pub orig_client_order_id: Option<String>,
    /// The value cannot be greater than `60000`
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`margin_get_margin_order_v1`]
#[derive(Clone, Debug, Default)]
pub struct MarginGetMarginOrderV1Params {
    pub symbol: String,
    pub timestamp: i64,
    /// for isolated margin or not, &#34;TRUE&#34;, &#34;FALSE&#34;，default &#34;FALSE&#34;
    pub is_isolated: Option<String>,
    pub order_id: Option<i64>,
    pub orig_client_order_id: Option<String>,
    /// The value cannot be greater than `60000`
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`margin_get_margin_rate_limit_order_v1`]
#[derive(Clone, Debug, Default)]
pub struct MarginGetMarginRateLimitOrderV1Params {
    pub timestamp: i64,
    /// for isolated margin or not, &#34;TRUE&#34;, &#34;FALSE&#34;，default &#34;FALSE&#34;
    pub is_isolated: Option<String>,
    /// isolated symbol, mandatory for isolated margin
    pub symbol: Option<String>,
    /// The value cannot be greater than `60000`
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`margin_update_margin_api_key_ip_v1`]
#[derive(Clone, Debug, Default)]
pub struct MarginUpdateMarginApiKeyIpV1Params {
    pub api_key: String,
    pub ip: String,
    pub timestamp: i64,
    pub recv_window: Option<i64>,
    pub symbol: Option<String>
}


/// struct for typed errors of method [`margin_create_margin_api_key_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MarginCreateMarginApiKeyV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`margin_create_margin_exchange_small_liability_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MarginCreateMarginExchangeSmallLiabilityV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`margin_create_margin_manual_liquidation_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MarginCreateMarginManualLiquidationV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`margin_create_margin_order_oco_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MarginCreateMarginOrderOcoV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`margin_create_margin_order_oto_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MarginCreateMarginOrderOtoV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`margin_create_margin_order_otoco_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MarginCreateMarginOrderOtocoV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`margin_create_margin_order_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MarginCreateMarginOrderV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`margin_delete_margin_api_key_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MarginDeleteMarginApiKeyV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`margin_delete_margin_open_orders_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MarginDeleteMarginOpenOrdersV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`margin_delete_margin_order_list_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MarginDeleteMarginOrderListV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`margin_delete_margin_order_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MarginDeleteMarginOrderV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`margin_get_margin_all_order_list_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MarginGetMarginAllOrderListV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`margin_get_margin_all_orders_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MarginGetMarginAllOrdersV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`margin_get_margin_api_key_list_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MarginGetMarginApiKeyListV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`margin_get_margin_api_key_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MarginGetMarginApiKeyV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`margin_get_margin_exchange_small_liability_history_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MarginGetMarginExchangeSmallLiabilityHistoryV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`margin_get_margin_exchange_small_liability_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MarginGetMarginExchangeSmallLiabilityV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`margin_get_margin_force_liquidation_rec_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MarginGetMarginForceLiquidationRecV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`margin_get_margin_my_trades_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MarginGetMarginMyTradesV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`margin_get_margin_open_order_list_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MarginGetMarginOpenOrderListV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`margin_get_margin_open_orders_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MarginGetMarginOpenOrdersV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`margin_get_margin_order_list_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MarginGetMarginOrderListV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`margin_get_margin_order_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MarginGetMarginOrderV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`margin_get_margin_rate_limit_order_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MarginGetMarginRateLimitOrderV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`margin_update_margin_api_key_ip_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MarginUpdateMarginApiKeyIpV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}


/// **Binance Margin offers low-latency trading through a special key, available exclusively to users with VIP level 4 or higher. **
pub async fn margin_create_margin_api_key_v1(configuration: &configuration::Configuration, params: MarginCreateMarginApiKeyV1Params) -> Result<models::MarginCreateMarginApiKeyV1Resp, Error<MarginCreateMarginApiKeyV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/apiKey", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("apiName", params.api_name.to_string());
    if let Some(param_value) = params.ip {
        multipart_form_params.insert("ip", param_value.to_string());
    }
    if let Some(param_value) = params.permission_mode {
        multipart_form_params.insert("permissionMode", param_value.to_string());
    }
    if let Some(param_value) = params.public_key {
        multipart_form_params.insert("publicKey", param_value.to_string());
    }
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    if let Some(param_value) = params.symbol {
        multipart_form_params.insert("symbol", param_value.to_string());
    }
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MarginCreateMarginApiKeyV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MarginCreateMarginApiKeyV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MarginCreateMarginApiKeyV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Small Liability Exchange
pub async fn margin_create_margin_exchange_small_liability_v1(configuration: &configuration::Configuration, params: MarginCreateMarginExchangeSmallLiabilityV1Params) -> Result<models::MarginCreateMarginExchangeSmallLiabilityV1Resp, Error<MarginCreateMarginExchangeSmallLiabilityV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/exchange-small-liability", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("assetNames", params.asset_names.into_iter().map(|p| serde_json::to_string(&p).unwrap_or_default()).collect::<Vec<String>>().join(",").to_string());
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MarginCreateMarginExchangeSmallLiabilityV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MarginCreateMarginExchangeSmallLiabilityV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MarginCreateMarginExchangeSmallLiabilityV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Margin Manual Liquidation
pub async fn margin_create_margin_manual_liquidation_v1(configuration: &configuration::Configuration, params: MarginCreateMarginManualLiquidationV1Params) -> Result<models::MarginCreateMarginManualLiquidationV1Resp, Error<MarginCreateMarginManualLiquidationV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/manual-liquidation", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    if let Some(param_value) = params.symbol {
        multipart_form_params.insert("symbol", param_value.to_string());
    }
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    multipart_form_params.insert("type", params.r#type.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MarginCreateMarginManualLiquidationV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MarginCreateMarginManualLiquidationV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MarginCreateMarginManualLiquidationV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Send in a new OCO for a margin account
pub async fn margin_create_margin_order_oco_v1(configuration: &configuration::Configuration, params: MarginCreateMarginOrderOcoV1Params) -> Result<models::MarginCreateMarginOrderOcoV1Resp, Error<MarginCreateMarginOrderOcoV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/order/oco", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    if let Some(param_value) = params.auto_repay_at_cancel {
        multipart_form_params.insert("autoRepayAtCancel", param_value.to_string());
    }
    if let Some(param_value) = params.is_isolated {
        multipart_form_params.insert("isIsolated", param_value.to_string());
    }
    if let Some(param_value) = params.limit_client_order_id {
        multipart_form_params.insert("limitClientOrderId", param_value.to_string());
    }
    if let Some(param_value) = params.limit_iceberg_qty {
        multipart_form_params.insert("limitIcebergQty", param_value.to_string());
    }
    if let Some(param_value) = params.list_client_order_id {
        multipart_form_params.insert("listClientOrderId", param_value.to_string());
    }
    if let Some(param_value) = params.new_order_resp_type {
        multipart_form_params.insert("newOrderRespType", param_value.to_string());
    }
    multipart_form_params.insert("price", params.price.to_string());
    multipart_form_params.insert("quantity", params.quantity.to_string());
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    if let Some(param_value) = params.self_trade_prevention_mode {
        multipart_form_params.insert("selfTradePreventionMode", param_value.to_string());
    }
    multipart_form_params.insert("side", params.side.to_string());
    if let Some(param_value) = params.side_effect_type {
        multipart_form_params.insert("sideEffectType", param_value.to_string());
    }
    if let Some(param_value) = params.stop_client_order_id {
        multipart_form_params.insert("stopClientOrderId", param_value.to_string());
    }
    if let Some(param_value) = params.stop_iceberg_qty {
        multipart_form_params.insert("stopIcebergQty", param_value.to_string());
    }
    if let Some(param_value) = params.stop_limit_price {
        multipart_form_params.insert("stopLimitPrice", param_value.to_string());
    }
    if let Some(param_value) = params.stop_limit_time_in_force {
        multipart_form_params.insert("stopLimitTimeInForce", param_value.to_string());
    }
    multipart_form_params.insert("stopPrice", params.stop_price.to_string());
    multipart_form_params.insert("symbol", params.symbol.to_string());
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MarginCreateMarginOrderOcoV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MarginCreateMarginOrderOcoV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MarginCreateMarginOrderOcoV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Post a new OTO order for margin account:
pub async fn margin_create_margin_order_oto_v1(configuration: &configuration::Configuration, params: MarginCreateMarginOrderOtoV1Params) -> Result<models::MarginCreateMarginOrderOtoV1Resp, Error<MarginCreateMarginOrderOtoV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/order/oto", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    if let Some(param_value) = params.auto_repay_at_cancel {
        multipart_form_params.insert("autoRepayAtCancel", param_value.to_string());
    }
    if let Some(param_value) = params.is_isolated {
        multipart_form_params.insert("isIsolated", param_value.to_string());
    }
    if let Some(param_value) = params.list_client_order_id {
        multipart_form_params.insert("listClientOrderId", param_value.to_string());
    }
    if let Some(param_value) = params.new_order_resp_type {
        multipart_form_params.insert("newOrderRespType", param_value.to_string());
    }
    if let Some(param_value) = params.pending_client_order_id {
        multipart_form_params.insert("pendingClientOrderId", param_value.to_string());
    }
    if let Some(param_value) = params.pending_iceberg_qty {
        multipart_form_params.insert("pendingIcebergQty", param_value.to_string());
    }
    if let Some(param_value) = params.pending_price {
        multipart_form_params.insert("pendingPrice", param_value.to_string());
    }
    multipart_form_params.insert("pendingQuantity", params.pending_quantity.to_string());
    multipart_form_params.insert("pendingSide", params.pending_side.to_string());
    if let Some(param_value) = params.pending_stop_price {
        multipart_form_params.insert("pendingStopPrice", param_value.to_string());
    }
    if let Some(param_value) = params.pending_time_in_force {
        multipart_form_params.insert("pendingTimeInForce", param_value.to_string());
    }
    if let Some(param_value) = params.pending_trailing_delta {
        multipart_form_params.insert("pendingTrailingDelta", param_value.to_string());
    }
    multipart_form_params.insert("pendingType", params.pending_type.to_string());
    if let Some(param_value) = params.self_trade_prevention_mode {
        multipart_form_params.insert("selfTradePreventionMode", param_value.to_string());
    }
    if let Some(param_value) = params.side_effect_type {
        multipart_form_params.insert("sideEffectType", param_value.to_string());
    }
    multipart_form_params.insert("symbol", params.symbol.to_string());
    if let Some(param_value) = params.working_client_order_id {
        multipart_form_params.insert("workingClientOrderId", param_value.to_string());
    }
    multipart_form_params.insert("workingIcebergQty", params.working_iceberg_qty.to_string());
    multipart_form_params.insert("workingPrice", params.working_price.to_string());
    multipart_form_params.insert("workingQuantity", params.working_quantity.to_string());
    multipart_form_params.insert("workingSide", params.working_side.to_string());
    if let Some(param_value) = params.working_time_in_force {
        multipart_form_params.insert("workingTimeInForce", param_value.to_string());
    }
    multipart_form_params.insert("workingType", params.working_type.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MarginCreateMarginOrderOtoV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MarginCreateMarginOrderOtoV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MarginCreateMarginOrderOtoV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Post a new OTOCO order for margin account：
pub async fn margin_create_margin_order_otoco_v1(configuration: &configuration::Configuration, params: MarginCreateMarginOrderOtocoV1Params) -> Result<models::MarginCreateMarginOrderOtocoV1Resp, Error<MarginCreateMarginOrderOtocoV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/order/otoco", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    if let Some(param_value) = params.auto_repay_at_cancel {
        multipart_form_params.insert("autoRepayAtCancel", param_value.to_string());
    }
    if let Some(param_value) = params.is_isolated {
        multipart_form_params.insert("isIsolated", param_value.to_string());
    }
    if let Some(param_value) = params.list_client_order_id {
        multipart_form_params.insert("listClientOrderId", param_value.to_string());
    }
    if let Some(param_value) = params.new_order_resp_type {
        multipart_form_params.insert("newOrderRespType", param_value.to_string());
    }
    if let Some(param_value) = params.pending_above_client_order_id {
        multipart_form_params.insert("pendingAboveClientOrderId", param_value.to_string());
    }
    if let Some(param_value) = params.pending_above_iceberg_qty {
        multipart_form_params.insert("pendingAboveIcebergQty", param_value.to_string());
    }
    if let Some(param_value) = params.pending_above_price {
        multipart_form_params.insert("pendingAbovePrice", param_value.to_string());
    }
    if let Some(param_value) = params.pending_above_stop_price {
        multipart_form_params.insert("pendingAboveStopPrice", param_value.to_string());
    }
    if let Some(param_value) = params.pending_above_time_in_force {
        multipart_form_params.insert("pendingAboveTimeInForce", param_value.to_string());
    }
    if let Some(param_value) = params.pending_above_trailing_delta {
        multipart_form_params.insert("pendingAboveTrailingDelta", param_value.to_string());
    }
    multipart_form_params.insert("pendingAboveType", params.pending_above_type.to_string());
    if let Some(param_value) = params.pending_below_client_order_id {
        multipart_form_params.insert("pendingBelowClientOrderId", param_value.to_string());
    }
    if let Some(param_value) = params.pending_below_iceberg_qty {
        multipart_form_params.insert("pendingBelowIcebergQty", param_value.to_string());
    }
    if let Some(param_value) = params.pending_below_price {
        multipart_form_params.insert("pendingBelowPrice", param_value.to_string());
    }
    if let Some(param_value) = params.pending_below_stop_price {
        multipart_form_params.insert("pendingBelowStopPrice", param_value.to_string());
    }
    if let Some(param_value) = params.pending_below_time_in_force {
        multipart_form_params.insert("pendingBelowTimeInForce", param_value.to_string());
    }
    if let Some(param_value) = params.pending_below_trailing_delta {
        multipart_form_params.insert("pendingBelowTrailingDelta", param_value.to_string());
    }
    if let Some(param_value) = params.pending_below_type {
        multipart_form_params.insert("pendingBelowType", param_value.to_string());
    }
    multipart_form_params.insert("pendingQuantity", params.pending_quantity.to_string());
    multipart_form_params.insert("pendingSide", params.pending_side.to_string());
    if let Some(param_value) = params.self_trade_prevention_mode {
        multipart_form_params.insert("selfTradePreventionMode", param_value.to_string());
    }
    if let Some(param_value) = params.side_effect_type {
        multipart_form_params.insert("sideEffectType", param_value.to_string());
    }
    multipart_form_params.insert("symbol", params.symbol.to_string());
    if let Some(param_value) = params.working_client_order_id {
        multipart_form_params.insert("workingClientOrderId", param_value.to_string());
    }
    if let Some(param_value) = params.working_iceberg_qty {
        multipart_form_params.insert("workingIcebergQty", param_value.to_string());
    }
    multipart_form_params.insert("workingPrice", params.working_price.to_string());
    multipart_form_params.insert("workingQuantity", params.working_quantity.to_string());
    multipart_form_params.insert("workingSide", params.working_side.to_string());
    if let Some(param_value) = params.working_time_in_force {
        multipart_form_params.insert("workingTimeInForce", param_value.to_string());
    }
    multipart_form_params.insert("workingType", params.working_type.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MarginCreateMarginOrderOtocoV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MarginCreateMarginOrderOtocoV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MarginCreateMarginOrderOtocoV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Post a new order for margin account.
pub async fn margin_create_margin_order_v1(configuration: &configuration::Configuration, params: MarginCreateMarginOrderV1Params) -> Result<models::MarginCreateMarginOrderV1Resp, Error<MarginCreateMarginOrderV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/order", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    if let Some(param_value) = params.auto_repay_at_cancel {
        multipart_form_params.insert("autoRepayAtCancel", param_value.to_string());
    }
    if let Some(param_value) = params.iceberg_qty {
        multipart_form_params.insert("icebergQty", param_value.to_string());
    }
    if let Some(param_value) = params.is_isolated {
        multipart_form_params.insert("isIsolated", param_value.to_string());
    }
    if let Some(param_value) = params.new_client_order_id {
        multipart_form_params.insert("newClientOrderId", param_value.to_string());
    }
    if let Some(param_value) = params.new_order_resp_type {
        multipart_form_params.insert("newOrderRespType", param_value.to_string());
    }
    if let Some(param_value) = params.price {
        multipart_form_params.insert("price", param_value.to_string());
    }
    if let Some(param_value) = params.quantity {
        multipart_form_params.insert("quantity", param_value.to_string());
    }
    if let Some(param_value) = params.quote_order_qty {
        multipart_form_params.insert("quoteOrderQty", param_value.to_string());
    }
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    if let Some(param_value) = params.self_trade_prevention_mode {
        multipart_form_params.insert("selfTradePreventionMode", param_value.to_string());
    }
    multipart_form_params.insert("side", params.side.to_string());
    if let Some(param_value) = params.side_effect_type {
        multipart_form_params.insert("sideEffectType", param_value.to_string());
    }
    if let Some(param_value) = params.stop_price {
        multipart_form_params.insert("stopPrice", param_value.to_string());
    }
    multipart_form_params.insert("symbol", params.symbol.to_string());
    if let Some(param_value) = params.time_in_force {
        multipart_form_params.insert("timeInForce", param_value.to_string());
    }
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    multipart_form_params.insert("type", params.r#type.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MarginCreateMarginOrderV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MarginCreateMarginOrderV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MarginCreateMarginOrderV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This only applies to Special Key for Low Latency Trading.
pub async fn margin_delete_margin_api_key_v1(configuration: &configuration::Configuration, params: MarginDeleteMarginApiKeyV1Params) -> Result<serde_json::Value, Error<MarginDeleteMarginApiKeyV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/apiKey", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.api_key {
        query_params.push(("apiKey".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.api_name {
        query_params.push(("apiName".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.symbol {
        query_params.push(("symbol".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MarginDeleteMarginApiKeyV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Cancels all active orders on a symbol for margin account. This includes OCO orders.
pub async fn margin_delete_margin_open_orders_v1(configuration: &configuration::Configuration, params: MarginDeleteMarginOpenOrdersV1Params) -> Result<Vec<models::MarginDeleteMarginOpenOrdersV1RespItem>, Error<MarginDeleteMarginOpenOrdersV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/openOrders", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    if let Some(ref param_value) = params.is_isolated {
        query_params.push(("isIsolated".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::MarginDeleteMarginOpenOrdersV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::MarginDeleteMarginOpenOrdersV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MarginDeleteMarginOpenOrdersV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Cancel an entire Order List for a margin account.
pub async fn margin_delete_margin_order_list_v1(configuration: &configuration::Configuration, params: MarginDeleteMarginOrderListV1Params) -> Result<models::MarginDeleteMarginOrderListV1Resp, Error<MarginDeleteMarginOrderListV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/orderList", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    if let Some(ref param_value) = params.is_isolated {
        query_params.push(("isIsolated".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.order_list_id {
        query_params.push(("orderListId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.list_client_order_id {
        query_params.push(("listClientOrderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.new_client_order_id {
        query_params.push(("newClientOrderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MarginDeleteMarginOrderListV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MarginDeleteMarginOrderListV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MarginDeleteMarginOrderListV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Cancel an active order for margin account.
pub async fn margin_delete_margin_order_v1(configuration: &configuration::Configuration, params: MarginDeleteMarginOrderV1Params) -> Result<models::MarginDeleteMarginOrderV1Resp, Error<MarginDeleteMarginOrderV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/order", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    if let Some(ref param_value) = params.is_isolated {
        query_params.push(("isIsolated".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.order_id {
        query_params.push(("orderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.orig_client_order_id {
        query_params.push(("origClientOrderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.new_client_order_id {
        query_params.push(("newClientOrderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MarginDeleteMarginOrderV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MarginDeleteMarginOrderV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MarginDeleteMarginOrderV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves all OCO for a specific margin account based on provided optional parameters
pub async fn margin_get_margin_all_order_list_v1(configuration: &configuration::Configuration, params: MarginGetMarginAllOrderListV1Params) -> Result<Vec<models::MarginGetMarginAllOrderListV1RespItem>, Error<MarginGetMarginAllOrderListV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/allOrderList", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.is_isolated {
        query_params.push(("isIsolated".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.symbol {
        query_params.push(("symbol".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.from_id {
        query_params.push(("fromId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.start_time {
        query_params.push(("startTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.end_time {
        query_params.push(("endTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.limit {
        query_params.push(("limit".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::MarginGetMarginAllOrderListV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::MarginGetMarginAllOrderListV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MarginGetMarginAllOrderListV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Query Margin Account's All Orders
pub async fn margin_get_margin_all_orders_v1(configuration: &configuration::Configuration, params: MarginGetMarginAllOrdersV1Params) -> Result<Vec<models::MarginGetMarginAllOrdersV1RespItem>, Error<MarginGetMarginAllOrdersV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/allOrders", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    if let Some(ref param_value) = params.is_isolated {
        query_params.push(("isIsolated".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.order_id {
        query_params.push(("orderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.start_time {
        query_params.push(("startTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.end_time {
        query_params.push(("endTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.limit {
        query_params.push(("limit".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::MarginGetMarginAllOrdersV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::MarginGetMarginAllOrdersV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MarginGetMarginAllOrdersV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This only applies to Special Key for Low Latency Trading.
pub async fn margin_get_margin_api_key_list_v1(configuration: &configuration::Configuration, params: MarginGetMarginApiKeyListV1Params) -> Result<Vec<models::MarginGetMarginApiKeyListV1RespItem>, Error<MarginGetMarginApiKeyListV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/api-key-list", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.symbol {
        query_params.push(("symbol".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::MarginGetMarginApiKeyListV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::MarginGetMarginApiKeyListV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MarginGetMarginApiKeyListV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Query Special Key Information.
pub async fn margin_get_margin_api_key_v1(configuration: &configuration::Configuration, params: MarginGetMarginApiKeyV1Params) -> Result<models::MarginGetMarginApiKeyV1Resp, Error<MarginGetMarginApiKeyV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/apiKey", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("apiKey".to_string(), params.api_key.to_string()));
    if let Some(ref param_value) = params.symbol {
        query_params.push(("symbol".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MarginGetMarginApiKeyV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MarginGetMarginApiKeyV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MarginGetMarginApiKeyV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get Small liability Exchange History
pub async fn margin_get_margin_exchange_small_liability_history_v1(configuration: &configuration::Configuration, params: MarginGetMarginExchangeSmallLiabilityHistoryV1Params) -> Result<models::MarginGetMarginExchangeSmallLiabilityHistoryV1Resp, Error<MarginGetMarginExchangeSmallLiabilityHistoryV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/exchange-small-liability-history", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("current".to_string(), params.current.to_string()));
    query_params.push(("size".to_string(), params.size.to_string()));
    if let Some(ref param_value) = params.start_time {
        query_params.push(("startTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.end_time {
        query_params.push(("endTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MarginGetMarginExchangeSmallLiabilityHistoryV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MarginGetMarginExchangeSmallLiabilityHistoryV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MarginGetMarginExchangeSmallLiabilityHistoryV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Query the coins which can be small liability exchange
pub async fn margin_get_margin_exchange_small_liability_v1(configuration: &configuration::Configuration, params: MarginGetMarginExchangeSmallLiabilityV1Params) -> Result<Vec<models::MarginGetMarginExchangeSmallLiabilityV1RespItem>, Error<MarginGetMarginExchangeSmallLiabilityV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/exchange-small-liability", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::MarginGetMarginExchangeSmallLiabilityV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::MarginGetMarginExchangeSmallLiabilityV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MarginGetMarginExchangeSmallLiabilityV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get Force Liquidation Record
pub async fn margin_get_margin_force_liquidation_rec_v1(configuration: &configuration::Configuration, params: MarginGetMarginForceLiquidationRecV1Params) -> Result<models::MarginGetMarginForceLiquidationRecV1Resp, Error<MarginGetMarginForceLiquidationRecV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/forceLiquidationRec", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.start_time {
        query_params.push(("startTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.end_time {
        query_params.push(("endTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.isolated_symbol {
        query_params.push(("isolatedSymbol".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.current {
        query_params.push(("current".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.size {
        query_params.push(("size".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MarginGetMarginForceLiquidationRecV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MarginGetMarginForceLiquidationRecV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MarginGetMarginForceLiquidationRecV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Query Margin Account's Trade List
pub async fn margin_get_margin_my_trades_v1(configuration: &configuration::Configuration, params: MarginGetMarginMyTradesV1Params) -> Result<Vec<models::MarginGetMarginMyTradesV1RespItem>, Error<MarginGetMarginMyTradesV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/myTrades", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    if let Some(ref param_value) = params.is_isolated {
        query_params.push(("isIsolated".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.order_id {
        query_params.push(("orderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.start_time {
        query_params.push(("startTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.end_time {
        query_params.push(("endTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.from_id {
        query_params.push(("fromId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.limit {
        query_params.push(("limit".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::MarginGetMarginMyTradesV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::MarginGetMarginMyTradesV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MarginGetMarginMyTradesV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Query Margin Account's Open OCO
pub async fn margin_get_margin_open_order_list_v1(configuration: &configuration::Configuration, params: MarginGetMarginOpenOrderListV1Params) -> Result<Vec<models::MarginGetMarginOpenOrderListV1RespItem>, Error<MarginGetMarginOpenOrderListV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/openOrderList", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.is_isolated {
        query_params.push(("isIsolated".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.symbol {
        query_params.push(("symbol".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::MarginGetMarginOpenOrderListV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::MarginGetMarginOpenOrderListV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MarginGetMarginOpenOrderListV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Query Margin Account's Open Orders
pub async fn margin_get_margin_open_orders_v1(configuration: &configuration::Configuration, params: MarginGetMarginOpenOrdersV1Params) -> Result<Vec<models::MarginGetMarginOpenOrdersV1RespItem>, Error<MarginGetMarginOpenOrdersV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/openOrders", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.symbol {
        query_params.push(("symbol".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.is_isolated {
        query_params.push(("isIsolated".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::MarginGetMarginOpenOrdersV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::MarginGetMarginOpenOrdersV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MarginGetMarginOpenOrdersV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves a specific OCO based on provided optional parameters
pub async fn margin_get_margin_order_list_v1(configuration: &configuration::Configuration, params: MarginGetMarginOrderListV1Params) -> Result<models::MarginGetMarginOrderListV1Resp, Error<MarginGetMarginOrderListV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/orderList", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.is_isolated {
        query_params.push(("isIsolated".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.symbol {
        query_params.push(("symbol".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.order_list_id {
        query_params.push(("orderListId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.orig_client_order_id {
        query_params.push(("origClientOrderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MarginGetMarginOrderListV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MarginGetMarginOrderListV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MarginGetMarginOrderListV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Query Margin Account's Order
pub async fn margin_get_margin_order_v1(configuration: &configuration::Configuration, params: MarginGetMarginOrderV1Params) -> Result<models::MarginGetMarginOrderV1Resp, Error<MarginGetMarginOrderV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/order", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    if let Some(ref param_value) = params.is_isolated {
        query_params.push(("isIsolated".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.order_id {
        query_params.push(("orderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.orig_client_order_id {
        query_params.push(("origClientOrderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MarginGetMarginOrderV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MarginGetMarginOrderV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MarginGetMarginOrderV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Displays the user's current margin order count usage for all intervals.
pub async fn margin_get_margin_rate_limit_order_v1(configuration: &configuration::Configuration, params: MarginGetMarginRateLimitOrderV1Params) -> Result<Vec<models::MarginGetMarginRateLimitOrderV1RespItem>, Error<MarginGetMarginRateLimitOrderV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/rateLimit/order", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.is_isolated {
        query_params.push(("isIsolated".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.symbol {
        query_params.push(("symbol".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::MarginGetMarginRateLimitOrderV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::MarginGetMarginRateLimitOrderV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MarginGetMarginRateLimitOrderV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Edit ip restriction. This only applies to Special Key for Low Latency Trading.
pub async fn margin_update_margin_api_key_ip_v1(configuration: &configuration::Configuration, params: MarginUpdateMarginApiKeyIpV1Params) -> Result<serde_json::Value, Error<MarginUpdateMarginApiKeyIpV1Error>> {

    let uri_str = format!("{}/sapi/v1/margin/apiKey/ip", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("apiKey", params.api_key.to_string());
    multipart_form_params.insert("ip", params.ip.to_string());
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    if let Some(param_value) = params.symbol {
        multipart_form_params.insert("symbol", param_value.to_string());
    }
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MarginUpdateMarginApiKeyIpV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

