/*
 * Binance USD-M Futures API
 *
 * OpenAPI specification for Binance exchange - Umfutures API
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::derivatives::umfutures::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};

/// struct for passing parameters to the method [`umfutures_create_batch_orders_v1`]
#[derive(Clone, Debug, Default)]
pub struct UmfuturesCreateBatchOrdersV1Params {
    pub batch_orders: Vec<models::UmfuturesCreateBatchOrdersV1ReqBatchOrdersItem>,
    pub timestamp: i64,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`umfutures_create_countdown_cancel_all_v1`]
#[derive(Clone, Debug, Default)]
pub struct UmfuturesCreateCountdownCancelAllV1Params {
    pub umfutures_create_countdown_cancel_all_v1_req: Option<models::UmfuturesCreateCountdownCancelAllV1Req>
}

/// struct for passing parameters to the method [`umfutures_create_leverage_v1`]
#[derive(Clone, Debug, Default)]
pub struct UmfuturesCreateLeverageV1Params {
    pub leverage: i32,
    pub symbol: String,
    pub timestamp: i64,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`umfutures_create_margin_type_v1`]
#[derive(Clone, Debug, Default)]
pub struct UmfuturesCreateMarginTypeV1Params {
    pub margin_type: String,
    pub symbol: String,
    pub timestamp: i64,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`umfutures_create_multi_assets_margin_v1`]
#[derive(Clone, Debug, Default)]
pub struct UmfuturesCreateMultiAssetsMarginV1Params {
    pub multi_assets_margin: String,
    pub timestamp: i64,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`umfutures_create_order_test_v1`]
#[derive(Clone, Debug, Default)]
pub struct UmfuturesCreateOrderTestV1Params {
    pub side: String,
    pub symbol: String,
    pub timestamp: i64,
    pub r#type: String,
    pub activation_price: Option<String>,
    pub callback_rate: Option<String>,
    pub close_position: Option<String>,
    pub good_till_date: Option<i64>,
    pub new_client_order_id: Option<String>,
    pub new_order_resp_type: Option<String>,
    pub position_side: Option<String>,
    pub price: Option<String>,
    pub price_match: Option<String>,
    pub price_protect: Option<String>,
    pub quantity: Option<String>,
    pub recv_window: Option<i64>,
    pub reduce_only: Option<String>,
    pub self_trade_prevention_mode: Option<String>,
    pub stop_price: Option<String>,
    pub time_in_force: Option<String>,
    pub working_type: Option<String>
}

/// struct for passing parameters to the method [`umfutures_create_order_v1`]
#[derive(Clone, Debug, Default)]
pub struct UmfuturesCreateOrderV1Params {
    pub side: String,
    pub symbol: String,
    pub timestamp: i64,
    pub r#type: String,
    pub activation_price: Option<String>,
    pub callback_rate: Option<String>,
    pub close_position: Option<String>,
    pub good_till_date: Option<i64>,
    pub new_client_order_id: Option<String>,
    pub new_order_resp_type: Option<String>,
    pub position_side: Option<String>,
    pub price: Option<String>,
    pub price_match: Option<String>,
    pub price_protect: Option<String>,
    pub quantity: Option<String>,
    pub recv_window: Option<i64>,
    pub reduce_only: Option<String>,
    pub self_trade_prevention_mode: Option<String>,
    pub stop_price: Option<String>,
    pub time_in_force: Option<String>,
    pub working_type: Option<String>
}

/// struct for passing parameters to the method [`umfutures_create_position_margin_v1`]
#[derive(Clone, Debug, Default)]
pub struct UmfuturesCreatePositionMarginV1Params {
    pub amount: String,
    pub symbol: String,
    pub timestamp: i64,
    pub r#type: i32,
    pub position_side: Option<String>,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`umfutures_create_position_side_dual_v1`]
#[derive(Clone, Debug, Default)]
pub struct UmfuturesCreatePositionSideDualV1Params {
    pub dual_side_position: String,
    pub timestamp: i64,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`umfutures_delete_all_open_orders_v1`]
#[derive(Clone, Debug, Default)]
pub struct UmfuturesDeleteAllOpenOrdersV1Params {
    pub symbol: String,
    pub timestamp: i64,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`umfutures_delete_batch_orders_v1`]
#[derive(Clone, Debug, Default)]
pub struct UmfuturesDeleteBatchOrdersV1Params {
    pub symbol: String,
    pub timestamp: i64,
    /// max length 10 <br/> e.g. [1234567,2345678]
    pub order_id_list: Option<Vec<i64>>,
    /// max length 10<br/> e.g. [&#34;my_id_1&#34;,&#34;my_id_2&#34;], encode the double quotes. No space after comma.
    pub orig_client_order_id_list: Option<Vec<String>>,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`umfutures_delete_order_v1`]
#[derive(Clone, Debug, Default)]
pub struct UmfuturesDeleteOrderV1Params {
    pub symbol: String,
    pub timestamp: i64,
    pub order_id: Option<i64>,
    pub orig_client_order_id: Option<String>,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`umfutures_get_adl_quantile_v1`]
#[derive(Clone, Debug, Default)]
pub struct UmfuturesGetAdlQuantileV1Params {
    pub timestamp: i64,
    pub symbol: Option<String>,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`umfutures_get_all_orders_v1`]
#[derive(Clone, Debug, Default)]
pub struct UmfuturesGetAllOrdersV1Params {
    pub symbol: String,
    pub timestamp: i64,
    pub order_id: Option<i64>,
    pub start_time: Option<i64>,
    pub end_time: Option<i64>,
    /// Default 500; max 1000.
    pub limit: Option<i32>,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`umfutures_get_force_orders_v1`]
#[derive(Clone, Debug, Default)]
pub struct UmfuturesGetForceOrdersV1Params {
    pub timestamp: i64,
    pub symbol: Option<String>,
    /// &#34;LIQUIDATION&#34; for liquidation orders, &#34;ADL&#34; for ADL orders.
    pub auto_close_type: Option<String>,
    pub start_time: Option<i64>,
    pub end_time: Option<i64>,
    /// Default 50; max 100.
    pub limit: Option<i32>,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`umfutures_get_open_order_v1`]
#[derive(Clone, Debug, Default)]
pub struct UmfuturesGetOpenOrderV1Params {
    pub symbol: String,
    pub timestamp: i64,
    pub order_id: Option<i64>,
    pub orig_client_order_id: Option<String>,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`umfutures_get_open_orders_v1`]
#[derive(Clone, Debug, Default)]
pub struct UmfuturesGetOpenOrdersV1Params {
    pub timestamp: i64,
    pub symbol: Option<String>,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`umfutures_get_order_amendment_v1`]
#[derive(Clone, Debug, Default)]
pub struct UmfuturesGetOrderAmendmentV1Params {
    pub symbol: String,
    pub timestamp: i64,
    pub order_id: Option<i64>,
    pub orig_client_order_id: Option<String>,
    /// Timestamp in ms to get modification history from INCLUSIVE
    pub start_time: Option<i64>,
    /// Timestamp in ms to get modification history until INCLUSIVE
    pub end_time: Option<i64>,
    /// Default 50; max 100
    pub limit: Option<i32>,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`umfutures_get_order_v1`]
#[derive(Clone, Debug, Default)]
pub struct UmfuturesGetOrderV1Params {
    pub symbol: String,
    pub timestamp: i64,
    pub order_id: Option<i64>,
    pub orig_client_order_id: Option<String>,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`umfutures_get_position_margin_history_v1`]
#[derive(Clone, Debug, Default)]
pub struct UmfuturesGetPositionMarginHistoryV1Params {
    pub symbol: String,
    pub timestamp: i64,
    /// 1: Add position marginï¼Œ2: Reduce position margin
    pub r#type: Option<i32>,
    pub start_time: Option<i64>,
    /// Default current time if not pass
    pub end_time: Option<i64>,
    /// Default: 500
    pub limit: Option<i32>,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`umfutures_get_position_risk_v2`]
#[derive(Clone, Debug, Default)]
pub struct UmfuturesGetPositionRiskV2Params {
    pub timestamp: i64,
    pub symbol: Option<String>,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`umfutures_get_position_risk_v3`]
#[derive(Clone, Debug, Default)]
pub struct UmfuturesGetPositionRiskV3Params {
    pub timestamp: i64,
    pub symbol: Option<String>,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`umfutures_get_user_trades_v1`]
#[derive(Clone, Debug, Default)]
pub struct UmfuturesGetUserTradesV1Params {
    pub symbol: String,
    pub timestamp: i64,
    /// This can only be used in combination with `symbol`
    pub order_id: Option<i64>,
    pub start_time: Option<i64>,
    pub end_time: Option<i64>,
    /// Trade id to fetch from. Default gets most recent trades.
    pub from_id: Option<i64>,
    /// Default 500; max 1000.
    pub limit: Option<i32>,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`umfutures_update_batch_orders_v1`]
#[derive(Clone, Debug, Default)]
pub struct UmfuturesUpdateBatchOrdersV1Params {
    pub batch_orders: Vec<models::UmfuturesUpdateBatchOrdersV1ReqBatchOrdersItem>,
    pub timestamp: i64,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`umfutures_update_order_v1`]
#[derive(Clone, Debug, Default)]
pub struct UmfuturesUpdateOrderV1Params {
    pub price: String,
    pub quantity: String,
    pub side: String,
    pub symbol: String,
    pub timestamp: i64,
    pub order_id: Option<i64>,
    pub orig_client_order_id: Option<String>,
    pub price_match: Option<String>,
    pub recv_window: Option<i64>
}


/// struct for typed errors of method [`umfutures_create_batch_orders_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UmfuturesCreateBatchOrdersV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`umfutures_create_countdown_cancel_all_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UmfuturesCreateCountdownCancelAllV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`umfutures_create_leverage_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UmfuturesCreateLeverageV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`umfutures_create_margin_type_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UmfuturesCreateMarginTypeV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`umfutures_create_multi_assets_margin_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UmfuturesCreateMultiAssetsMarginV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`umfutures_create_order_test_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UmfuturesCreateOrderTestV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`umfutures_create_order_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UmfuturesCreateOrderV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`umfutures_create_position_margin_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UmfuturesCreatePositionMarginV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`umfutures_create_position_side_dual_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UmfuturesCreatePositionSideDualV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`umfutures_delete_all_open_orders_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UmfuturesDeleteAllOpenOrdersV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`umfutures_delete_batch_orders_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UmfuturesDeleteBatchOrdersV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`umfutures_delete_order_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UmfuturesDeleteOrderV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`umfutures_get_adl_quantile_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UmfuturesGetAdlQuantileV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`umfutures_get_all_orders_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UmfuturesGetAllOrdersV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`umfutures_get_force_orders_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UmfuturesGetForceOrdersV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`umfutures_get_open_order_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UmfuturesGetOpenOrderV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`umfutures_get_open_orders_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UmfuturesGetOpenOrdersV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`umfutures_get_order_amendment_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UmfuturesGetOrderAmendmentV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`umfutures_get_order_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UmfuturesGetOrderV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`umfutures_get_position_margin_history_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UmfuturesGetPositionMarginHistoryV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`umfutures_get_position_risk_v2`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UmfuturesGetPositionRiskV2Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`umfutures_get_position_risk_v3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UmfuturesGetPositionRiskV3Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`umfutures_get_user_trades_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UmfuturesGetUserTradesV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`umfutures_update_batch_orders_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UmfuturesUpdateBatchOrdersV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`umfutures_update_order_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UmfuturesUpdateOrderV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}


/// Place Multiple Orders
pub async fn umfutures_create_batch_orders_v1(configuration: &configuration::Configuration, params: UmfuturesCreateBatchOrdersV1Params) -> Result<Vec<models::UmfuturesCreateBatchOrdersV1RespInner>, Error<UmfuturesCreateBatchOrdersV1Error>> {

    let uri_str = format!("{}/fapi/v1/batchOrders", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("batchOrders", params.batch_orders.into_iter().map(|p| serde_json::to_string(&p).unwrap_or_default()).collect::<Vec<String>>().join(",").to_string());
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UmfuturesCreateBatchOrdersV1RespInner&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UmfuturesCreateBatchOrdersV1RespInner&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UmfuturesCreateBatchOrdersV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Cancel all open orders of the specified symbol at the end of the specified countdown. The endpoint should be called repeatedly as heartbeats so that the existing countdown time can be canceled and replaced by a new one.
pub async fn umfutures_create_countdown_cancel_all_v1(configuration: &configuration::Configuration, params: UmfuturesCreateCountdownCancelAllV1Params) -> Result<models::UmfuturesCreateCountdownCancelAllV1Resp, Error<UmfuturesCreateCountdownCancelAllV1Error>> {

    let uri_str = format!("{}/fapi/v1/countdownCancelAll", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string = match serde_json::to_string(&params.umfutures_create_countdown_cancel_all_v1_req) {
            Ok(json) => Some(json.into_bytes()),
            Err(e) => return Err(Error::Serde(e)),
        };
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    req_builder = req_builder.json(&params.umfutures_create_countdown_cancel_all_v1_req);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UmfuturesCreateCountdownCancelAllV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UmfuturesCreateCountdownCancelAllV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UmfuturesCreateCountdownCancelAllV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Change user's initial leverage of specific symbol market.
pub async fn umfutures_create_leverage_v1(configuration: &configuration::Configuration, params: UmfuturesCreateLeverageV1Params) -> Result<models::UmfuturesCreateLeverageV1Resp, Error<UmfuturesCreateLeverageV1Error>> {

    let uri_str = format!("{}/fapi/v1/leverage", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("leverage", params.leverage.to_string());
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    multipart_form_params.insert("symbol", params.symbol.to_string());
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UmfuturesCreateLeverageV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UmfuturesCreateLeverageV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UmfuturesCreateLeverageV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Change symbol level margin type
pub async fn umfutures_create_margin_type_v1(configuration: &configuration::Configuration, params: UmfuturesCreateMarginTypeV1Params) -> Result<models::UmfuturesCreateMarginTypeV1Resp, Error<UmfuturesCreateMarginTypeV1Error>> {

    let uri_str = format!("{}/fapi/v1/marginType", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("marginType", params.margin_type.to_string());
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    multipart_form_params.insert("symbol", params.symbol.to_string());
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UmfuturesCreateMarginTypeV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UmfuturesCreateMarginTypeV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UmfuturesCreateMarginTypeV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Change user's Multi-Assets mode (Multi-Assets Mode or Single-Asset Mode) on Every symbol
pub async fn umfutures_create_multi_assets_margin_v1(configuration: &configuration::Configuration, params: UmfuturesCreateMultiAssetsMarginV1Params) -> Result<models::UmfuturesCreateMultiAssetsMarginV1Resp, Error<UmfuturesCreateMultiAssetsMarginV1Error>> {

    let uri_str = format!("{}/fapi/v1/multiAssetsMargin", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("multiAssetsMargin", params.multi_assets_margin.to_string());
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UmfuturesCreateMultiAssetsMarginV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UmfuturesCreateMultiAssetsMarginV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UmfuturesCreateMultiAssetsMarginV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Testing order request, this order will not be submitted to matching engine
pub async fn umfutures_create_order_test_v1(configuration: &configuration::Configuration, params: UmfuturesCreateOrderTestV1Params) -> Result<models::UmfuturesCreateOrderTestV1Resp, Error<UmfuturesCreateOrderTestV1Error>> {

    let uri_str = format!("{}/fapi/v1/order/test", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    if let Some(param_value) = params.activation_price {
        multipart_form_params.insert("activationPrice", param_value.to_string());
    }
    if let Some(param_value) = params.callback_rate {
        multipart_form_params.insert("callbackRate", param_value.to_string());
    }
    if let Some(param_value) = params.close_position {
        multipart_form_params.insert("closePosition", param_value.to_string());
    }
    if let Some(param_value) = params.good_till_date {
        multipart_form_params.insert("goodTillDate", param_value.to_string());
    }
    if let Some(param_value) = params.new_client_order_id {
        multipart_form_params.insert("newClientOrderId", param_value.to_string());
    }
    if let Some(param_value) = params.new_order_resp_type {
        multipart_form_params.insert("newOrderRespType", param_value.to_string());
    }
    if let Some(param_value) = params.position_side {
        multipart_form_params.insert("positionSide", param_value.to_string());
    }
    if let Some(param_value) = params.price {
        multipart_form_params.insert("price", param_value.to_string());
    }
    if let Some(param_value) = params.price_match {
        multipart_form_params.insert("priceMatch", param_value.to_string());
    }
    if let Some(param_value) = params.price_protect {
        multipart_form_params.insert("priceProtect", param_value.to_string());
    }
    if let Some(param_value) = params.quantity {
        multipart_form_params.insert("quantity", param_value.to_string());
    }
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    if let Some(param_value) = params.reduce_only {
        multipart_form_params.insert("reduceOnly", param_value.to_string());
    }
    if let Some(param_value) = params.self_trade_prevention_mode {
        multipart_form_params.insert("selfTradePreventionMode", param_value.to_string());
    }
    multipart_form_params.insert("side", params.side.to_string());
    if let Some(param_value) = params.stop_price {
        multipart_form_params.insert("stopPrice", param_value.to_string());
    }
    multipart_form_params.insert("symbol", params.symbol.to_string());
    if let Some(param_value) = params.time_in_force {
        multipart_form_params.insert("timeInForce", param_value.to_string());
    }
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    multipart_form_params.insert("type", params.r#type.to_string());
    if let Some(param_value) = params.working_type {
        multipart_form_params.insert("workingType", param_value.to_string());
    }
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UmfuturesCreateOrderTestV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UmfuturesCreateOrderTestV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UmfuturesCreateOrderTestV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Send in a new order.
pub async fn umfutures_create_order_v1(configuration: &configuration::Configuration, params: UmfuturesCreateOrderV1Params) -> Result<models::UmfuturesCreateOrderV1Resp, Error<UmfuturesCreateOrderV1Error>> {

    let uri_str = format!("{}/fapi/v1/order", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    if let Some(param_value) = params.activation_price {
        multipart_form_params.insert("activationPrice", param_value.to_string());
    }
    if let Some(param_value) = params.callback_rate {
        multipart_form_params.insert("callbackRate", param_value.to_string());
    }
    if let Some(param_value) = params.close_position {
        multipart_form_params.insert("closePosition", param_value.to_string());
    }
    if let Some(param_value) = params.good_till_date {
        multipart_form_params.insert("goodTillDate", param_value.to_string());
    }
    if let Some(param_value) = params.new_client_order_id {
        multipart_form_params.insert("newClientOrderId", param_value.to_string());
    }
    if let Some(param_value) = params.new_order_resp_type {
        multipart_form_params.insert("newOrderRespType", param_value.to_string());
    }
    if let Some(param_value) = params.position_side {
        multipart_form_params.insert("positionSide", param_value.to_string());
    }
    if let Some(param_value) = params.price {
        multipart_form_params.insert("price", param_value.to_string());
    }
    if let Some(param_value) = params.price_match {
        multipart_form_params.insert("priceMatch", param_value.to_string());
    }
    if let Some(param_value) = params.price_protect {
        multipart_form_params.insert("priceProtect", param_value.to_string());
    }
    if let Some(param_value) = params.quantity {
        multipart_form_params.insert("quantity", param_value.to_string());
    }
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    if let Some(param_value) = params.reduce_only {
        multipart_form_params.insert("reduceOnly", param_value.to_string());
    }
    if let Some(param_value) = params.self_trade_prevention_mode {
        multipart_form_params.insert("selfTradePreventionMode", param_value.to_string());
    }
    multipart_form_params.insert("side", params.side.to_string());
    if let Some(param_value) = params.stop_price {
        multipart_form_params.insert("stopPrice", param_value.to_string());
    }
    multipart_form_params.insert("symbol", params.symbol.to_string());
    if let Some(param_value) = params.time_in_force {
        multipart_form_params.insert("timeInForce", param_value.to_string());
    }
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    multipart_form_params.insert("type", params.r#type.to_string());
    if let Some(param_value) = params.working_type {
        multipart_form_params.insert("workingType", param_value.to_string());
    }
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UmfuturesCreateOrderV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UmfuturesCreateOrderV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UmfuturesCreateOrderV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Modify Isolated Position Margin
pub async fn umfutures_create_position_margin_v1(configuration: &configuration::Configuration, params: UmfuturesCreatePositionMarginV1Params) -> Result<models::UmfuturesCreatePositionMarginV1Resp, Error<UmfuturesCreatePositionMarginV1Error>> {

    let uri_str = format!("{}/fapi/v1/positionMargin", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("amount", params.amount.to_string());
    if let Some(param_value) = params.position_side {
        multipart_form_params.insert("positionSide", param_value.to_string());
    }
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    multipart_form_params.insert("symbol", params.symbol.to_string());
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    multipart_form_params.insert("type", params.r#type.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UmfuturesCreatePositionMarginV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UmfuturesCreatePositionMarginV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UmfuturesCreatePositionMarginV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Change user's position mode (Hedge Mode or One-way Mode ) on EVERY symbol
pub async fn umfutures_create_position_side_dual_v1(configuration: &configuration::Configuration, params: UmfuturesCreatePositionSideDualV1Params) -> Result<models::UmfuturesCreatePositionSideDualV1Resp, Error<UmfuturesCreatePositionSideDualV1Error>> {

    let uri_str = format!("{}/fapi/v1/positionSide/dual", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("dualSidePosition", params.dual_side_position.to_string());
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UmfuturesCreatePositionSideDualV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UmfuturesCreatePositionSideDualV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UmfuturesCreatePositionSideDualV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Cancel All Open Orders
pub async fn umfutures_delete_all_open_orders_v1(configuration: &configuration::Configuration, params: UmfuturesDeleteAllOpenOrdersV1Params) -> Result<models::UmfuturesDeleteAllOpenOrdersV1Resp, Error<UmfuturesDeleteAllOpenOrdersV1Error>> {

    let uri_str = format!("{}/fapi/v1/allOpenOrders", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UmfuturesDeleteAllOpenOrdersV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UmfuturesDeleteAllOpenOrdersV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UmfuturesDeleteAllOpenOrdersV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Cancel Multiple Orders
pub async fn umfutures_delete_batch_orders_v1(configuration: &configuration::Configuration, params: UmfuturesDeleteBatchOrdersV1Params) -> Result<Vec<models::UmfuturesDeleteBatchOrdersV1RespInner>, Error<UmfuturesDeleteBatchOrdersV1Error>> {

    let uri_str = format!("{}/fapi/v1/batchOrders", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    if let Some(ref param_value) = params.order_id_list {
        match "multi" {
            "multi" => {
                for p in param_value {
                    query_params.push(("orderIdList".to_string(), p.to_string()));
                }
            },
            _ => {
                let joined = param_value.iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",");
                query_params.push(("orderIdList".to_string(), joined));
            }
        };
    }
    if let Some(ref param_value) = params.orig_client_order_id_list {
        match "multi" {
            "multi" => {
                for p in param_value {
                    query_params.push(("origClientOrderIdList".to_string(), p.to_string()));
                }
            },
            _ => {
                let joined = param_value.iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",");
                query_params.push(("origClientOrderIdList".to_string(), joined));
            }
        };
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UmfuturesDeleteBatchOrdersV1RespInner&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UmfuturesDeleteBatchOrdersV1RespInner&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UmfuturesDeleteBatchOrdersV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Cancel an active order.
pub async fn umfutures_delete_order_v1(configuration: &configuration::Configuration, params: UmfuturesDeleteOrderV1Params) -> Result<models::UmfuturesDeleteOrderV1Resp, Error<UmfuturesDeleteOrderV1Error>> {

    let uri_str = format!("{}/fapi/v1/order", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    if let Some(ref param_value) = params.order_id {
        query_params.push(("orderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.orig_client_order_id {
        query_params.push(("origClientOrderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UmfuturesDeleteOrderV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UmfuturesDeleteOrderV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UmfuturesDeleteOrderV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Position ADL Quantile Estimation
pub async fn umfutures_get_adl_quantile_v1(configuration: &configuration::Configuration, params: UmfuturesGetAdlQuantileV1Params) -> Result<Vec<models::UmfuturesGetAdlQuantileV1RespItem>, Error<UmfuturesGetAdlQuantileV1Error>> {

    let uri_str = format!("{}/fapi/v1/adlQuantile", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.symbol {
        query_params.push(("symbol".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UmfuturesGetAdlQuantileV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UmfuturesGetAdlQuantileV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UmfuturesGetAdlQuantileV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get all account orders; active, canceled, or filled.
pub async fn umfutures_get_all_orders_v1(configuration: &configuration::Configuration, params: UmfuturesGetAllOrdersV1Params) -> Result<Vec<models::UmfuturesGetAllOrdersV1RespItem>, Error<UmfuturesGetAllOrdersV1Error>> {

    let uri_str = format!("{}/fapi/v1/allOrders", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    if let Some(ref param_value) = params.order_id {
        query_params.push(("orderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.start_time {
        query_params.push(("startTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.end_time {
        query_params.push(("endTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.limit {
        query_params.push(("limit".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UmfuturesGetAllOrdersV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UmfuturesGetAllOrdersV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UmfuturesGetAllOrdersV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Query user's Force Orders
pub async fn umfutures_get_force_orders_v1(configuration: &configuration::Configuration, params: UmfuturesGetForceOrdersV1Params) -> Result<Vec<models::UmfuturesGetForceOrdersV1RespItem>, Error<UmfuturesGetForceOrdersV1Error>> {

    let uri_str = format!("{}/fapi/v1/forceOrders", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.symbol {
        query_params.push(("symbol".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.auto_close_type {
        query_params.push(("autoCloseType".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.start_time {
        query_params.push(("startTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.end_time {
        query_params.push(("endTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.limit {
        query_params.push(("limit".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UmfuturesGetForceOrdersV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UmfuturesGetForceOrdersV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UmfuturesGetForceOrdersV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Query open order
pub async fn umfutures_get_open_order_v1(configuration: &configuration::Configuration, params: UmfuturesGetOpenOrderV1Params) -> Result<models::UmfuturesGetOpenOrderV1Resp, Error<UmfuturesGetOpenOrderV1Error>> {

    let uri_str = format!("{}/fapi/v1/openOrder", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    if let Some(ref param_value) = params.order_id {
        query_params.push(("orderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.orig_client_order_id {
        query_params.push(("origClientOrderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UmfuturesGetOpenOrderV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UmfuturesGetOpenOrderV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UmfuturesGetOpenOrderV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get all open orders on a symbol.
pub async fn umfutures_get_open_orders_v1(configuration: &configuration::Configuration, params: UmfuturesGetOpenOrdersV1Params) -> Result<Vec<models::UmfuturesGetOpenOrdersV1RespItem>, Error<UmfuturesGetOpenOrdersV1Error>> {

    let uri_str = format!("{}/fapi/v1/openOrders", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.symbol {
        query_params.push(("symbol".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UmfuturesGetOpenOrdersV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UmfuturesGetOpenOrdersV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UmfuturesGetOpenOrdersV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get order modification history
pub async fn umfutures_get_order_amendment_v1(configuration: &configuration::Configuration, params: UmfuturesGetOrderAmendmentV1Params) -> Result<Vec<models::UmfuturesGetOrderAmendmentV1RespItem>, Error<UmfuturesGetOrderAmendmentV1Error>> {

    let uri_str = format!("{}/fapi/v1/orderAmendment", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    if let Some(ref param_value) = params.order_id {
        query_params.push(("orderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.orig_client_order_id {
        query_params.push(("origClientOrderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.start_time {
        query_params.push(("startTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.end_time {
        query_params.push(("endTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.limit {
        query_params.push(("limit".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UmfuturesGetOrderAmendmentV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UmfuturesGetOrderAmendmentV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UmfuturesGetOrderAmendmentV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Check an order's status.
pub async fn umfutures_get_order_v1(configuration: &configuration::Configuration, params: UmfuturesGetOrderV1Params) -> Result<models::UmfuturesGetOrderV1Resp, Error<UmfuturesGetOrderV1Error>> {

    let uri_str = format!("{}/fapi/v1/order", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    if let Some(ref param_value) = params.order_id {
        query_params.push(("orderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.orig_client_order_id {
        query_params.push(("origClientOrderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UmfuturesGetOrderV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UmfuturesGetOrderV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UmfuturesGetOrderV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get Position Margin Change History
pub async fn umfutures_get_position_margin_history_v1(configuration: &configuration::Configuration, params: UmfuturesGetPositionMarginHistoryV1Params) -> Result<Vec<models::UmfuturesGetPositionMarginHistoryV1RespItem>, Error<UmfuturesGetPositionMarginHistoryV1Error>> {

    let uri_str = format!("{}/fapi/v1/positionMargin/history", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    if let Some(ref param_value) = params.r#type {
        query_params.push(("type".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.start_time {
        query_params.push(("startTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.end_time {
        query_params.push(("endTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.limit {
        query_params.push(("limit".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UmfuturesGetPositionMarginHistoryV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UmfuturesGetPositionMarginHistoryV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UmfuturesGetPositionMarginHistoryV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get current position information.
pub async fn umfutures_get_position_risk_v2(configuration: &configuration::Configuration, params: UmfuturesGetPositionRiskV2Params) -> Result<Vec<models::UmfuturesGetPositionRiskV2RespItem>, Error<UmfuturesGetPositionRiskV2Error>> {

    let uri_str = format!("{}/fapi/v2/positionRisk", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.symbol {
        query_params.push(("symbol".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UmfuturesGetPositionRiskV2RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UmfuturesGetPositionRiskV2RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UmfuturesGetPositionRiskV2Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get current position information(only symbol that has position or open orders will be returned).
pub async fn umfutures_get_position_risk_v3(configuration: &configuration::Configuration, params: UmfuturesGetPositionRiskV3Params) -> Result<Vec<models::UmfuturesGetPositionRiskV3RespItem>, Error<UmfuturesGetPositionRiskV3Error>> {

    let uri_str = format!("{}/fapi/v3/positionRisk", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.symbol {
        query_params.push(("symbol".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UmfuturesGetPositionRiskV3RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UmfuturesGetPositionRiskV3RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UmfuturesGetPositionRiskV3Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get trades for a specific account and symbol.
pub async fn umfutures_get_user_trades_v1(configuration: &configuration::Configuration, params: UmfuturesGetUserTradesV1Params) -> Result<Vec<models::UmfuturesGetUserTradesV1RespItem>, Error<UmfuturesGetUserTradesV1Error>> {

    let uri_str = format!("{}/fapi/v1/userTrades", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    if let Some(ref param_value) = params.order_id {
        query_params.push(("orderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.start_time {
        query_params.push(("startTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.end_time {
        query_params.push(("endTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.from_id {
        query_params.push(("fromId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.limit {
        query_params.push(("limit".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UmfuturesGetUserTradesV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UmfuturesGetUserTradesV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UmfuturesGetUserTradesV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Modify Multiple Orders (TRADE)
pub async fn umfutures_update_batch_orders_v1(configuration: &configuration::Configuration, params: UmfuturesUpdateBatchOrdersV1Params) -> Result<Vec<models::UmfuturesUpdateBatchOrdersV1RespItem>, Error<UmfuturesUpdateBatchOrdersV1Error>> {

    let uri_str = format!("{}/fapi/v1/batchOrders", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("batchOrders", params.batch_orders.into_iter().map(|p| serde_json::to_string(&p).unwrap_or_default()).collect::<Vec<String>>().join(",").to_string());
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UmfuturesUpdateBatchOrdersV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UmfuturesUpdateBatchOrdersV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UmfuturesUpdateBatchOrdersV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
pub async fn umfutures_update_order_v1(configuration: &configuration::Configuration, params: UmfuturesUpdateOrderV1Params) -> Result<models::UmfuturesUpdateOrderV1Resp, Error<UmfuturesUpdateOrderV1Error>> {

    let uri_str = format!("{}/fapi/v1/order", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    if let Some(param_value) = params.order_id {
        multipart_form_params.insert("orderId", param_value.to_string());
    }
    if let Some(param_value) = params.orig_client_order_id {
        multipart_form_params.insert("origClientOrderId", param_value.to_string());
    }
    multipart_form_params.insert("price", params.price.to_string());
    if let Some(param_value) = params.price_match {
        multipart_form_params.insert("priceMatch", param_value.to_string());
    }
    multipart_form_params.insert("quantity", params.quantity.to_string());
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    multipart_form_params.insert("side", params.side.to_string());
    multipart_form_params.insert("symbol", params.symbol.to_string());
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UmfuturesUpdateOrderV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UmfuturesUpdateOrderV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UmfuturesUpdateOrderV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

