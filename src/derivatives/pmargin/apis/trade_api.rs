/*
 * Binance Portfolio Margin API
 *
 * OpenAPI specification for Binance exchange - Pmargin API
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::derivatives::pmargin::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};

/// struct for passing parameters to the method [`pmargin_create_cm_conditional_order_v1`]
#[derive(Clone, Debug, Default)]
pub struct PmarginCreateCmConditionalOrderV1Params {
    pub side: String,
    pub strategy_type: String,
    pub symbol: String,
    pub timestamp: i64,
    pub activation_price: Option<String>,
    pub callback_rate: Option<String>,
    pub new_client_strategy_id: Option<String>,
    pub position_side: Option<String>,
    pub price: Option<String>,
    pub price_protect: Option<String>,
    pub quantity: Option<String>,
    pub recv_window: Option<i64>,
    pub reduce_only: Option<String>,
    pub stop_price: Option<String>,
    pub time_in_force: Option<String>,
    pub working_type: Option<String>
}

/// struct for passing parameters to the method [`pmargin_create_cm_order_v1`]
#[derive(Clone, Debug, Default)]
pub struct PmarginCreateCmOrderV1Params {
    pub side: String,
    pub symbol: String,
    pub timestamp: i64,
    pub r#type: String,
    pub new_client_order_id: Option<String>,
    pub new_order_resp_type: Option<String>,
    pub position_side: Option<String>,
    pub price: Option<String>,
    pub price_match: Option<String>,
    pub quantity: Option<String>,
    pub recv_window: Option<i64>,
    pub reduce_only: Option<String>,
    pub time_in_force: Option<String>
}

/// struct for passing parameters to the method [`pmargin_create_margin_loan_v1`]
#[derive(Clone, Debug, Default)]
pub struct PmarginCreateMarginLoanV1Params {
    pub amount: String,
    pub asset: String,
    pub timestamp: i64,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`pmargin_create_margin_order_oco_v1`]
#[derive(Clone, Debug, Default)]
pub struct PmarginCreateMarginOrderOcoV1Params {
    pub price: String,
    pub quantity: String,
    pub side: String,
    pub stop_price: String,
    pub symbol: String,
    pub timestamp: i64,
    pub limit_client_order_id: Option<String>,
    pub limit_iceberg_qty: Option<String>,
    pub list_client_order_id: Option<String>,
    pub new_order_resp_type: Option<String>,
    pub recv_window: Option<i64>,
    pub side_effect_type: Option<String>,
    pub stop_client_order_id: Option<String>,
    pub stop_iceberg_qty: Option<String>,
    pub stop_limit_price: Option<String>,
    pub stop_limit_time_in_force: Option<String>
}

/// struct for passing parameters to the method [`pmargin_create_margin_order_v1`]
#[derive(Clone, Debug, Default)]
pub struct PmarginCreateMarginOrderV1Params {
    pub side: String,
    pub symbol: String,
    pub timestamp: i64,
    pub r#type: String,
    pub auto_repay_at_cancel: Option<bool>,
    pub iceberg_qty: Option<String>,
    pub new_client_order_id: Option<String>,
    pub new_order_resp_type: Option<String>,
    pub price: Option<String>,
    pub quantity: Option<String>,
    pub quote_order_qty: Option<String>,
    pub recv_window: Option<i64>,
    pub self_trade_prevention_mode: Option<String>,
    pub side_effect_type: Option<String>,
    pub stop_price: Option<String>,
    pub time_in_force: Option<String>
}

/// struct for passing parameters to the method [`pmargin_create_margin_repay_debt_v1`]
#[derive(Clone, Debug, Default)]
pub struct PmarginCreateMarginRepayDebtV1Params {
    pub asset: String,
    pub timestamp: i64,
    pub amount: Option<String>,
    pub recv_window: Option<i64>,
    pub specify_repay_assets: Option<String>
}

/// struct for passing parameters to the method [`pmargin_create_repay_loan_v1`]
#[derive(Clone, Debug, Default)]
pub struct PmarginCreateRepayLoanV1Params {
    pub amount: String,
    pub asset: String,
    pub timestamp: i64,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`pmargin_create_um_conditional_order_v1`]
#[derive(Clone, Debug, Default)]
pub struct PmarginCreateUmConditionalOrderV1Params {
    pub side: String,
    pub strategy_type: String,
    pub symbol: String,
    pub timestamp: i64,
    pub activation_price: Option<String>,
    pub callback_rate: Option<String>,
    pub good_till_date: Option<i64>,
    pub new_client_strategy_id: Option<String>,
    pub position_side: Option<String>,
    pub price: Option<String>,
    pub price_match: Option<String>,
    pub price_protect: Option<String>,
    pub quantity: Option<String>,
    pub recv_window: Option<i64>,
    pub reduce_only: Option<String>,
    pub self_trade_prevention_mode: Option<String>,
    pub stop_price: Option<String>,
    pub time_in_force: Option<String>,
    pub working_type: Option<String>
}

/// struct for passing parameters to the method [`pmargin_create_um_fee_burn_v1`]
#[derive(Clone, Debug, Default)]
pub struct PmarginCreateUmFeeBurnV1Params {
    pub fee_burn: String,
    pub timestamp: i64,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`pmargin_create_um_order_v1`]
#[derive(Clone, Debug, Default)]
pub struct PmarginCreateUmOrderV1Params {
    pub side: String,
    pub symbol: String,
    pub timestamp: i64,
    pub r#type: String,
    pub good_till_date: Option<i64>,
    pub new_client_order_id: Option<String>,
    pub new_order_resp_type: Option<String>,
    pub position_side: Option<String>,
    pub price: Option<String>,
    pub price_match: Option<String>,
    pub quantity: Option<String>,
    pub recv_window: Option<i64>,
    pub reduce_only: Option<String>,
    pub self_trade_prevention_mode: Option<String>,
    pub time_in_force: Option<String>
}

/// struct for passing parameters to the method [`pmargin_delete_cm_all_open_orders_v1`]
#[derive(Clone, Debug, Default)]
pub struct PmarginDeleteCmAllOpenOrdersV1Params {
    pub symbol: String,
    pub timestamp: i64,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`pmargin_delete_cm_conditional_all_open_orders_v1`]
#[derive(Clone, Debug, Default)]
pub struct PmarginDeleteCmConditionalAllOpenOrdersV1Params {
    pub symbol: String,
    pub timestamp: i64,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`pmargin_delete_cm_conditional_order_v1`]
#[derive(Clone, Debug, Default)]
pub struct PmarginDeleteCmConditionalOrderV1Params {
    pub symbol: String,
    pub timestamp: i64,
    pub strategy_id: Option<i64>,
    pub new_client_strategy_id: Option<String>,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`pmargin_delete_cm_order_v1`]
#[derive(Clone, Debug, Default)]
pub struct PmarginDeleteCmOrderV1Params {
    pub symbol: String,
    pub timestamp: i64,
    pub order_id: Option<i64>,
    pub orig_client_order_id: Option<String>,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`pmargin_delete_margin_all_open_orders_v1`]
#[derive(Clone, Debug, Default)]
pub struct PmarginDeleteMarginAllOpenOrdersV1Params {
    pub symbol: String,
    pub timestamp: i64,
    /// The value cannot be greater than 60000
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`pmargin_delete_margin_order_list_v1`]
#[derive(Clone, Debug, Default)]
pub struct PmarginDeleteMarginOrderListV1Params {
    pub symbol: String,
    pub timestamp: i64,
    /// Either `orderListId` or `listClientOrderId` must be provided
    pub order_list_id: Option<i64>,
    /// Either `orderListId` or `listClientOrderId` must be provided
    pub list_client_order_id: Option<String>,
    /// Used to uniquely identify this cancel. Automatically generated by default
    pub new_client_order_id: Option<String>,
    /// The value cannot be greater than 60000
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`pmargin_delete_margin_order_v1`]
#[derive(Clone, Debug, Default)]
pub struct PmarginDeleteMarginOrderV1Params {
    pub symbol: String,
    pub timestamp: i64,
    pub order_id: Option<i64>,
    pub orig_client_order_id: Option<String>,
    /// Used to uniquely identify this cancel. Automatically generated by default.
    pub new_client_order_id: Option<String>,
    /// The value cannot be greater than `60000`
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`pmargin_delete_um_all_open_orders_v1`]
#[derive(Clone, Debug, Default)]
pub struct PmarginDeleteUmAllOpenOrdersV1Params {
    pub symbol: String,
    pub timestamp: i64,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`pmargin_delete_um_conditional_all_open_orders_v1`]
#[derive(Clone, Debug, Default)]
pub struct PmarginDeleteUmConditionalAllOpenOrdersV1Params {
    pub symbol: String,
    pub timestamp: i64,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`pmargin_delete_um_conditional_order_v1`]
#[derive(Clone, Debug, Default)]
pub struct PmarginDeleteUmConditionalOrderV1Params {
    pub symbol: String,
    pub timestamp: i64,
    pub strategy_id: Option<i64>,
    pub new_client_strategy_id: Option<String>,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`pmargin_delete_um_order_v1`]
#[derive(Clone, Debug, Default)]
pub struct PmarginDeleteUmOrderV1Params {
    pub symbol: String,
    pub timestamp: i64,
    pub order_id: Option<i64>,
    pub orig_client_order_id: Option<String>,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`pmargin_get_cm_all_orders_v1`]
#[derive(Clone, Debug, Default)]
pub struct PmarginGetCmAllOrdersV1Params {
    pub symbol: String,
    pub timestamp: i64,
    pub pair: Option<String>,
    pub order_id: Option<i64>,
    pub start_time: Option<i64>,
    pub end_time: Option<i64>,
    /// Default 50; max 100.
    pub limit: Option<i32>,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`pmargin_get_cm_conditional_all_orders_v1`]
#[derive(Clone, Debug, Default)]
pub struct PmarginGetCmConditionalAllOrdersV1Params {
    pub timestamp: i64,
    pub symbol: Option<String>,
    pub strategy_id: Option<i64>,
    pub start_time: Option<i64>,
    pub end_time: Option<i64>,
    /// Default 500; max 1000.
    pub limit: Option<i32>,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`pmargin_get_cm_conditional_open_order_v1`]
#[derive(Clone, Debug, Default)]
pub struct PmarginGetCmConditionalOpenOrderV1Params {
    pub symbol: String,
    pub timestamp: i64,
    pub strategy_id: Option<i64>,
    pub new_client_strategy_id: Option<String>,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`pmargin_get_cm_conditional_open_orders_v1`]
#[derive(Clone, Debug, Default)]
pub struct PmarginGetCmConditionalOpenOrdersV1Params {
    pub timestamp: i64,
    pub symbol: Option<String>,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`pmargin_get_cm_conditional_order_history_v1`]
#[derive(Clone, Debug, Default)]
pub struct PmarginGetCmConditionalOrderHistoryV1Params {
    pub symbol: String,
    pub timestamp: i64,
    pub strategy_id: Option<i64>,
    pub new_client_strategy_id: Option<String>,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`pmargin_get_cm_force_orders_v1`]
#[derive(Clone, Debug, Default)]
pub struct PmarginGetCmForceOrdersV1Params {
    pub timestamp: i64,
    pub symbol: Option<String>,
    /// &#34;LIQUIDATION&#34; for liquidation orders, &#34;ADL&#34; for ADL orders.
    pub auto_close_type: Option<String>,
    pub start_time: Option<i64>,
    pub end_time: Option<i64>,
    /// Default 50; max 100.
    pub limit: Option<i32>,
    /// The value cannot be greater than 60000
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`pmargin_get_cm_open_order_v1`]
#[derive(Clone, Debug, Default)]
pub struct PmarginGetCmOpenOrderV1Params {
    pub symbol: String,
    pub timestamp: i64,
    pub order_id: Option<i64>,
    pub orig_client_order_id: Option<String>,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`pmargin_get_cm_open_orders_v1`]
#[derive(Clone, Debug, Default)]
pub struct PmarginGetCmOpenOrdersV1Params {
    pub timestamp: i64,
    pub symbol: Option<String>,
    pub pair: Option<String>,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`pmargin_get_cm_order_amendment_v1`]
#[derive(Clone, Debug, Default)]
pub struct PmarginGetCmOrderAmendmentV1Params {
    pub symbol: String,
    pub timestamp: i64,
    pub order_id: Option<i64>,
    pub orig_client_order_id: Option<String>,
    /// Timestamp in ms to get modification history from INCLUSIVE
    pub start_time: Option<i64>,
    /// Timestamp in ms to get modification history until INCLUSIVE
    pub end_time: Option<i64>,
    /// Default 50, max 100
    pub limit: Option<i32>,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`pmargin_get_cm_order_v1`]
#[derive(Clone, Debug, Default)]
pub struct PmarginGetCmOrderV1Params {
    pub symbol: String,
    pub timestamp: i64,
    pub order_id: Option<i64>,
    pub orig_client_order_id: Option<String>,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`pmargin_get_cm_user_trades_v1`]
#[derive(Clone, Debug, Default)]
pub struct PmarginGetCmUserTradesV1Params {
    pub timestamp: i64,
    pub symbol: Option<String>,
    pub pair: Option<String>,
    pub start_time: Option<i64>,
    pub end_time: Option<i64>,
    /// Trade id to fetch from. Default gets most recent trades.
    pub from_id: Option<i64>,
    /// Default 50; max 1000.
    pub limit: Option<i32>,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`pmargin_get_margin_all_order_list_v1`]
#[derive(Clone, Debug, Default)]
pub struct PmarginGetMarginAllOrderListV1Params {
    pub timestamp: i64,
    /// If supplied, neither startTime or endTime can be provided
    pub from_id: Option<i64>,
    pub start_time: Option<i64>,
    pub end_time: Option<i64>,
    /// Default 500; max 500.
    pub limit: Option<i32>,
    /// The value cannot be greater than 60000
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`pmargin_get_margin_all_orders_v1`]
#[derive(Clone, Debug, Default)]
pub struct PmarginGetMarginAllOrdersV1Params {
    pub symbol: String,
    pub timestamp: i64,
    pub order_id: Option<i64>,
    pub start_time: Option<i64>,
    pub end_time: Option<i64>,
    /// Default 500; max 500.
    pub limit: Option<i32>,
    /// The value cannot be greater than 60000
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`pmargin_get_margin_force_orders_v1`]
#[derive(Clone, Debug, Default)]
pub struct PmarginGetMarginForceOrdersV1Params {
    pub timestamp: i64,
    pub start_time: Option<i64>,
    pub end_time: Option<i64>,
    /// Currently querying page. Start from 1. Default:1
    pub current: Option<i64>,
    /// Default:10 Max:100
    pub size: Option<i64>,
    /// The value cannot be greater than 60000
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`pmargin_get_margin_my_trades_v1`]
#[derive(Clone, Debug, Default)]
pub struct PmarginGetMarginMyTradesV1Params {
    pub symbol: String,
    pub timestamp: i64,
    pub order_id: Option<i64>,
    pub start_time: Option<i64>,
    pub end_time: Option<i64>,
    /// TradeId to fetch from. Default gets most recent trades.
    pub from_id: Option<i64>,
    /// Default 500; max 1000.
    pub limit: Option<i32>,
    /// The value cannot be greater than 60000
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`pmargin_get_margin_open_order_list_v1`]
#[derive(Clone, Debug, Default)]
pub struct PmarginGetMarginOpenOrderListV1Params {
    pub timestamp: i64,
    /// The value cannot be greater than 60000
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`pmargin_get_margin_open_orders_v1`]
#[derive(Clone, Debug, Default)]
pub struct PmarginGetMarginOpenOrdersV1Params {
    pub symbol: String,
    pub timestamp: i64,
    /// The value cannot be greater than 60000
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`pmargin_get_margin_order_list_v1`]
#[derive(Clone, Debug, Default)]
pub struct PmarginGetMarginOrderListV1Params {
    pub timestamp: i64,
    /// Either orderListId or origClientOrderId must be provided
    pub order_list_id: Option<i64>,
    /// Either orderListId or origClientOrderId must be provided
    pub orig_client_order_id: Option<String>,
    /// The value cannot be greater than 60000
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`pmargin_get_margin_order_v1`]
#[derive(Clone, Debug, Default)]
pub struct PmarginGetMarginOrderV1Params {
    pub symbol: String,
    pub timestamp: i64,
    pub order_id: Option<i64>,
    pub orig_client_order_id: Option<String>,
    /// The value cannot be greater than 60000
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`pmargin_get_um_adl_quantile_v1`]
#[derive(Clone, Debug, Default)]
pub struct PmarginGetUmAdlQuantileV1Params {
    pub timestamp: i64,
    pub symbol: Option<String>,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`pmargin_get_um_all_orders_v1`]
#[derive(Clone, Debug, Default)]
pub struct PmarginGetUmAllOrdersV1Params {
    pub symbol: String,
    pub timestamp: i64,
    pub order_id: Option<i64>,
    pub start_time: Option<i64>,
    pub end_time: Option<i64>,
    /// Default 500; max 1000.
    pub limit: Option<i32>,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`pmargin_get_um_conditional_all_orders_v1`]
#[derive(Clone, Debug, Default)]
pub struct PmarginGetUmConditionalAllOrdersV1Params {
    pub timestamp: i64,
    pub symbol: Option<String>,
    pub strategy_id: Option<i64>,
    pub start_time: Option<i64>,
    pub end_time: Option<i64>,
    /// Default 500; max 1000.
    pub limit: Option<i32>,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`pmargin_get_um_conditional_open_order_v1`]
#[derive(Clone, Debug, Default)]
pub struct PmarginGetUmConditionalOpenOrderV1Params {
    pub symbol: String,
    pub timestamp: i64,
    pub strategy_id: Option<i64>,
    pub new_client_strategy_id: Option<String>,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`pmargin_get_um_conditional_order_history_v1`]
#[derive(Clone, Debug, Default)]
pub struct PmarginGetUmConditionalOrderHistoryV1Params {
    pub symbol: String,
    pub timestamp: i64,
    pub strategy_id: Option<i64>,
    pub new_client_strategy_id: Option<String>,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`pmargin_get_um_fee_burn_v1`]
#[derive(Clone, Debug, Default)]
pub struct PmarginGetUmFeeBurnV1Params {
    pub timestamp: i64,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`pmargin_get_um_force_orders_v1`]
#[derive(Clone, Debug, Default)]
pub struct PmarginGetUmForceOrdersV1Params {
    pub timestamp: i64,
    pub symbol: Option<String>,
    /// `LIQUIDATION` for liquidation orders, `ADL` for ADL orders.
    pub auto_close_type: Option<String>,
    pub start_time: Option<i64>,
    pub end_time: Option<i64>,
    /// Default 50; max 100.
    pub limit: Option<i32>,
    /// The value cannot be greater than 60000
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`pmargin_get_um_open_order_v1`]
#[derive(Clone, Debug, Default)]
pub struct PmarginGetUmOpenOrderV1Params {
    pub symbol: String,
    pub timestamp: i64,
    pub order_id: Option<i64>,
    pub orig_client_order_id: Option<String>,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`pmargin_get_um_open_orders_v1`]
#[derive(Clone, Debug, Default)]
pub struct PmarginGetUmOpenOrdersV1Params {
    pub timestamp: i64,
    pub symbol: Option<String>,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`pmargin_get_um_order_amendment_v1`]
#[derive(Clone, Debug, Default)]
pub struct PmarginGetUmOrderAmendmentV1Params {
    pub symbol: String,
    pub timestamp: i64,
    pub order_id: Option<i64>,
    pub orig_client_order_id: Option<String>,
    /// Timestamp in ms to get modification history from INCLUSIVE
    pub start_time: Option<i64>,
    /// Timestamp in ms to get modification history until INCLUSIVE
    pub end_time: Option<i64>,
    /// Default 500, max 1000
    pub limit: Option<i32>,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`pmargin_get_um_order_v1`]
#[derive(Clone, Debug, Default)]
pub struct PmarginGetUmOrderV1Params {
    pub symbol: String,
    pub timestamp: i64,
    pub order_id: Option<i64>,
    pub orig_client_order_id: Option<String>,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`pmargin_get_um_user_trades_v1`]
#[derive(Clone, Debug, Default)]
pub struct PmarginGetUmUserTradesV1Params {
    pub symbol: String,
    pub timestamp: i64,
    pub start_time: Option<i64>,
    pub end_time: Option<i64>,
    /// Trade id to fetch from. Default gets most recent trades.
    pub from_id: Option<i64>,
    /// Default 500; max 1000.
    pub limit: Option<i32>,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`pmargin_update_cm_order_v1`]
#[derive(Clone, Debug, Default)]
pub struct PmarginUpdateCmOrderV1Params {
    pub price: String,
    pub quantity: String,
    pub side: String,
    pub symbol: String,
    pub timestamp: i64,
    pub order_id: Option<i64>,
    pub orig_client_order_id: Option<String>,
    pub price_match: Option<String>,
    pub recv_window: Option<i64>
}

/// struct for passing parameters to the method [`pmargin_update_um_order_v1`]
#[derive(Clone, Debug, Default)]
pub struct PmarginUpdateUmOrderV1Params {
    pub price: String,
    pub quantity: String,
    pub side: String,
    pub symbol: String,
    pub timestamp: i64,
    pub order_id: Option<i64>,
    pub orig_client_order_id: Option<String>,
    pub price_match: Option<String>,
    pub recv_window: Option<i64>
}


/// struct for typed errors of method [`pmargin_create_cm_conditional_order_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PmarginCreateCmConditionalOrderV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pmargin_create_cm_order_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PmarginCreateCmOrderV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pmargin_create_margin_loan_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PmarginCreateMarginLoanV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pmargin_create_margin_order_oco_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PmarginCreateMarginOrderOcoV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pmargin_create_margin_order_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PmarginCreateMarginOrderV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pmargin_create_margin_repay_debt_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PmarginCreateMarginRepayDebtV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pmargin_create_repay_loan_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PmarginCreateRepayLoanV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pmargin_create_um_conditional_order_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PmarginCreateUmConditionalOrderV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pmargin_create_um_fee_burn_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PmarginCreateUmFeeBurnV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pmargin_create_um_order_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PmarginCreateUmOrderV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pmargin_delete_cm_all_open_orders_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PmarginDeleteCmAllOpenOrdersV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pmargin_delete_cm_conditional_all_open_orders_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PmarginDeleteCmConditionalAllOpenOrdersV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pmargin_delete_cm_conditional_order_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PmarginDeleteCmConditionalOrderV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pmargin_delete_cm_order_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PmarginDeleteCmOrderV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pmargin_delete_margin_all_open_orders_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PmarginDeleteMarginAllOpenOrdersV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pmargin_delete_margin_order_list_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PmarginDeleteMarginOrderListV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pmargin_delete_margin_order_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PmarginDeleteMarginOrderV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pmargin_delete_um_all_open_orders_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PmarginDeleteUmAllOpenOrdersV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pmargin_delete_um_conditional_all_open_orders_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PmarginDeleteUmConditionalAllOpenOrdersV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pmargin_delete_um_conditional_order_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PmarginDeleteUmConditionalOrderV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pmargin_delete_um_order_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PmarginDeleteUmOrderV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pmargin_get_cm_adl_quantile_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PmarginGetCmAdlQuantileV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pmargin_get_cm_all_orders_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PmarginGetCmAllOrdersV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pmargin_get_cm_conditional_all_orders_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PmarginGetCmConditionalAllOrdersV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pmargin_get_cm_conditional_open_order_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PmarginGetCmConditionalOpenOrderV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pmargin_get_cm_conditional_open_orders_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PmarginGetCmConditionalOpenOrdersV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pmargin_get_cm_conditional_order_history_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PmarginGetCmConditionalOrderHistoryV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pmargin_get_cm_force_orders_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PmarginGetCmForceOrdersV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pmargin_get_cm_open_order_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PmarginGetCmOpenOrderV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pmargin_get_cm_open_orders_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PmarginGetCmOpenOrdersV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pmargin_get_cm_order_amendment_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PmarginGetCmOrderAmendmentV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pmargin_get_cm_order_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PmarginGetCmOrderV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pmargin_get_cm_user_trades_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PmarginGetCmUserTradesV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pmargin_get_margin_all_order_list_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PmarginGetMarginAllOrderListV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pmargin_get_margin_all_orders_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PmarginGetMarginAllOrdersV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pmargin_get_margin_force_orders_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PmarginGetMarginForceOrdersV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pmargin_get_margin_my_trades_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PmarginGetMarginMyTradesV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pmargin_get_margin_open_order_list_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PmarginGetMarginOpenOrderListV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pmargin_get_margin_open_orders_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PmarginGetMarginOpenOrdersV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pmargin_get_margin_order_list_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PmarginGetMarginOrderListV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pmargin_get_margin_order_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PmarginGetMarginOrderV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pmargin_get_um_adl_quantile_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PmarginGetUmAdlQuantileV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pmargin_get_um_all_orders_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PmarginGetUmAllOrdersV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pmargin_get_um_conditional_all_orders_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PmarginGetUmConditionalAllOrdersV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pmargin_get_um_conditional_open_order_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PmarginGetUmConditionalOpenOrderV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pmargin_get_um_conditional_open_orders_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PmarginGetUmConditionalOpenOrdersV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pmargin_get_um_conditional_order_history_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PmarginGetUmConditionalOrderHistoryV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pmargin_get_um_fee_burn_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PmarginGetUmFeeBurnV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pmargin_get_um_force_orders_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PmarginGetUmForceOrdersV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pmargin_get_um_open_order_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PmarginGetUmOpenOrderV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pmargin_get_um_open_orders_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PmarginGetUmOpenOrdersV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pmargin_get_um_order_amendment_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PmarginGetUmOrderAmendmentV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pmargin_get_um_order_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PmarginGetUmOrderV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pmargin_get_um_user_trades_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PmarginGetUmUserTradesV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pmargin_update_cm_order_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PmarginUpdateCmOrderV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pmargin_update_um_order_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PmarginUpdateUmOrderV1Error {
    Status4XX(models::ApiError),
    Status5XX(models::ApiError),
    UnknownValue(serde_json::Value),
}


/// New CM Conditional Order
pub async fn pmargin_create_cm_conditional_order_v1(configuration: &configuration::Configuration, params: PmarginCreateCmConditionalOrderV1Params) -> Result<models::PmarginCreateCmConditionalOrderV1Resp, Error<PmarginCreateCmConditionalOrderV1Error>> {

    let uri_str = format!("{}/papi/v1/cm/conditional/order", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    if let Some(param_value) = params.activation_price {
        multipart_form_params.insert("activationPrice", param_value.to_string());
    }
    if let Some(param_value) = params.callback_rate {
        multipart_form_params.insert("callbackRate", param_value.to_string());
    }
    if let Some(param_value) = params.new_client_strategy_id {
        multipart_form_params.insert("newClientStrategyId", param_value.to_string());
    }
    if let Some(param_value) = params.position_side {
        multipart_form_params.insert("positionSide", param_value.to_string());
    }
    if let Some(param_value) = params.price {
        multipart_form_params.insert("price", param_value.to_string());
    }
    if let Some(param_value) = params.price_protect {
        multipart_form_params.insert("priceProtect", param_value.to_string());
    }
    if let Some(param_value) = params.quantity {
        multipart_form_params.insert("quantity", param_value.to_string());
    }
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    if let Some(param_value) = params.reduce_only {
        multipart_form_params.insert("reduceOnly", param_value.to_string());
    }
    multipart_form_params.insert("side", params.side.to_string());
    if let Some(param_value) = params.stop_price {
        multipart_form_params.insert("stopPrice", param_value.to_string());
    }
    multipart_form_params.insert("strategyType", params.strategy_type.to_string());
    multipart_form_params.insert("symbol", params.symbol.to_string());
    if let Some(param_value) = params.time_in_force {
        multipart_form_params.insert("timeInForce", param_value.to_string());
    }
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    if let Some(param_value) = params.working_type {
        multipart_form_params.insert("workingType", param_value.to_string());
    }
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PmarginCreateCmConditionalOrderV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PmarginCreateCmConditionalOrderV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PmarginCreateCmConditionalOrderV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Place new CM order
pub async fn pmargin_create_cm_order_v1(configuration: &configuration::Configuration, params: PmarginCreateCmOrderV1Params) -> Result<models::PmarginCreateCmOrderV1Resp, Error<PmarginCreateCmOrderV1Error>> {

    let uri_str = format!("{}/papi/v1/cm/order", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    if let Some(param_value) = params.new_client_order_id {
        multipart_form_params.insert("newClientOrderId", param_value.to_string());
    }
    if let Some(param_value) = params.new_order_resp_type {
        multipart_form_params.insert("newOrderRespType", param_value.to_string());
    }
    if let Some(param_value) = params.position_side {
        multipart_form_params.insert("positionSide", param_value.to_string());
    }
    if let Some(param_value) = params.price {
        multipart_form_params.insert("price", param_value.to_string());
    }
    if let Some(param_value) = params.price_match {
        multipart_form_params.insert("priceMatch", param_value.to_string());
    }
    if let Some(param_value) = params.quantity {
        multipart_form_params.insert("quantity", param_value.to_string());
    }
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    if let Some(param_value) = params.reduce_only {
        multipart_form_params.insert("reduceOnly", param_value.to_string());
    }
    multipart_form_params.insert("side", params.side.to_string());
    multipart_form_params.insert("symbol", params.symbol.to_string());
    if let Some(param_value) = params.time_in_force {
        multipart_form_params.insert("timeInForce", param_value.to_string());
    }
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    multipart_form_params.insert("type", params.r#type.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PmarginCreateCmOrderV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PmarginCreateCmOrderV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PmarginCreateCmOrderV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Apply for a margin loan.
pub async fn pmargin_create_margin_loan_v1(configuration: &configuration::Configuration, params: PmarginCreateMarginLoanV1Params) -> Result<models::PmarginCreateMarginLoanV1Resp, Error<PmarginCreateMarginLoanV1Error>> {

    let uri_str = format!("{}/papi/v1/marginLoan", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("amount", params.amount.to_string());
    multipart_form_params.insert("asset", params.asset.to_string());
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PmarginCreateMarginLoanV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PmarginCreateMarginLoanV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PmarginCreateMarginLoanV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Send in a new OCO for a margin account
pub async fn pmargin_create_margin_order_oco_v1(configuration: &configuration::Configuration, params: PmarginCreateMarginOrderOcoV1Params) -> Result<models::PmarginCreateMarginOrderOcoV1Resp, Error<PmarginCreateMarginOrderOcoV1Error>> {

    let uri_str = format!("{}/papi/v1/margin/order/oco", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    if let Some(param_value) = params.limit_client_order_id {
        multipart_form_params.insert("limitClientOrderId", param_value.to_string());
    }
    if let Some(param_value) = params.limit_iceberg_qty {
        multipart_form_params.insert("limitIcebergQty", param_value.to_string());
    }
    if let Some(param_value) = params.list_client_order_id {
        multipart_form_params.insert("listClientOrderId", param_value.to_string());
    }
    if let Some(param_value) = params.new_order_resp_type {
        multipart_form_params.insert("newOrderRespType", param_value.to_string());
    }
    multipart_form_params.insert("price", params.price.to_string());
    multipart_form_params.insert("quantity", params.quantity.to_string());
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    multipart_form_params.insert("side", params.side.to_string());
    if let Some(param_value) = params.side_effect_type {
        multipart_form_params.insert("sideEffectType", param_value.to_string());
    }
    if let Some(param_value) = params.stop_client_order_id {
        multipart_form_params.insert("stopClientOrderId", param_value.to_string());
    }
    if let Some(param_value) = params.stop_iceberg_qty {
        multipart_form_params.insert("stopIcebergQty", param_value.to_string());
    }
    if let Some(param_value) = params.stop_limit_price {
        multipart_form_params.insert("stopLimitPrice", param_value.to_string());
    }
    if let Some(param_value) = params.stop_limit_time_in_force {
        multipart_form_params.insert("stopLimitTimeInForce", param_value.to_string());
    }
    multipart_form_params.insert("stopPrice", params.stop_price.to_string());
    multipart_form_params.insert("symbol", params.symbol.to_string());
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PmarginCreateMarginOrderOcoV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PmarginCreateMarginOrderOcoV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PmarginCreateMarginOrderOcoV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// New Margin Order
pub async fn pmargin_create_margin_order_v1(configuration: &configuration::Configuration, params: PmarginCreateMarginOrderV1Params) -> Result<models::PmarginCreateMarginOrderV1Resp, Error<PmarginCreateMarginOrderV1Error>> {

    let uri_str = format!("{}/papi/v1/margin/order", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    if let Some(param_value) = params.auto_repay_at_cancel {
        multipart_form_params.insert("autoRepayAtCancel", param_value.to_string());
    }
    if let Some(param_value) = params.iceberg_qty {
        multipart_form_params.insert("icebergQty", param_value.to_string());
    }
    if let Some(param_value) = params.new_client_order_id {
        multipart_form_params.insert("newClientOrderId", param_value.to_string());
    }
    if let Some(param_value) = params.new_order_resp_type {
        multipart_form_params.insert("newOrderRespType", param_value.to_string());
    }
    if let Some(param_value) = params.price {
        multipart_form_params.insert("price", param_value.to_string());
    }
    if let Some(param_value) = params.quantity {
        multipart_form_params.insert("quantity", param_value.to_string());
    }
    if let Some(param_value) = params.quote_order_qty {
        multipart_form_params.insert("quoteOrderQty", param_value.to_string());
    }
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    if let Some(param_value) = params.self_trade_prevention_mode {
        multipart_form_params.insert("selfTradePreventionMode", param_value.to_string());
    }
    multipart_form_params.insert("side", params.side.to_string());
    if let Some(param_value) = params.side_effect_type {
        multipart_form_params.insert("sideEffectType", param_value.to_string());
    }
    if let Some(param_value) = params.stop_price {
        multipart_form_params.insert("stopPrice", param_value.to_string());
    }
    multipart_form_params.insert("symbol", params.symbol.to_string());
    if let Some(param_value) = params.time_in_force {
        multipart_form_params.insert("timeInForce", param_value.to_string());
    }
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    multipart_form_params.insert("type", params.r#type.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PmarginCreateMarginOrderV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PmarginCreateMarginOrderV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PmarginCreateMarginOrderV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Repay debt for a margin loan.
pub async fn pmargin_create_margin_repay_debt_v1(configuration: &configuration::Configuration, params: PmarginCreateMarginRepayDebtV1Params) -> Result<models::PmarginCreateMarginRepayDebtV1Resp, Error<PmarginCreateMarginRepayDebtV1Error>> {

    let uri_str = format!("{}/papi/v1/margin/repay-debt", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    if let Some(param_value) = params.amount {
        multipart_form_params.insert("amount", param_value.to_string());
    }
    multipart_form_params.insert("asset", params.asset.to_string());
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    if let Some(param_value) = params.specify_repay_assets {
        multipart_form_params.insert("specifyRepayAssets", param_value.to_string());
    }
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PmarginCreateMarginRepayDebtV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PmarginCreateMarginRepayDebtV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PmarginCreateMarginRepayDebtV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Repay for a margin loan.
pub async fn pmargin_create_repay_loan_v1(configuration: &configuration::Configuration, params: PmarginCreateRepayLoanV1Params) -> Result<models::PmarginCreateRepayLoanV1Resp, Error<PmarginCreateRepayLoanV1Error>> {

    let uri_str = format!("{}/papi/v1/repayLoan", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("amount", params.amount.to_string());
    multipart_form_params.insert("asset", params.asset.to_string());
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PmarginCreateRepayLoanV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PmarginCreateRepayLoanV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PmarginCreateRepayLoanV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Place new UM conditional order
pub async fn pmargin_create_um_conditional_order_v1(configuration: &configuration::Configuration, params: PmarginCreateUmConditionalOrderV1Params) -> Result<models::PmarginCreateUmConditionalOrderV1Resp, Error<PmarginCreateUmConditionalOrderV1Error>> {

    let uri_str = format!("{}/papi/v1/um/conditional/order", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    if let Some(param_value) = params.activation_price {
        multipart_form_params.insert("activationPrice", param_value.to_string());
    }
    if let Some(param_value) = params.callback_rate {
        multipart_form_params.insert("callbackRate", param_value.to_string());
    }
    if let Some(param_value) = params.good_till_date {
        multipart_form_params.insert("goodTillDate", param_value.to_string());
    }
    if let Some(param_value) = params.new_client_strategy_id {
        multipart_form_params.insert("newClientStrategyId", param_value.to_string());
    }
    if let Some(param_value) = params.position_side {
        multipart_form_params.insert("positionSide", param_value.to_string());
    }
    if let Some(param_value) = params.price {
        multipart_form_params.insert("price", param_value.to_string());
    }
    if let Some(param_value) = params.price_match {
        multipart_form_params.insert("priceMatch", param_value.to_string());
    }
    if let Some(param_value) = params.price_protect {
        multipart_form_params.insert("priceProtect", param_value.to_string());
    }
    if let Some(param_value) = params.quantity {
        multipart_form_params.insert("quantity", param_value.to_string());
    }
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    if let Some(param_value) = params.reduce_only {
        multipart_form_params.insert("reduceOnly", param_value.to_string());
    }
    if let Some(param_value) = params.self_trade_prevention_mode {
        multipart_form_params.insert("selfTradePreventionMode", param_value.to_string());
    }
    multipart_form_params.insert("side", params.side.to_string());
    if let Some(param_value) = params.stop_price {
        multipart_form_params.insert("stopPrice", param_value.to_string());
    }
    multipart_form_params.insert("strategyType", params.strategy_type.to_string());
    multipart_form_params.insert("symbol", params.symbol.to_string());
    if let Some(param_value) = params.time_in_force {
        multipart_form_params.insert("timeInForce", param_value.to_string());
    }
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    if let Some(param_value) = params.working_type {
        multipart_form_params.insert("workingType", param_value.to_string());
    }
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PmarginCreateUmConditionalOrderV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PmarginCreateUmConditionalOrderV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PmarginCreateUmConditionalOrderV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Change user's BNB Fee Discount for UM Futures (Fee Discount On or Fee Discount Off ) on EVERY symbol
pub async fn pmargin_create_um_fee_burn_v1(configuration: &configuration::Configuration, params: PmarginCreateUmFeeBurnV1Params) -> Result<models::PmarginCreateUmFeeBurnV1Resp, Error<PmarginCreateUmFeeBurnV1Error>> {

    let uri_str = format!("{}/papi/v1/um/feeBurn", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("feeBurn", params.fee_burn.to_string());
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PmarginCreateUmFeeBurnV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PmarginCreateUmFeeBurnV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PmarginCreateUmFeeBurnV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Place new UM order
pub async fn pmargin_create_um_order_v1(configuration: &configuration::Configuration, params: PmarginCreateUmOrderV1Params) -> Result<models::PmarginCreateUmOrderV1Resp, Error<PmarginCreateUmOrderV1Error>> {

    let uri_str = format!("{}/papi/v1/um/order", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    if let Some(param_value) = params.good_till_date {
        multipart_form_params.insert("goodTillDate", param_value.to_string());
    }
    if let Some(param_value) = params.new_client_order_id {
        multipart_form_params.insert("newClientOrderId", param_value.to_string());
    }
    if let Some(param_value) = params.new_order_resp_type {
        multipart_form_params.insert("newOrderRespType", param_value.to_string());
    }
    if let Some(param_value) = params.position_side {
        multipart_form_params.insert("positionSide", param_value.to_string());
    }
    if let Some(param_value) = params.price {
        multipart_form_params.insert("price", param_value.to_string());
    }
    if let Some(param_value) = params.price_match {
        multipart_form_params.insert("priceMatch", param_value.to_string());
    }
    if let Some(param_value) = params.quantity {
        multipart_form_params.insert("quantity", param_value.to_string());
    }
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    if let Some(param_value) = params.reduce_only {
        multipart_form_params.insert("reduceOnly", param_value.to_string());
    }
    if let Some(param_value) = params.self_trade_prevention_mode {
        multipart_form_params.insert("selfTradePreventionMode", param_value.to_string());
    }
    multipart_form_params.insert("side", params.side.to_string());
    multipart_form_params.insert("symbol", params.symbol.to_string());
    if let Some(param_value) = params.time_in_force {
        multipart_form_params.insert("timeInForce", param_value.to_string());
    }
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    multipart_form_params.insert("type", params.r#type.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PmarginCreateUmOrderV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PmarginCreateUmOrderV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PmarginCreateUmOrderV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Cancel all active LIMIT orders on specific symbol
pub async fn pmargin_delete_cm_all_open_orders_v1(configuration: &configuration::Configuration, params: PmarginDeleteCmAllOpenOrdersV1Params) -> Result<models::PmarginDeleteCmAllOpenOrdersV1Resp, Error<PmarginDeleteCmAllOpenOrdersV1Error>> {

    let uri_str = format!("{}/papi/v1/cm/allOpenOrders", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PmarginDeleteCmAllOpenOrdersV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PmarginDeleteCmAllOpenOrdersV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PmarginDeleteCmAllOpenOrdersV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Cancel All CM Open Conditional Orders
pub async fn pmargin_delete_cm_conditional_all_open_orders_v1(configuration: &configuration::Configuration, params: PmarginDeleteCmConditionalAllOpenOrdersV1Params) -> Result<models::PmarginDeleteCmConditionalAllOpenOrdersV1Resp, Error<PmarginDeleteCmConditionalAllOpenOrdersV1Error>> {

    let uri_str = format!("{}/papi/v1/cm/conditional/allOpenOrders", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PmarginDeleteCmConditionalAllOpenOrdersV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PmarginDeleteCmConditionalAllOpenOrdersV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PmarginDeleteCmConditionalAllOpenOrdersV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Cancel CM Conditional Order
pub async fn pmargin_delete_cm_conditional_order_v1(configuration: &configuration::Configuration, params: PmarginDeleteCmConditionalOrderV1Params) -> Result<models::PmarginDeleteCmConditionalOrderV1Resp, Error<PmarginDeleteCmConditionalOrderV1Error>> {

    let uri_str = format!("{}/papi/v1/cm/conditional/order", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    if let Some(ref param_value) = params.strategy_id {
        query_params.push(("strategyId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.new_client_strategy_id {
        query_params.push(("newClientStrategyId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PmarginDeleteCmConditionalOrderV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PmarginDeleteCmConditionalOrderV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PmarginDeleteCmConditionalOrderV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Cancel an active LIMIT order
pub async fn pmargin_delete_cm_order_v1(configuration: &configuration::Configuration, params: PmarginDeleteCmOrderV1Params) -> Result<models::PmarginDeleteCmOrderV1Resp, Error<PmarginDeleteCmOrderV1Error>> {

    let uri_str = format!("{}/papi/v1/cm/order", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    if let Some(ref param_value) = params.order_id {
        query_params.push(("orderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.orig_client_order_id {
        query_params.push(("origClientOrderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PmarginDeleteCmOrderV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PmarginDeleteCmOrderV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PmarginDeleteCmOrderV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Cancel Margin Account All Open Orders on a Symbol
pub async fn pmargin_delete_margin_all_open_orders_v1(configuration: &configuration::Configuration, params: PmarginDeleteMarginAllOpenOrdersV1Params) -> Result<Vec<models::PmarginDeleteMarginAllOpenOrdersV1RespInner>, Error<PmarginDeleteMarginAllOpenOrdersV1Error>> {

    let uri_str = format!("{}/papi/v1/margin/allOpenOrders", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::PmarginDeleteMarginAllOpenOrdersV1RespInner&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::PmarginDeleteMarginAllOpenOrdersV1RespInner&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PmarginDeleteMarginAllOpenOrdersV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Cancel Margin Account OCO Orders
pub async fn pmargin_delete_margin_order_list_v1(configuration: &configuration::Configuration, params: PmarginDeleteMarginOrderListV1Params) -> Result<models::PmarginDeleteMarginOrderListV1Resp, Error<PmarginDeleteMarginOrderListV1Error>> {

    let uri_str = format!("{}/papi/v1/margin/orderList", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    if let Some(ref param_value) = params.order_list_id {
        query_params.push(("orderListId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.list_client_order_id {
        query_params.push(("listClientOrderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.new_client_order_id {
        query_params.push(("newClientOrderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PmarginDeleteMarginOrderListV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PmarginDeleteMarginOrderListV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PmarginDeleteMarginOrderListV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Cancel Margin Account Order
pub async fn pmargin_delete_margin_order_v1(configuration: &configuration::Configuration, params: PmarginDeleteMarginOrderV1Params) -> Result<models::PmarginDeleteMarginOrderV1Resp, Error<PmarginDeleteMarginOrderV1Error>> {

    let uri_str = format!("{}/papi/v1/margin/order", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    if let Some(ref param_value) = params.order_id {
        query_params.push(("orderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.orig_client_order_id {
        query_params.push(("origClientOrderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.new_client_order_id {
        query_params.push(("newClientOrderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PmarginDeleteMarginOrderV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PmarginDeleteMarginOrderV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PmarginDeleteMarginOrderV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Cancel all active LIMIT orders on specific symbol
pub async fn pmargin_delete_um_all_open_orders_v1(configuration: &configuration::Configuration, params: PmarginDeleteUmAllOpenOrdersV1Params) -> Result<models::PmarginDeleteUmAllOpenOrdersV1Resp, Error<PmarginDeleteUmAllOpenOrdersV1Error>> {

    let uri_str = format!("{}/papi/v1/um/allOpenOrders", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PmarginDeleteUmAllOpenOrdersV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PmarginDeleteUmAllOpenOrdersV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PmarginDeleteUmAllOpenOrdersV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Cancel All UM Open Conditional Orders
pub async fn pmargin_delete_um_conditional_all_open_orders_v1(configuration: &configuration::Configuration, params: PmarginDeleteUmConditionalAllOpenOrdersV1Params) -> Result<models::PmarginDeleteUmConditionalAllOpenOrdersV1Resp, Error<PmarginDeleteUmConditionalAllOpenOrdersV1Error>> {

    let uri_str = format!("{}/papi/v1/um/conditional/allOpenOrders", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PmarginDeleteUmConditionalAllOpenOrdersV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PmarginDeleteUmConditionalAllOpenOrdersV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PmarginDeleteUmConditionalAllOpenOrdersV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Cancel UM Conditional Order
pub async fn pmargin_delete_um_conditional_order_v1(configuration: &configuration::Configuration, params: PmarginDeleteUmConditionalOrderV1Params) -> Result<models::PmarginDeleteUmConditionalOrderV1Resp, Error<PmarginDeleteUmConditionalOrderV1Error>> {

    let uri_str = format!("{}/papi/v1/um/conditional/order", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    if let Some(ref param_value) = params.strategy_id {
        query_params.push(("strategyId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.new_client_strategy_id {
        query_params.push(("newClientStrategyId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PmarginDeleteUmConditionalOrderV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PmarginDeleteUmConditionalOrderV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PmarginDeleteUmConditionalOrderV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Cancel an active UM LIMIT order
pub async fn pmargin_delete_um_order_v1(configuration: &configuration::Configuration, params: PmarginDeleteUmOrderV1Params) -> Result<models::PmarginDeleteUmOrderV1Resp, Error<PmarginDeleteUmOrderV1Error>> {

    let uri_str = format!("{}/papi/v1/um/order", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    if let Some(ref param_value) = params.order_id {
        query_params.push(("orderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.orig_client_order_id {
        query_params.push(("origClientOrderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PmarginDeleteUmOrderV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PmarginDeleteUmOrderV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PmarginDeleteUmOrderV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Query CM Position ADL Quantile Estimation
pub async fn pmargin_get_cm_adl_quantile_v1(configuration: &configuration::Configuration) -> Result<Vec<models::PmarginGetCmAdlQuantileV1RespItem>, Error<PmarginGetCmAdlQuantileV1Error>> {

    let uri_str = format!("{}/papi/v1/cm/adlQuantile", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::PmarginGetCmAdlQuantileV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::PmarginGetCmAdlQuantileV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PmarginGetCmAdlQuantileV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get all account CM orders; active, canceled, or filled.
pub async fn pmargin_get_cm_all_orders_v1(configuration: &configuration::Configuration, params: PmarginGetCmAllOrdersV1Params) -> Result<Vec<models::PmarginGetCmAllOrdersV1RespItem>, Error<PmarginGetCmAllOrdersV1Error>> {

    let uri_str = format!("{}/papi/v1/cm/allOrders", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    if let Some(ref param_value) = params.pair {
        query_params.push(("pair".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.order_id {
        query_params.push(("orderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.start_time {
        query_params.push(("startTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.end_time {
        query_params.push(("endTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.limit {
        query_params.push(("limit".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::PmarginGetCmAllOrdersV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::PmarginGetCmAllOrdersV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PmarginGetCmAllOrdersV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Query All CM Conditional Orders
pub async fn pmargin_get_cm_conditional_all_orders_v1(configuration: &configuration::Configuration, params: PmarginGetCmConditionalAllOrdersV1Params) -> Result<Vec<models::PmarginGetCmConditionalAllOrdersV1RespItem>, Error<PmarginGetCmConditionalAllOrdersV1Error>> {

    let uri_str = format!("{}/papi/v1/cm/conditional/allOrders", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.symbol {
        query_params.push(("symbol".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.strategy_id {
        query_params.push(("strategyId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.start_time {
        query_params.push(("startTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.end_time {
        query_params.push(("endTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.limit {
        query_params.push(("limit".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::PmarginGetCmConditionalAllOrdersV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::PmarginGetCmConditionalAllOrdersV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PmarginGetCmConditionalAllOrdersV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Query Current CM Open Conditional Order
pub async fn pmargin_get_cm_conditional_open_order_v1(configuration: &configuration::Configuration, params: PmarginGetCmConditionalOpenOrderV1Params) -> Result<models::PmarginGetCmConditionalOpenOrderV1Resp, Error<PmarginGetCmConditionalOpenOrderV1Error>> {

    let uri_str = format!("{}/papi/v1/cm/conditional/openOrder", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    if let Some(ref param_value) = params.strategy_id {
        query_params.push(("strategyId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.new_client_strategy_id {
        query_params.push(("newClientStrategyId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PmarginGetCmConditionalOpenOrderV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PmarginGetCmConditionalOpenOrderV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PmarginGetCmConditionalOpenOrderV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get all open conditional orders on a symbol. Careful when accessing this with no symbol.
pub async fn pmargin_get_cm_conditional_open_orders_v1(configuration: &configuration::Configuration, params: PmarginGetCmConditionalOpenOrdersV1Params) -> Result<Vec<models::PmarginGetCmConditionalOpenOrdersV1RespItem>, Error<PmarginGetCmConditionalOpenOrdersV1Error>> {

    let uri_str = format!("{}/papi/v1/cm/conditional/openOrders", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.symbol {
        query_params.push(("symbol".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::PmarginGetCmConditionalOpenOrdersV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::PmarginGetCmConditionalOpenOrdersV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PmarginGetCmConditionalOpenOrdersV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Query CM Conditional Order History
pub async fn pmargin_get_cm_conditional_order_history_v1(configuration: &configuration::Configuration, params: PmarginGetCmConditionalOrderHistoryV1Params) -> Result<models::PmarginGetCmConditionalOrderHistoryV1Resp, Error<PmarginGetCmConditionalOrderHistoryV1Error>> {

    let uri_str = format!("{}/papi/v1/cm/conditional/orderHistory", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    if let Some(ref param_value) = params.strategy_id {
        query_params.push(("strategyId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.new_client_strategy_id {
        query_params.push(("newClientStrategyId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PmarginGetCmConditionalOrderHistoryV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PmarginGetCmConditionalOrderHistoryV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PmarginGetCmConditionalOrderHistoryV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Query User's CM Force Orders
pub async fn pmargin_get_cm_force_orders_v1(configuration: &configuration::Configuration, params: PmarginGetCmForceOrdersV1Params) -> Result<Vec<models::PmarginGetCmForceOrdersV1RespItem>, Error<PmarginGetCmForceOrdersV1Error>> {

    let uri_str = format!("{}/papi/v1/cm/forceOrders", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.symbol {
        query_params.push(("symbol".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.auto_close_type {
        query_params.push(("autoCloseType".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.start_time {
        query_params.push(("startTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.end_time {
        query_params.push(("endTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.limit {
        query_params.push(("limit".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::PmarginGetCmForceOrdersV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::PmarginGetCmForceOrdersV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PmarginGetCmForceOrdersV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Query current CM open order
pub async fn pmargin_get_cm_open_order_v1(configuration: &configuration::Configuration, params: PmarginGetCmOpenOrderV1Params) -> Result<models::PmarginGetCmOpenOrderV1Resp, Error<PmarginGetCmOpenOrderV1Error>> {

    let uri_str = format!("{}/papi/v1/cm/openOrder", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    if let Some(ref param_value) = params.order_id {
        query_params.push(("orderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.orig_client_order_id {
        query_params.push(("origClientOrderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PmarginGetCmOpenOrderV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PmarginGetCmOpenOrderV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PmarginGetCmOpenOrderV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get all open orders on a symbol.
pub async fn pmargin_get_cm_open_orders_v1(configuration: &configuration::Configuration, params: PmarginGetCmOpenOrdersV1Params) -> Result<Vec<models::PmarginGetCmOpenOrdersV1RespItem>, Error<PmarginGetCmOpenOrdersV1Error>> {

    let uri_str = format!("{}/papi/v1/cm/openOrders", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.symbol {
        query_params.push(("symbol".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.pair {
        query_params.push(("pair".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::PmarginGetCmOpenOrdersV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::PmarginGetCmOpenOrdersV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PmarginGetCmOpenOrdersV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get order modification history
pub async fn pmargin_get_cm_order_amendment_v1(configuration: &configuration::Configuration, params: PmarginGetCmOrderAmendmentV1Params) -> Result<Vec<models::PmarginGetCmOrderAmendmentV1RespItem>, Error<PmarginGetCmOrderAmendmentV1Error>> {

    let uri_str = format!("{}/papi/v1/cm/orderAmendment", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    if let Some(ref param_value) = params.order_id {
        query_params.push(("orderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.orig_client_order_id {
        query_params.push(("origClientOrderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.start_time {
        query_params.push(("startTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.end_time {
        query_params.push(("endTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.limit {
        query_params.push(("limit".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::PmarginGetCmOrderAmendmentV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::PmarginGetCmOrderAmendmentV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PmarginGetCmOrderAmendmentV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Check an CM order's status.
pub async fn pmargin_get_cm_order_v1(configuration: &configuration::Configuration, params: PmarginGetCmOrderV1Params) -> Result<models::PmarginGetCmOrderV1Resp, Error<PmarginGetCmOrderV1Error>> {

    let uri_str = format!("{}/papi/v1/cm/order", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    if let Some(ref param_value) = params.order_id {
        query_params.push(("orderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.orig_client_order_id {
        query_params.push(("origClientOrderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PmarginGetCmOrderV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PmarginGetCmOrderV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PmarginGetCmOrderV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get trades for a specific account and CM symbol.
pub async fn pmargin_get_cm_user_trades_v1(configuration: &configuration::Configuration, params: PmarginGetCmUserTradesV1Params) -> Result<Vec<models::PmarginGetCmUserTradesV1RespItem>, Error<PmarginGetCmUserTradesV1Error>> {

    let uri_str = format!("{}/papi/v1/cm/userTrades", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.symbol {
        query_params.push(("symbol".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.pair {
        query_params.push(("pair".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.start_time {
        query_params.push(("startTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.end_time {
        query_params.push(("endTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.from_id {
        query_params.push(("fromId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.limit {
        query_params.push(("limit".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::PmarginGetCmUserTradesV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::PmarginGetCmUserTradesV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PmarginGetCmUserTradesV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Query all OCO for a specific margin account based on provided optional parameters
pub async fn pmargin_get_margin_all_order_list_v1(configuration: &configuration::Configuration, params: PmarginGetMarginAllOrderListV1Params) -> Result<Vec<models::PmarginGetMarginAllOrderListV1RespItem>, Error<PmarginGetMarginAllOrderListV1Error>> {

    let uri_str = format!("{}/papi/v1/margin/allOrderList", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.from_id {
        query_params.push(("fromId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.start_time {
        query_params.push(("startTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.end_time {
        query_params.push(("endTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.limit {
        query_params.push(("limit".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::PmarginGetMarginAllOrderListV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::PmarginGetMarginAllOrderListV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PmarginGetMarginAllOrderListV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Query All Margin Account Orders
pub async fn pmargin_get_margin_all_orders_v1(configuration: &configuration::Configuration, params: PmarginGetMarginAllOrdersV1Params) -> Result<Vec<models::PmarginGetMarginAllOrdersV1RespItem>, Error<PmarginGetMarginAllOrdersV1Error>> {

    let uri_str = format!("{}/papi/v1/margin/allOrders", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    if let Some(ref param_value) = params.order_id {
        query_params.push(("orderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.start_time {
        query_params.push(("startTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.end_time {
        query_params.push(("endTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.limit {
        query_params.push(("limit".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::PmarginGetMarginAllOrdersV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::PmarginGetMarginAllOrdersV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PmarginGetMarginAllOrdersV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Query user's margin force orders
pub async fn pmargin_get_margin_force_orders_v1(configuration: &configuration::Configuration, params: PmarginGetMarginForceOrdersV1Params) -> Result<models::PmarginGetMarginForceOrdersV1Resp, Error<PmarginGetMarginForceOrdersV1Error>> {

    let uri_str = format!("{}/papi/v1/margin/forceOrders", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.start_time {
        query_params.push(("startTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.end_time {
        query_params.push(("endTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.current {
        query_params.push(("current".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.size {
        query_params.push(("size".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PmarginGetMarginForceOrdersV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PmarginGetMarginForceOrdersV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PmarginGetMarginForceOrdersV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Margin Account Trade List
pub async fn pmargin_get_margin_my_trades_v1(configuration: &configuration::Configuration, params: PmarginGetMarginMyTradesV1Params) -> Result<Vec<models::PmarginGetMarginMyTradesV1RespItem>, Error<PmarginGetMarginMyTradesV1Error>> {

    let uri_str = format!("{}/papi/v1/margin/myTrades", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    if let Some(ref param_value) = params.order_id {
        query_params.push(("orderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.start_time {
        query_params.push(("startTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.end_time {
        query_params.push(("endTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.from_id {
        query_params.push(("fromId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.limit {
        query_params.push(("limit".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::PmarginGetMarginMyTradesV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::PmarginGetMarginMyTradesV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PmarginGetMarginMyTradesV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Query Margin Account's Open OCO
pub async fn pmargin_get_margin_open_order_list_v1(configuration: &configuration::Configuration, params: PmarginGetMarginOpenOrderListV1Params) -> Result<Vec<models::PmarginGetMarginOpenOrderListV1RespItem>, Error<PmarginGetMarginOpenOrderListV1Error>> {

    let uri_str = format!("{}/papi/v1/margin/openOrderList", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::PmarginGetMarginOpenOrderListV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::PmarginGetMarginOpenOrderListV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PmarginGetMarginOpenOrderListV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Query Current Margin Open Order
pub async fn pmargin_get_margin_open_orders_v1(configuration: &configuration::Configuration, params: PmarginGetMarginOpenOrdersV1Params) -> Result<Vec<models::PmarginGetMarginOpenOrdersV1RespItem>, Error<PmarginGetMarginOpenOrdersV1Error>> {

    let uri_str = format!("{}/papi/v1/margin/openOrders", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::PmarginGetMarginOpenOrdersV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::PmarginGetMarginOpenOrdersV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PmarginGetMarginOpenOrdersV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves a specific OCO based on provided optional parameters
pub async fn pmargin_get_margin_order_list_v1(configuration: &configuration::Configuration, params: PmarginGetMarginOrderListV1Params) -> Result<models::PmarginGetMarginOrderListV1Resp, Error<PmarginGetMarginOrderListV1Error>> {

    let uri_str = format!("{}/papi/v1/margin/orderList", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.order_list_id {
        query_params.push(("orderListId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.orig_client_order_id {
        query_params.push(("origClientOrderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PmarginGetMarginOrderListV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PmarginGetMarginOrderListV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PmarginGetMarginOrderListV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Query Margin Account Order
pub async fn pmargin_get_margin_order_v1(configuration: &configuration::Configuration, params: PmarginGetMarginOrderV1Params) -> Result<models::PmarginGetMarginOrderV1Resp, Error<PmarginGetMarginOrderV1Error>> {

    let uri_str = format!("{}/papi/v1/margin/order", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    if let Some(ref param_value) = params.order_id {
        query_params.push(("orderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.orig_client_order_id {
        query_params.push(("origClientOrderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PmarginGetMarginOrderV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PmarginGetMarginOrderV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PmarginGetMarginOrderV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Query UM Position ADL Quantile Estimation
pub async fn pmargin_get_um_adl_quantile_v1(configuration: &configuration::Configuration, params: PmarginGetUmAdlQuantileV1Params) -> Result<Vec<models::PmarginGetUmAdlQuantileV1RespItem>, Error<PmarginGetUmAdlQuantileV1Error>> {

    let uri_str = format!("{}/papi/v1/um/adlQuantile", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.symbol {
        query_params.push(("symbol".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::PmarginGetUmAdlQuantileV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::PmarginGetUmAdlQuantileV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PmarginGetUmAdlQuantileV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get all account UM orders; active, canceled, or filled.
pub async fn pmargin_get_um_all_orders_v1(configuration: &configuration::Configuration, params: PmarginGetUmAllOrdersV1Params) -> Result<Vec<models::PmarginGetUmAllOrdersV1RespItem>, Error<PmarginGetUmAllOrdersV1Error>> {

    let uri_str = format!("{}/papi/v1/um/allOrders", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    if let Some(ref param_value) = params.order_id {
        query_params.push(("orderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.start_time {
        query_params.push(("startTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.end_time {
        query_params.push(("endTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.limit {
        query_params.push(("limit".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::PmarginGetUmAllOrdersV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::PmarginGetUmAllOrdersV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PmarginGetUmAllOrdersV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Query All UM Conditional Orders
pub async fn pmargin_get_um_conditional_all_orders_v1(configuration: &configuration::Configuration, params: PmarginGetUmConditionalAllOrdersV1Params) -> Result<Vec<models::PmarginGetUmConditionalAllOrdersV1RespItem>, Error<PmarginGetUmConditionalAllOrdersV1Error>> {

    let uri_str = format!("{}/papi/v1/um/conditional/allOrders", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.symbol {
        query_params.push(("symbol".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.strategy_id {
        query_params.push(("strategyId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.start_time {
        query_params.push(("startTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.end_time {
        query_params.push(("endTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.limit {
        query_params.push(("limit".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::PmarginGetUmConditionalAllOrdersV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::PmarginGetUmConditionalAllOrdersV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PmarginGetUmConditionalAllOrdersV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Query Current UM Open Conditional Order
pub async fn pmargin_get_um_conditional_open_order_v1(configuration: &configuration::Configuration, params: PmarginGetUmConditionalOpenOrderV1Params) -> Result<models::PmarginGetUmConditionalOpenOrderV1Resp, Error<PmarginGetUmConditionalOpenOrderV1Error>> {

    let uri_str = format!("{}/papi/v1/um/conditional/openOrder", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    if let Some(ref param_value) = params.strategy_id {
        query_params.push(("strategyId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.new_client_strategy_id {
        query_params.push(("newClientStrategyId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PmarginGetUmConditionalOpenOrderV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PmarginGetUmConditionalOpenOrderV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PmarginGetUmConditionalOpenOrderV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get all open conditional orders on a symbol.
pub async fn pmargin_get_um_conditional_open_orders_v1(configuration: &configuration::Configuration) -> Result<Vec<models::PmarginGetUmConditionalOpenOrdersV1RespItem>, Error<PmarginGetUmConditionalOpenOrdersV1Error>> {

    let uri_str = format!("{}/papi/v1/um/conditional/openOrders", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::PmarginGetUmConditionalOpenOrdersV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::PmarginGetUmConditionalOpenOrdersV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PmarginGetUmConditionalOpenOrdersV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Query UM Conditional Order History
pub async fn pmargin_get_um_conditional_order_history_v1(configuration: &configuration::Configuration, params: PmarginGetUmConditionalOrderHistoryV1Params) -> Result<models::PmarginGetUmConditionalOrderHistoryV1Resp, Error<PmarginGetUmConditionalOrderHistoryV1Error>> {

    let uri_str = format!("{}/papi/v1/um/conditional/orderHistory", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    if let Some(ref param_value) = params.strategy_id {
        query_params.push(("strategyId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.new_client_strategy_id {
        query_params.push(("newClientStrategyId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PmarginGetUmConditionalOrderHistoryV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PmarginGetUmConditionalOrderHistoryV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PmarginGetUmConditionalOrderHistoryV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get user's BNB Fee Discount for UM Futures (Fee Discount On or Fee Discount Off )
pub async fn pmargin_get_um_fee_burn_v1(configuration: &configuration::Configuration, params: PmarginGetUmFeeBurnV1Params) -> Result<models::PmarginGetUmFeeBurnV1Resp, Error<PmarginGetUmFeeBurnV1Error>> {

    let uri_str = format!("{}/papi/v1/um/feeBurn", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PmarginGetUmFeeBurnV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PmarginGetUmFeeBurnV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PmarginGetUmFeeBurnV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Query User's UM Force Orders
pub async fn pmargin_get_um_force_orders_v1(configuration: &configuration::Configuration, params: PmarginGetUmForceOrdersV1Params) -> Result<Vec<models::PmarginGetUmForceOrdersV1RespItem>, Error<PmarginGetUmForceOrdersV1Error>> {

    let uri_str = format!("{}/papi/v1/um/forceOrders", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.symbol {
        query_params.push(("symbol".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.auto_close_type {
        query_params.push(("autoCloseType".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.start_time {
        query_params.push(("startTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.end_time {
        query_params.push(("endTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.limit {
        query_params.push(("limit".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::PmarginGetUmForceOrdersV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::PmarginGetUmForceOrdersV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PmarginGetUmForceOrdersV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Query current UM open order
pub async fn pmargin_get_um_open_order_v1(configuration: &configuration::Configuration, params: PmarginGetUmOpenOrderV1Params) -> Result<models::PmarginGetUmOpenOrderV1Resp, Error<PmarginGetUmOpenOrderV1Error>> {

    let uri_str = format!("{}/papi/v1/um/openOrder", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    if let Some(ref param_value) = params.order_id {
        query_params.push(("orderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.orig_client_order_id {
        query_params.push(("origClientOrderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PmarginGetUmOpenOrderV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PmarginGetUmOpenOrderV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PmarginGetUmOpenOrderV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get all open orders on a symbol.
pub async fn pmargin_get_um_open_orders_v1(configuration: &configuration::Configuration, params: PmarginGetUmOpenOrdersV1Params) -> Result<Vec<models::PmarginGetUmOpenOrdersV1RespItem>, Error<PmarginGetUmOpenOrdersV1Error>> {

    let uri_str = format!("{}/papi/v1/um/openOrders", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    if let Some(ref param_value) = params.symbol {
        query_params.push(("symbol".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::PmarginGetUmOpenOrdersV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::PmarginGetUmOpenOrdersV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PmarginGetUmOpenOrdersV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get order modification history
pub async fn pmargin_get_um_order_amendment_v1(configuration: &configuration::Configuration, params: PmarginGetUmOrderAmendmentV1Params) -> Result<Vec<models::PmarginGetUmOrderAmendmentV1RespItem>, Error<PmarginGetUmOrderAmendmentV1Error>> {

    let uri_str = format!("{}/papi/v1/um/orderAmendment", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    if let Some(ref param_value) = params.order_id {
        query_params.push(("orderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.orig_client_order_id {
        query_params.push(("origClientOrderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.start_time {
        query_params.push(("startTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.end_time {
        query_params.push(("endTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.limit {
        query_params.push(("limit".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::PmarginGetUmOrderAmendmentV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::PmarginGetUmOrderAmendmentV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PmarginGetUmOrderAmendmentV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Check an UM order's status.
pub async fn pmargin_get_um_order_v1(configuration: &configuration::Configuration, params: PmarginGetUmOrderV1Params) -> Result<models::PmarginGetUmOrderV1Resp, Error<PmarginGetUmOrderV1Error>> {

    let uri_str = format!("{}/papi/v1/um/order", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    if let Some(ref param_value) = params.order_id {
        query_params.push(("orderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.orig_client_order_id {
        query_params.push(("origClientOrderId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PmarginGetUmOrderV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PmarginGetUmOrderV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PmarginGetUmOrderV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get trades for a specific account and UM symbol.
pub async fn pmargin_get_um_user_trades_v1(configuration: &configuration::Configuration, params: PmarginGetUmUserTradesV1Params) -> Result<Vec<models::PmarginGetUmUserTradesV1RespItem>, Error<PmarginGetUmUserTradesV1Error>> {

    let uri_str = format!("{}/papi/v1/um/userTrades", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();

    query_params.push(("symbol".to_string(), params.symbol.to_string()));
    if let Some(ref param_value) = params.start_time {
        query_params.push(("startTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.end_time {
        query_params.push(("endTime".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.from_id {
        query_params.push(("fromId".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.limit {
        query_params.push(("limit".to_string(), param_value.to_string()));
    }
    if let Some(ref param_value) = params.recv_window {
        query_params.push(("recvWindow".to_string(), param_value.to_string()));
    }
    query_params.push(("timestamp".to_string(), params.timestamp.to_string()));

    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::PmarginGetUmUserTradesV1RespItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::PmarginGetUmUserTradesV1RespItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PmarginGetUmUserTradesV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
pub async fn pmargin_update_cm_order_v1(configuration: &configuration::Configuration, params: PmarginUpdateCmOrderV1Params) -> Result<models::PmarginUpdateCmOrderV1Resp, Error<PmarginUpdateCmOrderV1Error>> {

    let uri_str = format!("{}/papi/v1/cm/order", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    if let Some(param_value) = params.order_id {
        multipart_form_params.insert("orderId", param_value.to_string());
    }
    if let Some(param_value) = params.orig_client_order_id {
        multipart_form_params.insert("origClientOrderId", param_value.to_string());
    }
    multipart_form_params.insert("price", params.price.to_string());
    if let Some(param_value) = params.price_match {
        multipart_form_params.insert("priceMatch", param_value.to_string());
    }
    multipart_form_params.insert("quantity", params.quantity.to_string());
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    multipart_form_params.insert("side", params.side.to_string());
    multipart_form_params.insert("symbol", params.symbol.to_string());
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PmarginUpdateCmOrderV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PmarginUpdateCmOrderV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PmarginUpdateCmOrderV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue
pub async fn pmargin_update_um_order_v1(configuration: &configuration::Configuration, params: PmarginUpdateUmOrderV1Params) -> Result<models::PmarginUpdateUmOrderV1Resp, Error<PmarginUpdateUmOrderV1Error>> {

    let uri_str = format!("{}/papi/v1/um/order", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    // Create a mutable vector for query parameters
    let mut query_params: Vec<(String, String)> = Vec::new();


    // Create header parameters collection
    let mut header_params = std::collections::HashMap::new();

    // Handle Binance Auth first if configured
    if let Some(ref binance_auth) = configuration.binance_auth {
        // Add API key to headers
        header_params.insert("X-MBX-APIKEY".to_string(), binance_auth.api_key().to_string());
        
        // Generate request body for signing (if any)
        let body_string: Option<Vec<u8>> = None;
        
        // Sign the request
        let signature = match binance_auth.sign(Some(&query_params), body_string.as_deref()) {
            Ok(sig) => sig,
            Err(e) => return Err(Error::Generic(format!("Failed to sign request: {}", e))),
        };
        
        // Add signature to query params
        query_params.push(("signature".to_string(), signature));
    }

    // Apply all query parameters
    if !query_params.is_empty() {
        req_builder = req_builder.query(&query_params);
    }


    // Add user agent if configured
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    // Apply all header parameters
    for (header_name, header_value) in header_params {
        req_builder = req_builder.header(&header_name, &header_value);
    }

    let mut multipart_form_params = std::collections::HashMap::new();
    if let Some(param_value) = params.order_id {
        multipart_form_params.insert("orderId", param_value.to_string());
    }
    if let Some(param_value) = params.orig_client_order_id {
        multipart_form_params.insert("origClientOrderId", param_value.to_string());
    }
    multipart_form_params.insert("price", params.price.to_string());
    if let Some(param_value) = params.price_match {
        multipart_form_params.insert("priceMatch", param_value.to_string());
    }
    multipart_form_params.insert("quantity", params.quantity.to_string());
    if let Some(param_value) = params.recv_window {
        multipart_form_params.insert("recvWindow", param_value.to_string());
    }
    multipart_form_params.insert("side", params.side.to_string());
    multipart_form_params.insert("symbol", params.symbol.to_string());
    multipart_form_params.insert("timestamp", params.timestamp.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PmarginUpdateUmOrderV1Resp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PmarginUpdateUmOrderV1Resp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PmarginUpdateUmOrderV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

